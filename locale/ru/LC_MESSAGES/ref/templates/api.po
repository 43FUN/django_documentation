# Russian translations for Django package.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
# Automatically generated <>, 2012, 2014.
#
msgid ""
msgstr ""
"Project-Id-Version: Django 1.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-09-09 11:16+0300\n"
"PO-Revision-Date: 2014-12-18 18:34+0200\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Gtranslator 2.91.6\n"

# 1d201004172a46e59165f832c52481b4
#: ../../ref/templates/api.txt:3
msgid "The Django template language: For Python programmers"
msgstr "Язык шаблонов Django: для Python программистов"

# 523ab89fd9274fffacba647757a590b2
#: ../../ref/templates/api.txt:8
msgid ""
"This document explains the Django template system from a technical "
"perspective -- how it works and how to extend it. If you're just looking for "
"reference on the language syntax, see :doc:`/topics/templates`."
msgstr ""
"Этот раздел описывает систему шаблонов Django с технической стороны -- как "
"она работает и как расширить её. Если вы ищите просто описание синтаксиса "
"шаблонов, смотрите :doc:`/topics/templates`."

# 0f7ad3c91f0a483fac3791c90a7b8508
#: ../../ref/templates/api.txt:12
msgid ""
"If you're looking to use the Django template system as part of another "
"application -- i.e., without the rest of the framework -- make sure to read "
"the `configuration`_ section later in this document."
msgstr ""
"Если вы хотите использовать систему шаблонов Django в другом приложении -- т."
"е. без всего Django -- прочитайте раздел о :ref:`настройке <configuration>`."

# c5016c1597d948c8a10aabddd092ffb7
#: ../../ref/templates/api.txt:19
msgid "Basics"
msgstr "Основы"

# 6e1167d354544442bf489d0f43826259
#: ../../ref/templates/api.txt:21
msgid ""
"A **template** is a text document, or a normal Python string, that is marked-"
"up using the Django template language. A template can contain **block tags** "
"or **variables**."
msgstr ""
"**Шаблон** -- просто текстовый документ, или строка Python, которая "
"использует язык разметки шаблонов Django. Шаблон может содержать **блочные "
"теги** или **переменные**."

# cd3854f00e4d48d0ae0fef931d6ed185
#: ../../ref/templates/api.txt:25
msgid "A **block tag** is a symbol within a template that does something."
msgstr "**Блочный тег** -- просто символ в шаблоне, который что-то означает."

# bc011e8fead7414ea49eeeed695dc6f2
#: ../../ref/templates/api.txt:27
msgid ""
"This definition is deliberately vague. For example, a block tag can output "
"content, serve as a control structure (an \"if\" statement or \"for\" loop), "
"grab content from a database or enable access to other template tags."
msgstr ""
"Это определение такое неточное намеренно. Например, блочный тег может "
"выводить текст, работать как условный оператор (\"if\" или \"for\" для "
"циклов), получать данные из базы данных или загружать другие шаблонные теги."

# 681a759e2e91403fb9bf11718eefa6de
#: ../../ref/templates/api.txt:31
msgid "Block tags are surrounded by ``\"{%\"`` and ``\"%}\"``."
msgstr "Блочные теги выделены ``\"{%\"`` и ``\"%}\"``."

# 171996132fe348919cc95b02c8b4a9ae
#: ../../ref/templates/api.txt:33
msgid "Example template with block tags:"
msgstr "Пример шаблона с блочными тегами:"

# e00ecbce5b1f4864a40e6ac8fbdfed08
#: ../../ref/templates/api.txt:39
msgid "A **variable** is a symbol within a template that outputs a value."
msgstr ""
"**Переменная** -- это символ в шаблоне, который выводит какое-то значение."

# 76199fbd4c8f4168809b0564b0980fe4
#: ../../ref/templates/api.txt:41
msgid "Variable tags are surrounded by ``\"{{\"`` and ``\"}}\"``."
msgstr "Переменные выделены ``\"{{\"`` и ``\"}}\"``."

# 00425ff901b1484c9c8ff0a725131c77
#: ../../ref/templates/api.txt:43
msgid "Example template with variables:"
msgstr "Пример шаблона с переменными:"

# c178484ab3034fbd8c70ff6f35c36fa1
#: ../../ref/templates/api.txt:49
msgid ""
"A **context** is a \"variable name\" -> \"variable value\" mapping that is "
"passed to a template."
msgstr ""
"**Контекст** -- это структура, которая содержит соответствия \"название "
"переменной\" -> \"значение переменной\" и передается в шаблон."

# 49a9b1db1f5e4b3eb959454a50ecf646
#: ../../ref/templates/api.txt:52
msgid ""
"A template **renders** a context by replacing the variable \"holes\" with "
"values from the context and executing all block tags."
msgstr ""
"Шаблон **рендерит** контекст, заменяет переменные значениями из контекста и "
"выполняет все блочные теги."

# 93e4b2cc2ec441e7afc4fac2a7d50039
#: ../../ref/templates/api.txt:56
msgid "Using the template system"
msgstr "Использование системы шаблонов"

# c9a0b776484849c28ce22782f30c9e28
#: ../../ref/templates/api.txt:60
msgid "Using the template system in Python is a two-step process:"
msgstr "Система шаблонов в Python работает в два этапа:"

# 3cbf75ced2e046d8b1ba15e0ff119d06
#: ../../ref/templates/api.txt:62
msgid "First, you compile the raw template code into a ``Template`` object."
msgstr "Сначала вы компилируете код шаблона в объект ``Template``."

# 91629278e2f749ba8e8273ff1b4115ca
#: ../../ref/templates/api.txt:63
msgid ""
"Then, you call the ``render()`` method of the ``Template`` object with a "
"given context."
msgstr ""
"Затем вызываете метод ``render()`` объекта ``Template``, передав контекст."

# b178157bd37c4d57888f649cea31be62
#: ../../ref/templates/api.txt:67
msgid "Compiling a string"
msgstr "Компилирование строки"

# 3f5bf22c215040838bdbfffa2ce09e7c
#: ../../ref/templates/api.txt:69
msgid ""
"The easiest way to create a ``Template`` object is by instantiating it "
"directly. The class lives at :class:`django.template.Template`. The "
"constructor takes one argument -- the raw template code::"
msgstr ""
"Самый простой способ создать объект ``Template`` -- создать экземпляр "
"класса. Класс находится в :class:`django.template.Template`. Конструктор "
"принимает один аргумент -- \"сырой\" код шаблона::"

# c4fa321944fc4da2839f042590efbdee
#: ../../ref/templates/api.txt:0
msgid "Behind the scenes"
msgstr "За кулисами"

# 16370177e41b436ba9e84d2c26c74ce2
#: ../../ref/templates/api.txt:80
msgid ""
"The system only parses your raw template code once -- when you create the "
"``Template`` object. From then on, it's stored internally as a \"node\" "
"structure for performance."
msgstr ""
"Система парсит код шаблона один раз -- когда вы создаете объект "
"``Template``. Результат сохраняется в объекте как структура \"нодов\", чтобы "
"повысить производительность системы шаблонов."

# f3631b1d934e4066a9dbfc9b4f180c45
#: ../../ref/templates/api.txt:84
msgid ""
"Even the parsing itself is quite fast. Most of the parsing happens via a "
"single call to a single, short, regular expression."
msgstr ""
"Сам по себе парсинг работает достаточно быстро, обычно с помощью небольших "
"регулярных выражений."

# b8479b83e5e5453f8d8cff47b5354942
#: ../../ref/templates/api.txt:88
msgid "Rendering a context"
msgstr "Рендеринг контекста"

# 96e15b84123d4e208b76a62fc6ff5c21
#: ../../ref/templates/api.txt:92
msgid ""
"Once you have a compiled ``Template`` object, you can render a context -- or "
"multiple contexts -- with it. The ``Context`` class lives at :class:`django."
"template.Context`, and the constructor takes two (optional) arguments:"
msgstr ""
"Скомпилировав объект ``Template``, вы можете отрендерить с его помощью "
"контекст, или несколько контекстов. Класс ``Context`` находится в :class:"
"`django.template.Context`, конструктор принимает два (необязательных) "
"аргумента:"

# 685166cfc97c469f9943fb9fc4bdfea4
#: ../../ref/templates/api.txt:97
msgid "A dictionary mapping variable names to variable values."
msgstr "Словарь с переменными и их значениями."

# b141f02d72c74a32a9c8fb67ad0ba180
#: ../../ref/templates/api.txt:99
msgid ""
"The name of the current application. This application name is used to help :"
"ref:`resolve namespaced URLs<topics-http-reversing-url-namespaces>`. If "
"you're not using namespaced URLs, you can ignore this argument."
msgstr ""
"Название текущего приложения. Оно помогает :ref:`определить текущее "
"пространство имен для URL-ов<topics-http-reversing-url-namespaces>`. Если вы "
"не используете пространство имен для URL-ов, можете игнорировать этот "
"аргумент."

# b31114656a0b4c80babfe0969e50845a
#: ../../ref/templates/api.txt:103
msgid ""
"Call the ``Template`` object's ``render()`` method with the context to \"fill"
"\" the template::"
msgstr ""
"Вызовите метод ``render()`` объекта ``Template`` с контекстом, чтобы "
"\"выполнить\" шаблон::"

# cc11f714920c4b97b81da1e1a20bc41f
#: ../../ref/templates/api.txt:118
msgid "Variables and lookups"
msgstr "Переменные"

# ce8561cad1fe4615bc3131708270eaec
#: ../../ref/templates/api.txt:120
msgid ""
"Variable names must consist of any letter (A-Z), any digit (0-9), an "
"underscore (but they must not start with an underscore) or a dot."
msgstr ""
"Название переменной может состоять из букв (A-Z), цифр (0-9), подчеркивания "
"(но не начинаться с подчеркивания) или точки."

# 054cdf9dc0af4943be66560c80e3de26
#: ../../ref/templates/api.txt:123
msgid ""
"Dots have a special meaning in template rendering. A dot in a variable name "
"signifies a **lookup**. Specifically, when the template system encounters a "
"dot in a variable name, it tries the following lookups, in this order:"
msgstr ""
"У точки особое значение. Точка в названии переменной означает **поиск**. "
"Встретив точку в названии переменной, система шаблонов пытается найти "
"значение в следующем подряке:"

# f75b61bd2d1c49b4ba3d6d3ec3b26663
#: ../../ref/templates/api.txt:127
msgid "Dictionary lookup. Example: ``foo[\"bar\"]``"
msgstr "Поиск в словаре. Например: ``foo[\"bar\"]``"

# 55b4428f26fd4a25a21963417dc54b41
#: ../../ref/templates/api.txt:128
msgid "Attribute lookup. Example: ``foo.bar``"
msgstr "Поиск атрибута. Например: ``foo.bar``"

# bbceeff1118e4da2b909562d35269a50
#: ../../ref/templates/api.txt:129
msgid "List-index lookup. Example: ``foo[bar]``"
msgstr "Поиск в списке. Напрмиер: ``foo[bar]``"

# 89f6aba887d045ca8d5e264414da949f
#: ../../ref/templates/api.txt:131
msgid ""
"Note that \"bar\" in a template expression like ``{{ foo.bar }}`` will be "
"interpreted as a literal string and not using the value of the variable \"bar"
"\", if one exists in the template context."
msgstr ""
"Обратите внимание, \"bar\" в выражении ``{{ foo.bar }}`` будет "
"интепретировано как строка \"bar\", а не переменная с названием \"bar\"."

# db5e81b0818e4544b5ccd7019f45cc7c
#: ../../ref/templates/api.txt:135
msgid ""
"The template system uses the first lookup type that works. It's short-"
"circuit logic. Here are a few examples::"
msgstr ""
"Система шаблонов будет использовать первое найденное значение. Вот несколько "
"примеров::"

# ae9a3a25971f49bebd4170bbd0bc8b2d
#: ../../ref/templates/api.txt:156
msgid ""
"If any part of the variable is callable, the template system will try "
"calling it. Example::"
msgstr ""
"Если найдена функция, или любой другой вызываемый объект, шаблон попытается "
"вызвать её. Например::"

# 1ed4d072fd0f4472a42f3e8a5d4ddfae
#: ../../ref/templates/api.txt:166
msgid ""
"Callable variables are slightly more complex than variables which only "
"require straight lookups. Here are some things to keep in mind:"
msgstr ""
"Вызываемые переменные работают немного сложнее. Вам следует помнить о "
"следующем:"

# 5b6dd06f94af43c599facef6e0c51bbc
#: ../../ref/templates/api.txt:169
msgid ""
"If the variable raises an exception when called, the exception will be "
"propagated, unless the exception has an attribute "
"``silent_variable_failure`` whose value is ``True``. If the exception *does* "
"have a ``silent_variable_failure`` attribute whose value is ``True``, the "
"variable will render as an empty string. Example::"
msgstr ""
"Если выполнение функции вызвало исключение, это приведет к ошибке при "
"выполнении шаблона, если только исключение не содержит атрибут "
"``silent_variable_failure`` равный ``True``. В таком случае переменная будет "
"отрендерена как пустая строка. Например::"

# 592dd2e2a3e644c5a8e800ed2c959a50
#: ../../ref/templates/api.txt:194
msgid ""
"Note that :exc:`django.core.exceptions.ObjectDoesNotExist`, which is the "
"base class for all Django database API ``DoesNotExist`` exceptions, has "
"``silent_variable_failure = True``. So if you're using Django templates with "
"Django model objects, any ``DoesNotExist`` exception will fail silently."
msgstr ""
"Обратите внимание, :exc:`django.core.exceptions.ObjectDoesNotExist`, который "
"является родительским для всех ошибок ``DoesNotExist`` в ORM, содержит "
"``silent_variable_failure = True``. По этому, если вы используете объекты "
"модели в шаблонах, исключение ``DoesNotExist`` будет проигнорировано."

# d73f22c8b1954859b58e4f27ef4eb2aa
#: ../../ref/templates/api.txt:200
msgid ""
"A variable can only be called if it has no required arguments. Otherwise, "
"the system will return an empty string."
msgstr ""
"Функция из переменной может быть вызвана, только если не требует "
"обязательных аргументов. В таком случае шаблон вставит вместо переменной "
"пустую строку."

# c776f677bf8146da8b35d2c9fc7053aa
#: ../../ref/templates/api.txt:205
msgid ""
"Obviously, there can be side effects when calling some variables, and it'd "
"be either foolish or a security hole to allow the template system to access "
"them."
msgstr ""
"Очевидно, что вызов функций может выполнять различные побочные действия, "
"которые могут привести к уязвимостям, было бы глупо позволять шаблону "
"выполнять их."

# a9cbe2f62d254a07861264c91cd668b0
#: ../../ref/templates/api.txt:209
msgid ""
"A good example is the :meth:`~django.db.models.Model.delete` method on each "
"Django model object. The template system shouldn't be allowed to do "
"something like this::"
msgstr ""
"Хороший пример -- метод :meth:`~django.db.models.Model.delete` модели. "
"Нельзя позволять шаблонам выполнять следующее::"

# 9f926c76e557480ba20683c4b3d012ee
#: ../../ref/templates/api.txt:215
msgid ""
"To prevent this, set an ``alters_data`` attribute on the callable variable. "
"The template system won't call a variable if it has ``alters_data=True`` "
"set, and will instead replace the variable with :setting:"
"`TEMPLATE_STRING_IF_INVALID`, unconditionally.  The dynamically-generated :"
"meth:`~django.db.models.Model.delete` and :meth:`~django.db.models.Model."
"save` methods on Django model objects get ``alters_data=True`` "
"automatically. Example::"
msgstr ""
"Чтобы избежать этого, укажите атрибут ``alters_data`` в функции или методе. "
"Шаблон не будет вызывать переменную, если значение содержит "
"``alters_data=True``, и будет использовать значение настройки :setting:"
"`TEMPLATE_STRING_IF_INVALID`.  Встроенные методы :meth:`~django.db.models."
"Model.delete` и :meth:`~django.db.models.Model.save` модели содержат атрибут "
"``alters_data=True``. Например::"

# 7945e0cd774e4dc295d7cd6d3274882b
#: ../../ref/templates/api.txt:227
msgid ""
"Occasionally you may want to turn off this feature for other reasons, and "
"tell the template system to leave a variable uncalled no matter what.  To do "
"so, set a ``do_not_call_in_templates`` attribute on the callable with the "
"value ``True``.  The template system then will act as if your variable is "
"not callable (allowing you to access attributes of the callable, for "
"example)."
msgstr ""
"В некоторых случая может понадобится отключить вызов переменной и "
"использовать значение как есть. Для этого укажите атрибут "
"``do_not_call_in_templates`` со значением ``True``. Шаблон будет "
"интерпретировать такую функцию как не вызываемое значение (позволяя "
"обратиться к её атрибутам, например)."

# 5998286e9ce14a5bb7f17386be8846bd
#: ../../ref/templates/api.txt:237
msgid "How invalid variables are handled"
msgstr "Как обрабатываются неправильные переменные"

# fa0bd15decb2475abc38d172aeff627f
#: ../../ref/templates/api.txt:239
msgid ""
"Generally, if a variable doesn't exist, the template system inserts the "
"value of the :setting:`TEMPLATE_STRING_IF_INVALID` setting, which is set to "
"``''`` (the empty string) by default."
msgstr ""
"Если переменная не найдена в шаблоне, будет использоваться значение "
"настройки :setting:`TEMPLATE_STRING_IF_INVALID`, равной по умолчанию ``''`` "
"(пустая строка)."

# 00f8c67b48fc45b1b82a7d080d450bb4
#: ../../ref/templates/api.txt:243
msgid ""
"Filters that are applied to an invalid variable will only be applied if :"
"setting:`TEMPLATE_STRING_IF_INVALID` is set to ``''`` (the empty string). "
"If :setting:`TEMPLATE_STRING_IF_INVALID` is set to any other value, variable "
"filters will be ignored."
msgstr ""
"Фильтры, которые указаны для переменной, будут применяться, только если :"
"setting:`TEMPLATE_STRING_IF_INVALID` равна ``''`` (пустая строка). Если :"
"setting:`TEMPLATE_STRING_IF_INVALID` равна другому значению, фильтры будут "
"проигнорированы."

# 83b13b0c542440c6ae29aa4550e1d850
#: ../../ref/templates/api.txt:248
msgid ""
"This behavior is slightly different for the ``if``, ``for`` and ``regroup`` "
"template tags. If an invalid variable is provided to one of these template "
"tags, the variable will be interpreted as ``None``. Filters are always "
"applied to invalid variables within these template tags."
msgstr ""
"Теги ``if``, ``for`` и ``regroup`` работают немного по другому. Если указать "
"неправильную переменную, будет использоваться значение ``None``. Фильтры "
"всегда применяются к переменной в этих тегах."

# c93e99e5e7ad4341803113e86569f0ec
#: ../../ref/templates/api.txt:253
msgid ""
"If :setting:`TEMPLATE_STRING_IF_INVALID` contains a ``'%s'``, the format "
"marker will be replaced with the name of the invalid variable."
msgstr ""
"Если :setting:`TEMPLATE_STRING_IF_INVALID` содержит ``'%s'``, будет "
"подставлено название переменной."

# db5d94cc6e2b415998cd320a5665670b
#: ../../ref/templates/api.txt:0
msgid "For debug purposes only!"
msgstr "Только для отладки!"

# 5fe77ee37a764c9a9d21afc4af1dd96a
#: ../../ref/templates/api.txt:258
msgid ""
"While :setting:`TEMPLATE_STRING_IF_INVALID` can be a useful debugging tool, "
"it is a bad idea to turn it on as a 'development default'."
msgstr ""
"Хотя :setting:`TEMPLATE_STRING_IF_INVALID` и полезная для отладки, лучше не "
"менять её по умолчанию и использовать только при необходимости локально."

# c4e4535f0e85426da064d2780ce65f1d
#: ../../ref/templates/api.txt:261
msgid ""
"Many templates, including those in the Admin site, rely upon the silence of "
"the template system when a non-existent variable is encountered. If you "
"assign a value other than ``''`` to :setting:`TEMPLATE_STRING_IF_INVALID`, "
"you will experience rendering problems with these templates and sites."
msgstr ""
"Многие шаблоны, включая шаблоны админки, полагаются на то, что неправильные "
"переменные будут проигнорированы системой шаблонов. Если заменить ``''`` в :"
"setting:`TEMPLATE_STRING_IF_INVALID` на другое значение, могут возникнуть "
"проблемы с рендерингом шаблонов."

# d9c1b9e7a8b142a2942d3a959e03396c
#: ../../ref/templates/api.txt:267
msgid ""
"Generally, :setting:`TEMPLATE_STRING_IF_INVALID` should only be enabled in "
"order to debug a specific template problem, then cleared once debugging is "
"complete."
msgstr ""
"Как правило :setting:`TEMPLATE_STRING_IF_INVALID` необходимо использовать "
"для отладки конкретной проблемы в шаблоне, и после отладки возвращать "
"значение по умолчанию."

# 49a720c370054926947d014bed08b497
#: ../../ref/templates/api.txt:272
msgid "Builtin variables"
msgstr "Встроенные переменные"

# 59a36043915e43d18199785e04f99b19
#: ../../ref/templates/api.txt:274
msgid ""
"Every context contains ``True``, ``False`` and ``None``. As you would "
"expect, these variables resolve to the corresponding Python objects."
msgstr ""
"Каждый контекст содержит ``True``, ``False`` и ``None``. Как и следовало "
"ожидать эти переменные соответствуют объектам Python."

# 577a939d6c3f4b92ae4734e159bc9f66
#: ../../ref/templates/api.txt:278
msgid "Limitations with string literals"
msgstr "Ограничения текстовых литералов"

# e95d11ea17ea4a2191bb00f2eada7ebe
#: ../../ref/templates/api.txt:280
msgid ""
"Django's template language has no way to escape the characters used for its "
"own syntax. For example, the :ttag:`templatetag` tag is required if you need "
"to output character sequences like ``{%`` and ``%}``."
msgstr ""
"Система шаблонов Django не позволяет экранировать символы, которые "
"используются в синтаксисе разметки шаблонов. Например, следует использовать "
"тег :ttag:`templatetag`, если необходимо вывести в шаблоне ``{%`` и ``%}`` "
"как строки."

# fa5ba05bbb9f41759bba510cd5e87340
#: ../../ref/templates/api.txt:284
msgid ""
"A similar issue exists if you want to include these sequences in template "
"filter or tag arguments. For example, when parsing a block tag, Django's "
"template parser looks for the first occurrence of ``%}`` after a ``{%``. "
"This prevents the use of ``\"%}\"`` as a string literal. For example, a "
"``TemplateSyntaxError`` will be raised for the following expressions::"
msgstr ""
"Аналогичные проблемы возникают, если необходимо использовать эти значения "
"как аргумент фильтра или тега. Например, при парсинге блочного тега, Django "
"ищет первое появление ``%}`` после ``{%``. Таким образом нельзя использовать "
"``\"%}\"`` как текст. Например, в следующих ситуациях будет вызвано "
"исключение ``TemplateSyntaxError``::"

# 7bc23eca2b824630beee07304e23b9e7
#: ../../ref/templates/api.txt:294
msgid ""
"The same issue can be triggered by using a reserved sequence in filter "
"arguments::"
msgstr ""
"Аналогичная проблема возникнет при использовании ``}}`` в качестве аргумента "
"фильтра::"

# 9de643ca8bdc4b9d83fb349740f92af7
#: ../../ref/templates/api.txt:299
msgid ""
"If you need to use strings with these sequences, store them in template "
"variables or use a custom template tag or filter to workaround the "
"limitation."
msgstr ""
"Чтобы обойти эти ограничения, используйте переменную для хранения "
"запрещенных строк, или свой теги или фильтр, чтобы обойти ограничения."

# 23aa021c846d43c1bc1457f2ca6f6dc6
#: ../../ref/templates/api.txt:303
msgid "Playing with Context objects"
msgstr "Использование объекта Context"

# 3d215e0a227d4ec9a65d7c6b2042d470
#: ../../ref/templates/api.txt:307
msgid ""
"Most of the time, you'll instantiate ``Context`` objects by passing in a "
"fully-populated dictionary to ``Context()``. But you can add and delete "
"items from a ``Context`` object once it's been instantiated, too, using "
"standard dictionary syntax::"
msgstr ""
"Обычно при создании объекта ``Context`` сразу передается словарь со всеми "
"переменными. Но вы можете менять содержимое объекта ``Context`` и после его "
"инициализации, использую стандартный API словарей::"

# 2cfc8d63979a4e47b03873aec19ea4cd
#: ../../ref/templates/api.txt:327
msgid ""
"A ``Context`` object is a stack. That is, you can ``push()`` and ``pop()`` "
"it. If you ``pop()`` too much, it'll raise ``django.template."
"ContextPopException``::"
msgstr ""
"Объект ``Context`` работает как стек. По этому можно использовать методы "
"``push()`` и ``pop()``. Если вызывать ``pop()`` слишком часто, будет вызвано "
"исключение ``django.template.ContextPopException``::"

# 55e1368f231a4a468b2cf38260f52094
#: ../../ref/templates/api.txt:352
msgid ""
"You can also use ``push()`` as a context manager to ensure a matching "
"``pop()`` is called."
msgstr ""
"``push()`` можно использовать как менеджер контекста, чтобы быть уверенным, "
"что будет ``pop()`` вызван в конце."

# 681d9c1b256c450da9a31e7edcd1c27c
#: ../../ref/templates/api.txt:364
msgid ""
"All arguments passed to ``push()`` will be passed to the ``dict`` "
"constructor used to build the new context level."
msgstr ""
"Все аргументы ``push()`` будут переданы в конструктор ``dict`` при создании "
"нового слоя в контексте."

# 2170415dc10649d8bfa0edfe98bde326
#: ../../ref/templates/api.txt:377
msgid ""
"In addition to ``push()`` and ``pop()``, the ``Context`` object also defines "
"an ``update()`` method. This works like ``push()`` but takes a dictionary as "
"an argument and pushes that dictionary onto the stack instead of an empty "
"one."
msgstr ""
"Кроме ``push()`` и ``pop()`` объект ``Context`` также предоставляет метод "
"``update()``. Работает как и ``push()``, но принимает словарь в качестве "
"аргумента и добавляет его в стек."

# 1a23db2e66de429da838ef8c0eaaaf87
#: ../../ref/templates/api.txt:393
msgid ""
"Using a ``Context`` as a stack comes in handy in some custom template tags, "
"as you'll see below."
msgstr ""
"Использовать ``Context``, как стек, удобно в собственных тегах. Ниже мы "
"покажем пример."

# 61e9db3ead914d7a8e655258945a11f4
#: ../../ref/templates/api.txt:400
msgid ""
"Using ``flatten()`` method you can get whole ``Context`` stack as one "
"dictionary including builtin variables."
msgstr ""
"Метод ``flatten()`` возвращает весь стек ``Context`` одним словарём, включая "
"встроенные переменные."

# 97c6dfca57f641fbb7b2234b0decd0ef
#: ../../ref/templates/api.txt:410
msgid ""
"A ``flatten()`` method is also internally used to make ``Context`` objects "
"comparable."
msgstr ""
"Метод ``flatten()`` также используется для сравнения объектов ``Context`` "
"внутри системы шаблонов."

# a3808b43e3e441319c1465fa1d16ec67
#: ../../ref/templates/api.txt:421
msgid ""
"Result from ``flatten()`` can be useful in unit tests to compare ``Context`` "
"against ``dict``::"
msgstr ""
"Результат ``flatten()`` можно использовать в тестах для сравнения "
"``Context`` и ``dict``::"

# b3cfecf2edf84488aea9f62878ef6a9a
#: ../../ref/templates/api.txt:436
msgid "Subclassing Context: RequestContext"
msgstr "Классы наследники Context: RequestContext"

# 794c75488db84963a4a2df2eb1408c38
#: ../../ref/templates/api.txt:440
msgid ""
"Django comes with a special ``Context`` class, ``django.template."
"RequestContext``, that acts slightly differently than the normal ``django."
"template.Context``. The first difference is that it takes an :class:`~django."
"http.HttpRequest` as its first argument. For example::"
msgstr ""
"Django предоставляет специальный класс ``Context``, ``django.template."
"RequestContext``, которые немного отличается от обычного ``django.template."
"Context``. Первое отличие -- он принимает :class:`~django.http.HttpRequest` "
"первым аргументом. Например::"

# 36600bf9272b490a8f22225c32c90645
#: ../../ref/templates/api.txt:449
msgid ""
"The second difference is that it automatically populates the context with a "
"few variables, according to your :setting:`TEMPLATE_CONTEXT_PROCESSORS` "
"setting."
msgstr ""
"Еще одно отличие -- он автоматически добавляет различные переменные в "
"соответствии с настройкой :setting:`TEMPLATE_CONTEXT_PROCESSORS`."

# d81ca0560a544e65b007c7936c5d9c2f
#: ../../ref/templates/api.txt:452
msgid ""
"The :setting:`TEMPLATE_CONTEXT_PROCESSORS` setting is a tuple of callables "
"-- called **context processors** -- that take a request object as their "
"argument and return a dictionary of items to be merged into the context. By "
"default, :setting:`TEMPLATE_CONTEXT_PROCESSORS` is set to::"
msgstr ""
"Настройка :setting:`TEMPLATE_CONTEXT_PROCESSORS` содержит кортеж функций, "
"которые называются **процессорами контекста**. Они принимают объект запроса "
"в качестве аргумента и возвращают словарь переменных, которые будут "
"добавлены в контекст. По умолчанию :setting:`TEMPLATE_CONTEXT_PROCESSORS` "
"равна::"

# accd1f784a8e4727923bbc2a1fcb421a
#: ../../ref/templates/api.txt:465
msgid ""
"In addition to these, ``RequestContext`` always uses ``django.core."
"context_processors.csrf``.  This is a security related context processor "
"required by the admin and other contrib apps, and, in case of accidental "
"misconfiguration, it is deliberately hardcoded in and cannot be turned off "
"by the :setting:`TEMPLATE_CONTEXT_PROCESSORS` setting."
msgstr ""
"Кроме этого ``RequestContext`` всегда использует ``django.core."
"context_processors.csrf``. Этот процессор контекста используется для "
"безопасности админкой и другими встроенными приложениями. Чтобы исключить "
"его случайное отключение, он захардкоден и не может быть выключен с помощью "
"настройки :setting:`TEMPLATE_CONTEXT_PROCESSORS`."

# e3c6eff88d9147f6a2ff50c8ca76a65a
#: ../../ref/templates/api.txt:471
msgid ""
"Each processor is applied in order. That means, if one processor adds a "
"variable to the context and a second processor adds a variable with the same "
"name, the second will override the first. The default processors are "
"explained below."
msgstr ""
"Процессоры контекста применяются по очереди. Это означает, что один "
"процессор может перетереть переменную, которую добавил предыдущий. "
"Процессоры по умолчанию описаны ниже."

# 67c9890d0fc04471a9e1584fa2c50daf
#: ../../ref/templates/api.txt:0
msgid "When context processors are applied"
msgstr "Когда применяются процессоры контекста"

# 95c50fe560ff4cb08240345fb03de958
#: ../../ref/templates/api.txt:478
msgid ""
"Context processors are applied *after* the context itself is processed. This "
"means that a context processor may overwrite variables you've supplied to "
"your ``Context`` or ``RequestContext``, so take care to avoid variable names "
"that overlap with those supplied by your context processors."
msgstr ""
"Процессоры контекста применяются *после* инициализации контекста. То есть "
"процессор может перезаписать переменную, которую вы добавили в ``Context`` "
"или ``RequestContext``. По этому избегайте названий переменных, которые "
"используются процессорами."

# 277c1ac702d4493eb42bcd33fdaa9682
#: ../../ref/templates/api.txt:484
msgid ""
"Also, you can give ``RequestContext`` a list of additional processors, using "
"the optional, third positional argument, ``processors``. In this example, "
"the ``RequestContext`` instance gets a ``ip_address`` variable::"
msgstr ""
"Также в ``RequestContext`` можно передать список дополнительных процессоров "
"контекста, используя третий необязательный аргумент ``processors``. В это "
"примере в ``RequestContext`` будет добавлена переменная ``ip_address``::"

# 2c01ea357f9948d481caebeae0d9f320
#: ../../ref/templates/api.txt:503
msgid ""
"If you're using Django's :func:`~django.shortcuts.render_to_response()` "
"shortcut to populate a template with the contents of a dictionary, your "
"template will be passed a ``Context`` instance by default (not a "
"``RequestContext``). To use a ``RequestContext`` in your template rendering, "
"pass an optional third argument to :func:`~django.shortcuts."
"render_to_response()`: a ``RequestContext`` instance. Your code might look "
"like this::"
msgstr ""
"Если вы используете встроенную в Django функцию :func:`~django.shortcuts."
"render_to_response()` для рендеринга шаблона, в шаблон будет передан "
"экземпляр ``Context`` (не ``RequestContext``). Чтобы использовать "
"``RequestContext``, передайте третьим аргументом в :func:`~django.shortcuts."
"render_to_response()` экземпляр ``RequestContext``. Например::"

# 1eb3ef40e1c64a7fb2b87fe0375c58ad
#: ../../ref/templates/api.txt:520
msgid ""
"Alternatively, use the :meth:`~django.shortcuts.render()` shortcut which is "
"the same as a call to :func:`~django.shortcuts.render_to_response()` with a "
"context_instance argument that forces the use of a ``RequestContext``."
msgstr ""
"Еще можно использовать функцию :meth:`~django.shortcuts.render()`, которая "
"работает аналогично :func:`~django.shortcuts.render_to_response()`, но "
"использует ``RequestContext``."

# 1ff5ce34e85d490dbe9fae802b3dc660
#: ../../ref/templates/api.txt:524
msgid ""
"Note that the contents of a supplied dictionary (``my_data_dictionary`` in "
"this example) will take precedence over any variables supplied by context "
"processors or the ``RequestContext``."
msgstr ""
"Обратите внимание, переменные из передаваемого словаря "
"(``my_data_dictionary`` в нашем примере) будут иметь приоритет над "
"переменными процессоров контекста или ``RequestContext``."

# 67a7f24f7c234c958535ea79c218237a
#: ../../ref/templates/api.txt:528
msgid "Here's what each of the default processors does:"
msgstr "Вот список процессоров контекста по умолчанию:"

# 4f74c55c8ffb45b0b8ba336076dbd8d5
#: ../../ref/templates/api.txt:531
msgid "django.contrib.auth.context_processors.auth"
msgstr "django.contrib.auth.context_processors.auth"

# 46663a355dbf4721b6853eb24490fa14
#: ../../ref/templates/api.txt:533
msgid ""
"If :setting:`TEMPLATE_CONTEXT_PROCESSORS` contains this processor, every "
"``RequestContext`` will contain these variables:"
msgstr ""
"Если :setting:`TEMPLATE_CONTEXT_PROCESSORS` содержит этот процессор, в "
"``RequestContext`` будут добавлены следующие переменные:"

# 2099f68b2f5e48b28426eba03ba71aed
#: ../../ref/templates/api.txt:536
msgid ""
"``user`` -- An ``auth.User`` instance representing the currently logged-in "
"user (or an ``AnonymousUser`` instance, if the client isn't logged in)."
msgstr ""
"``user`` -- объект ``auth.User`` текущего авторизованного пользователя или "
"объект ``AnonymousUser``, если пользователь не авторизованный)."

# df4a1fc2c560491a89c4b3c257fe4c39
#: ../../ref/templates/api.txt:540
msgid ""
"``perms`` -- An instance of ``django.contrib.auth.context_processors."
"PermWrapper``, representing the permissions that the currently logged-in "
"user has."
msgstr ""
"``perms`` -- объект ``django.contrib.auth.context_processors.PermWrapper``, "
"которые содержит права доступа текущего пользователя."

# b6966b419065485c982913cd7f637d4f
#: ../../ref/templates/api.txt:547
msgid "django.core.context_processors.debug"
msgstr "django.core.context_processors.debug"

# a782b2b8c6fd44ba917bcfbbdf44e825
#: ../../ref/templates/api.txt:549
msgid ""
"If :setting:`TEMPLATE_CONTEXT_PROCESSORS` contains this processor, every "
"``RequestContext`` will contain these two variables -- but only if your :"
"setting:`DEBUG` setting is set to ``True`` and the request's IP address "
"(``request.META['REMOTE_ADDR']``) is in the :setting:`INTERNAL_IPS` setting:"
msgstr ""
"Если :setting:`TEMPLATE_CONTEXT_PROCESSORS` содержит этот процессор, в "
"``RequestContext`` будут добавлены следующие переменные, но только при :"
"setting:`DEBUG` равном ``True`` и, если IP адрес запроса (``request."
"META['REMOTE_ADDR']``) указан в :setting:`INTERNAL_IPS`:"

# 6271cf99e53345d49968b2696f57c449
#: ../../ref/templates/api.txt:554
msgid ""
"``debug`` -- ``True``. You can use this in templates to test whether you're "
"in :setting:`DEBUG` mode."
msgstr ""
"``debug`` -- ``True``. Вы можете использовать эту переменную, чтобы "
"определить :setting:`DEBUG` режим в шаблоне."

# 88c3d9db22e145de9770af0ccb2e2cff
#: ../../ref/templates/api.txt:556
msgid ""
"``sql_queries`` -- A list of ``{'sql': ..., 'time': ...}`` dictionaries, "
"representing every SQL query that has happened so far during the request and "
"how long it took. The list is in order by query."
msgstr ""
"``sql_queries`` -- список словарей ``{'sql': ..., 'time': ...}``, который "
"содержит все SQL запросы и время их выполнения, которые были выполнены при "
"обработке запроса. Список отсортирован в порядке выполнения SQL запроса."

# 40b3281520c24cd3b9f25692a7eb1e66
#: ../../ref/templates/api.txt:561
msgid "django.core.context_processors.i18n"
msgstr "django.core.context_processors.i18n"

# 13192c07fd7f4886978238bd1647af92
#: ../../ref/templates/api.txt:563 ../../ref/templates/api.txt:606
msgid ""
"If :setting:`TEMPLATE_CONTEXT_PROCESSORS` contains this processor, every "
"``RequestContext`` will contain these two variables:"
msgstr ""
"Если :setting:`TEMPLATE_CONTEXT_PROCESSORS` содержит этот процессор, в "
"``RequestContext`` будут добавлены следующие переменные:"

# fd018e6040574d409ffe9e8f6821ce22
#: ../../ref/templates/api.txt:566
msgid "``LANGUAGES`` -- The value of the :setting:`LANGUAGES` setting."
msgstr "``LANGUAGES`` -- значение настройки :setting:`LANGUAGES`."

# db178c2698da4a83acd2ae7a47dd4c2d
#: ../../ref/templates/api.txt:567
msgid ""
"``LANGUAGE_CODE`` -- ``request.LANGUAGE_CODE``, if it exists. Otherwise, the "
"value of the :setting:`LANGUAGE_CODE` setting."
msgstr ""
"``LANGUAGE_CODE`` -- ``request.LANGUAGE_CODE``, если существует. Иначе "
"значение :setting:`LANGUAGE_CODE`."

# 7e82e3a962514a29bc03b9c1d8f887cc
#: ../../ref/templates/api.txt:570
msgid "See :doc:`/topics/i18n/index` for more."
msgstr "Смотрите :doc:`/topics/i18n/index`."

# fc4072670a644ed4a02af0c52d98c520
#: ../../ref/templates/api.txt:573
msgid "django.core.context_processors.media"
msgstr "django.core.context_processors.media"

# 12e09d53127e4245a94bd154e7c386a3
#: ../../ref/templates/api.txt:575
msgid ""
"If :setting:`TEMPLATE_CONTEXT_PROCESSORS` contains this processor, every "
"``RequestContext`` will contain a variable ``MEDIA_URL``, providing the "
"value of the :setting:`MEDIA_URL` setting."
msgstr ""
"Если :setting:`TEMPLATE_CONTEXT_PROCESSORS` содержит этот процессор, в "
"``RequestContext`` будет добавлена переменная ``MEDIA_URL``, которая "
"содержит значение :setting:`MEDIA_URL`."

# 0df2d136ed844df4a50afee535e871cf
#: ../../ref/templates/api.txt:580
msgid "django.core.context_processors.static"
msgstr "django.core.context_processors.static"

# f3d32a76ba94481da1d0d32d26f18845
#: ../../ref/templates/api.txt:584
msgid ""
"If :setting:`TEMPLATE_CONTEXT_PROCESSORS` contains this processor, every "
"``RequestContext`` will contain a variable ``STATIC_URL``, providing the "
"value of the :setting:`STATIC_URL` setting."
msgstr ""
"Если :setting:`TEMPLATE_CONTEXT_PROCESSORS` содержит этот процессор, в "
"``RequestContext`` будет добавлена переменная ``STATIC_URL``, которая "
"содержит значение :setting:`STATIC_URL`."

# e6fe13fc616949f4bae7a8c5d2ae2d25
#: ../../ref/templates/api.txt:589
msgid "django.core.context_processors.csrf"
msgstr "django.core.context_processors.csrf"

# 076ae19c926d4ab18330243dae9b902c
#: ../../ref/templates/api.txt:591
msgid ""
"This processor adds a token that is needed by the :ttag:`csrf_token` "
"template tag for protection against :doc:`Cross Site Request Forgeries </ref/"
"contrib/csrf>`."
msgstr ""
"Этот процессор добавляет токен, который используется тегом :ttag:"
"`csrf_token` для защиты от :doc:`CSRF атак </ref/contrib/csrf>`."

# d72b464bbbc54949b59c36334dc7feaf
#: ../../ref/templates/api.txt:596
msgid "django.core.context_processors.request"
msgstr "django.core.context_processors.request"

# 98fac01ff9c94f6abbdd64330987bc5b
#: ../../ref/templates/api.txt:598
msgid ""
"If :setting:`TEMPLATE_CONTEXT_PROCESSORS` contains this processor, every "
"``RequestContext`` will contain a variable ``request``, which is the "
"current :class:`~django.http.HttpRequest`. Note that this processor is not "
"enabled by default; you'll have to activate it."
msgstr ""
"Если :setting:`TEMPLATE_CONTEXT_PROCESSORS` содержит этот процессор, в "
"``RequestContext`` будет добавлена переменная ``request``, содержащая "
"текущий :class:`~django.http.HttpRequest`. Обратите внимание, этот процессор "
"не включен по умолчанию."

# 9f9382901d7a46d192a2fa172846980b
#: ../../ref/templates/api.txt:604
msgid "django.contrib.messages.context_processors.messages"
msgstr "django.contrib.messages.context_processors.messages"

# 093618ab1c0444b69851d6ee73afaf60
#: ../../ref/templates/api.txt:609
msgid ""
"``messages`` -- A list of messages (as strings) that have been set via the :"
"doc:`messages framework </ref/contrib/messages>`."
msgstr ""
"``messages`` -- список сообщений (строки), которые были добавлены с помощью :"
"doc:`фреймворка сообщений </ref/contrib/messages>`."

# 8378ef0e3f044f5abf7957024fe47468
#: ../../ref/templates/api.txt:611
msgid ""
"``DEFAULT_MESSAGE_LEVELS`` -- A mapping of the message level names to :ref:"
"`their numeric value <message-level-constants>`."
msgstr ""
"``DEFAULT_MESSAGE_LEVELS`` -- словарь приоритетов сообщений и :ref:`их "
"числовых кодов <message-level-constants>`."

# d06dfea5b49b4d8281abf98eab374c33
#: ../../ref/templates/api.txt:616
msgid "The ``DEFAULT_MESSAGE_LEVELS`` variable was added."
msgstr "Была добавлена переменная ``DEFAULT_MESSAGE_LEVELS``."

# 1fcde39b1ac443d8b4163bef8893de09
#: ../../ref/templates/api.txt:619
msgid "Writing your own context processors"
msgstr "Как создать свой процессор контекста"

# 2e07708a63e24295b61c5c28b7a42378
#: ../../ref/templates/api.txt:621
msgid ""
"A context processor has a very simple interface: It's just a Python function "
"that takes one argument, an :class:`~django.http.HttpRequest` object, and "
"returns a dictionary that gets added to the template context. Each context "
"processor *must* return a dictionary."
msgstr ""
"Интерфейс процессора контекста очень простой: это функция Python, которая "
"принимает один аргумент, объект :class:`~django.http.HttpRequest`, и "
"возвращает словарь, которая будет добавлен в контекст шаблона. Процессор "
"контекста *обязательно* должен возвращать словарь."

# 6b0ac5e3f8d34d8db46cc759c9fbadaa
#: ../../ref/templates/api.txt:626
msgid ""
"Custom context processors can live anywhere in your code base. All Django "
"cares about is that your custom context processors are pointed-to by your :"
"setting:`TEMPLATE_CONTEXT_PROCESSORS` setting."
msgstr ""
"Код процессора может находится где угодно. Главное не забыть указать его в "
"настройке :setting:`TEMPLATE_CONTEXT_PROCESSORS`."

# d81d691eb3f547c1977948b7ce189443
#: ../../ref/templates/api.txt:631
msgid "Loading templates"
msgstr "Загрузка шаблонов"

# 9769e4cc33644631ac451b17ef9ad14f
#: ../../ref/templates/api.txt:633
msgid ""
"Generally, you'll store templates in files on your filesystem rather than "
"using the low-level ``Template`` API yourself. Save templates in a directory "
"specified as a **template directory**."
msgstr ""
"Обычно при разработке проекта шаблоны хранятся в файлах, а не создаются с "
"помощью API ``Template``. Сохраняйте их в каталоге, который называют "
"**каталог с шаблонами**."

# 9b644db389ab4622988041bbfbb06311
#: ../../ref/templates/api.txt:637
msgid ""
"Django searches for template directories in a number of places, depending on "
"your template-loader settings (see \"Loader types\" below), but the most "
"basic way of specifying template directories is by using the :setting:"
"`TEMPLATE_DIRS` setting."
msgstr ""
"Django ищет каталоги с шаблонами в соответствии с настройками загрузки "
"шаблонов (смотрите \"Типа загрузчиков\" (FIXME) ниже). Самый простой способ "
"-- указать каталоги с шаблонами в настройке :setting:`TEMPLATE_DIRS`."

# e0741e1950ef4699ba6f4cac63ff138f
#: ../../ref/templates/api.txt:643
msgid "The TEMPLATE_DIRS setting"
msgstr "Настройка TEMPLATE_DIRS"

# b963a6780eb34ebd8c8372a2b3020080
#: ../../ref/templates/api.txt:645
msgid ""
"Tell Django what your template directories are by using the :setting:"
"`TEMPLATE_DIRS` setting in your settings file. This should be set to a list "
"or tuple of strings that contain full paths to your template directory(ies). "
"Example::"
msgstr ""
"Вы можете указать Django каталоги с шаблонами через настройку :setting:"
"`TEMPLATE_DIRS` в файле настроек проекта. Настройка должна содержать список "
"или кортеж полных путей к каталогам. Например::"

# 0be6659172bd4a05befb3397349badb6
#: ../../ref/templates/api.txt:655
msgid ""
"Your templates can go anywhere you want, as long as the directories and "
"templates are readable by the Web server. They can have any extension you "
"want, such as ``.html`` or ``.txt``, or they can have no extension at all."
msgstr ""
"Шаблоны могут находиться где угодно, главное, чтобы у Web-сервера были права "
"на чтение. Расширение файла может быть любым, ``.html`` или ``.txt``, или "
"вообще без расширения."

# 1f5dbb2948f54aab8299117d1382f8db
#: ../../ref/templates/api.txt:659
msgid ""
"Note that these paths should use Unix-style forward slashes, even on Windows."
msgstr ""
"Обратите внимание, пути должны быть Unix-стиле, даже для Windows (то есть "
"использовать ``/``)."

# e3a1efffc99c4aeeaa973c966f5b60c7
#: ../../ref/templates/api.txt:664
msgid "The Python API"
msgstr "Python API"

# 0215f38d94004d7ab391b4642132659c
#: ../../ref/templates/api.txt:668
msgid ""
"``django.template.loader`` has two functions to load templates from files:"
msgstr ""
"``django.template.loader`` содержит две функции для загрузки шаблонов с "
"файла:"

# 982ca7c6f779465eb43bdd4fd9732676
#: ../../ref/templates/api.txt:672
msgid ""
"``get_template`` returns the compiled template (a ``Template`` object) for "
"the template with the given name. If the template doesn't exist, it raises "
"``django.template.TemplateDoesNotExist``."
msgstr ""
"``get_template`` возвращает скомпилированный шаблон (объект ``Template``) "
"для указанного названия шаблона. Если шаблон не найден, будет вызвано "
"исключение ``django.template.TemplateDoesNotExist``."

# d32a0e9b06714446a005b8b861d34987
# 37574e2467b74e26875da184b256c198
#: ../../ref/templates/api.txt:676 ../../ref/templates/api.txt:688
msgid ""
"To override the :setting:`TEMPLATE_DIRS` setting, use the ``dirs`` "
"parameter. The ``dirs`` parameter may be a tuple or list."
msgstr ""
"Чтобы переопределить настройку :setting:`TEMPLATE_DIRS`, используйте "
"аргумент ``dirs``. Аргумент ``dirs`` может быть списком или кортежем."

# 2b7bc73d3b6a4a659b522027cfbe1dac
# 6a6aa759374d427fbae438f7138f704e
#: ../../ref/templates/api.txt:681 ../../ref/templates/api.txt:693
msgid "The ``dirs`` parameter was added."
msgstr "Был добавлен аргумент ``dirs``."

# 1d9e88c402fa41e283ac3ada1911811e
#: ../../ref/templates/api.txt:685
msgid ""
"``select_template`` is just like ``get_template``, except it takes a list of "
"template names. Of the list, it returns the first template that exists."
msgstr ""
"``select_template`` похож на ``get_template``, но принимает список шаблонов. "
"Возвращает первый доступный шаблон из списка."

# 423a741d62074cbe81e9757a0624ca70
#: ../../ref/templates/api.txt:695
msgid ""
"For example, if you call ``get_template('story_detail.html')`` and have the "
"above :setting:`TEMPLATE_DIRS` setting, here are the files Django will look "
"for, in order:"
msgstr ""
"Например, для ``get_template('story_detail.html')``, при настройке :setting:"
"`TEMPLATE_DIRS` из примера выше, Django будет проверять такие файлы в "
"следующем порядке:"

# 2e0ee63e3f0d4f21a2fafc6b7bbec8ad
# 1803a692346042ccb14e8d305eac6522
#: ../../ref/templates/api.txt:699 ../../ref/templates/api.txt:707
msgid "``/home/html/templates/lawrence.com/story_detail.html``"
msgstr "``/home/html/templates/lawrence.com/story_detail.html``"

# 16242f67738e44a2994ac1725d6b969d
# 2bef4fb42a9c438ca1540f3dad1b64f6
#: ../../ref/templates/api.txt:700 ../../ref/templates/api.txt:708
msgid "``/home/html/templates/default/story_detail.html``"
msgstr "``/home/html/templates/default/story_detail.html``"

# 61cffbed641149579be89541913953e7
#: ../../ref/templates/api.txt:702
msgid ""
"If you call ``select_template(['story_253_detail.html', 'story_detail."
"html'])``, here's what Django will look for:"
msgstr ""
"Для ``select_template(['story_253_detail.html', 'story_detail.html'])``, "
"Django будет искать:"

# 8568200fc8bb4647b408b1434db37912
#: ../../ref/templates/api.txt:705
msgid "``/home/html/templates/lawrence.com/story_253_detail.html``"
msgstr "``/home/html/templates/lawrence.com/story_253_detail.html``"

# 2159ec691c6a4b09a395e8267f3b36bd
#: ../../ref/templates/api.txt:706
msgid "``/home/html/templates/default/story_253_detail.html``"
msgstr "``/home/html/templates/default/story_253_detail.html``"

# 2d0f63d34b6e47fa88e74ea50017018f
#: ../../ref/templates/api.txt:710
msgid "When Django finds a template that exists, it stops looking."
msgstr "Как только Django найдет шаблон, поиск будет остановлен."

# 3d5d4dc50d404f95a2f5cb5daa03f311
#: ../../ref/templates/api.txt:0
msgid "Tip"
msgstr "Совет"

# f00cde4cb9ab4dd189d37d269c964575
#: ../../ref/templates/api.txt:714
msgid ""
"You can use ``select_template()`` for super-flexible \"templatability.\" For "
"example, if you've written a news story and want some stories to have custom "
"templates, use something like ``select_template(['story_%s_detail.html' % "
"story.id, 'story_detail.html'])``. That'll allow you to use a custom "
"template for an individual story, with a fallback template for stories that "
"don't have custom templates."
msgstr ""
"Вы можете использовать ``select_template()`` для супер-гибкой структуры "
"шаблонов. Например, если у вас есть новости и вы хотите для некоторых "
"использовать собственный шаблон, используйте следующий код "
"``select_template(['story_%s_detail.html' % story.id, 'story_detail."
"html'])``. Такой подход позволит использовать собственный шаблон для "
"некоторых новостей и шаблон по умолчанию для всех остальных."

# 8011a261467e46178cd9ddab3aaeb8c7
#: ../../ref/templates/api.txt:722
msgid "Using subdirectories"
msgstr "Использование под-каталогов"

# 0591f24d108f4428930f19b7c28027e6
#: ../../ref/templates/api.txt:724
msgid ""
"It's possible -- and preferable -- to organize templates in subdirectories "
"of the template directory. The convention is to make a subdirectory for each "
"Django app, with subdirectories within those subdirectories as needed."
msgstr ""
"Вы можете организовать хранение шаблонов в под-каталогах в каталоге шаблонов "
"и мы рекомендуем использовать такой подход. Существует неписанное соглашение "
"разделять шаблоны по под-каталогам для каждого приложения Django."

# cddaa40c34254f36b25d4ab157828ca5
#: ../../ref/templates/api.txt:728
msgid ""
"Do this for your own sanity. Storing all templates in the root level of a "
"single directory gets messy."
msgstr ""
"Используйте это для собственного удобства. Хранение всех шаблонов в одном "
"каталоге может привести к беспорядку в коде."

# 8cbe197b72964bfd9c37e2ef0914a6d5
#: ../../ref/templates/api.txt:731
msgid ""
"To load a template that's within a subdirectory, just use a slash, like so::"
msgstr "Чтобы загрузить шаблон из под-каталога, используйте слеш::"

# 6b704e28322e4943a4cf3bc4d38fc99b
#: ../../ref/templates/api.txt:735
msgid ""
"Using the same :setting:`TEMPLATE_DIRS` setting from above, this example "
"``get_template()`` call will attempt to load the following templates:"
msgstr ""
"Для настройки :setting:`TEMPLATE_DIRS` из примера выше этот вызов "
"``get_template()`` будет искать следующие шаблоны:"

# e1cf406e1d9e465997c40f4eafce6755
#: ../../ref/templates/api.txt:738
msgid "``/home/html/templates/lawrence.com/news/story_detail.html``"
msgstr "``/home/html/templates/lawrence.com/news/story_detail.html``"

# f49d19997fdf4c8cb1f5faec6152fdc2
#: ../../ref/templates/api.txt:739
msgid "``/home/html/templates/default/news/story_detail.html``"
msgstr "``/home/html/templates/default/news/story_detail.html``"

# f5de52746ee64836bff2111256443442
#: ../../ref/templates/api.txt:744
msgid "Loader types"
msgstr "Типы загрузчиков"

# a3e1a45cce4049b7b9236c6b951c0373
#: ../../ref/templates/api.txt:746
msgid ""
"By default, Django uses a filesystem-based template loader, but Django comes "
"with a few other template loaders, which know how to load templates from "
"other sources."
msgstr ""
"По умолчанию Django использует загрузчик шаблонов с файловой системы, но "
"Django предоставляет и другие загрузчики шаблонов, которые позволяют "
"загружать шаблоны с других источников."

# b2bb78e6164e46e2abcf47d3af2a37d6
#: ../../ref/templates/api.txt:750
msgid ""
"Some of these other loaders are disabled by default, but you can activate "
"them by editing your :setting:`TEMPLATE_LOADERS` setting. :setting:"
"`TEMPLATE_LOADERS` should be a tuple of strings, where each string "
"represents a template loader class. Here are the template loaders that come "
"with Django:"
msgstr ""
"Некоторые из них выключены по умолчанию, но вы можете активировать их "
"изменив настройку :setting:`TEMPLATE_LOADERS`. :setting:`TEMPLATE_LOADERS` "
"содержит кортеж строк, каждая из которых представляет класс загрузчика "
"шаблонов. Вот список загрузчиков, которые предоставляет Django:"

# 5edff49860f9475dac1d179479ec492c
#: ../../ref/templates/api.txt:757
msgid "``django.template.loaders.filesystem.Loader``"
msgstr "``django.template.loaders.filesystem.Loader``"

# 51b2227ae0f0440da206259e90aa40d0
#: ../../ref/templates/api.txt:761
msgid ""
"Loads templates from the filesystem, according to :setting:`TEMPLATE_DIRS`. "
"This loader is enabled by default."
msgstr ""
"Загружает шаблоны с файловой системы в соответствии с настройкой :setting:"
"`TEMPLATE_DIRS`. Включен по умолчанию."

# 2aba8252bf3a4176a6e476db0436377a
#: ../../ref/templates/api.txt:764
msgid "``django.template.loaders.app_directories.Loader``"
msgstr "``django.template.loaders.app_directories.Loader``"

# b8ee5b981d6b452ab14eca16e8f331c9
#: ../../ref/templates/api.txt:768
msgid ""
"Loads templates from Django apps on the filesystem. For each app in :setting:"
"`INSTALLED_APPS`, the loader looks for a ``templates`` subdirectory. If the "
"directory exists, Django looks for templates in there."
msgstr ""
"Загружает шаблоны из каталога приложения Django. Для каждого приложения в :"
"setting:`INSTALLED_APPS` загрузчик ищет под-каталог ``templates``. Если под-"
"каталог найден, Django ищет в нем шаблон."

# 48d7074334514cb0ac403327830e08eb
#: ../../ref/templates/api.txt:772
msgid ""
"This means you can store templates with your individual apps. This also "
"makes it easy to distribute Django apps with default templates."
msgstr ""
"Это означает, что вы можете хранить шаблоны вместе с приложением. Таким "
"образом легко распространять приложение Django с шаблонами по умолчанию."

# 38bd1c8504a045629583779a4c3cc2c2
#: ../../ref/templates/api.txt:775
msgid "For example, for this setting::"
msgstr "Например для следующих настроек::"

# 13b7c3f588f946c194badd32f9fe6e9e
#: ../../ref/templates/api.txt:779
msgid ""
"...then ``get_template('foo.html')`` will look for ``foo.html`` in these "
"directories, in this order:"
msgstr ""
"... ``get_template('foo.html')`` будет искать ``foo.html`` в таких каталогах "
"в указанном порядке:"

# 9a2e4b2c7fc74f2eb4e473aebe4b8370
#: ../../ref/templates/api.txt:782
msgid "``/path/to/myproject/polls/templates/``"
msgstr "``/path/to/myproject/polls/templates/``"

# 4721bf0cdd62448090a615210f2b9966
#: ../../ref/templates/api.txt:783
msgid "``/path/to/myproject/music/templates/``"
msgstr "``/path/to/myproject/music/templates/``"

# 9cd1a5e2f14c451a9faa0f58d853f60e
#: ../../ref/templates/api.txt:785
msgid "... and will use the one it finds first."
msgstr "... и будет использовать первый найденный."

# 5dffd0ec00e2469cae7d6abc2e491c13
#: ../../ref/templates/api.txt:787
msgid ""
"The order of :setting:`INSTALLED_APPS` is significant! For example, if you "
"want to customize the Django admin, you might choose to override the "
"standard ``admin/base_site.html`` template, from ``django.contrib.admin``, "
"with your own ``admin/base_site.html`` in ``myproject.polls``. You must then "
"make sure that your ``myproject.polls`` comes *before* ``django.contrib."
"admin`` in :setting:`INSTALLED_APPS`, otherwise ``django.contrib.admin``’s "
"will be loaded first and yours will be ignored."
msgstr ""
"Порядок :setting:`INSTALLED_APPS` -- важен! Например, вы хотите "
"переопределить шаблон админки Django, например ``admin/base_site.html`` из "
"``django.contrib.admin``, заменив на ``admin/base_site.html`` из ``myproject."
"polls``. Вы должны указать ``myproject.polls`` *перед* ``django.contrib."
"admin`` в :setting:`INSTALLED_APPS`, иначе шаблон из ``django.contrib."
"admin`` будет загружен первым, а ваш проигнорирован."

# 1c097e92dfc14918a7737e12a63bf559
#: ../../ref/templates/api.txt:795
msgid ""
"Note that the loader performs an optimization when it is first imported: it "
"caches a list of which :setting:`INSTALLED_APPS` packages have a "
"``templates`` subdirectory."
msgstr ""
"Обратите внимание, загрузчик выполняет некоторую оптимизацию при первом "
"импорте: он кеширует список приложений из :setting:`INSTALLED_APPS`, которые "
"содержат под-каталог ``templates``."

# 49e0044590b840ceb79bd35f885a2831
#: ../../ref/templates/api.txt:799
msgid "This loader is enabled by default."
msgstr "Загрузчик включен по умолчанию."

# 18220eec191c479fbbbb0c1a7e385d3b
#: ../../ref/templates/api.txt:801
msgid "``django.template.loaders.eggs.Loader``"
msgstr "``django.template.loaders.eggs.Loader``"

# ce2a25b669ee4bf08a984f1dd31d7ec9
#: ../../ref/templates/api.txt:805
msgid ""
"Just like ``app_directories`` above, but it loads templates from Python eggs "
"rather than from the filesystem."
msgstr ""
"Аналогичен ``app_directories``, но загружает шаблоны из Python eggs, а не "
"файловой системы."

# efc4aa376af64478925271255c365323
# 20bb1c0bcb424e0ab796724346461155
#: ../../ref/templates/api.txt:808 ../../ref/templates/api.txt:843
msgid "This loader is disabled by default."
msgstr "Загрузчик выключен по умолчанию."

# 247a952199d94495809c6ab2cbd21a14
#: ../../ref/templates/api.txt:810
msgid "``django.template.loaders.cached.Loader``"
msgstr "``django.template.loaders.cached.Loader``"

# 0537a19bb307473d8d7fefaf136432c5
#: ../../ref/templates/api.txt:814
msgid ""
"By default, the templating system will read and compile your templates every "
"time they need to be rendered. While the Django templating system is quite "
"fast, the overhead from reading and compiling templates can add up."
msgstr ""
"По умолчанию система шаблонов читает и компилирует ваш шаблон при каждом "
"рендеринге шаблона. Хотя система шаблонов Django работает достаточно быстро, "
"но общие накладные расходы на чтение и компилирование шаблонов могут быть "
"существенны."

# 13c13aee0e9b455eaf2f4900ba60a41a
#: ../../ref/templates/api.txt:818
msgid ""
"The cached template loader is a class-based loader that you configure with a "
"list of other loaders that it should wrap. The wrapped loaders are used to "
"locate unknown templates when they are first encountered. The cached loader "
"then stores the compiled ``Template`` in memory. The cached ``Template`` "
"instance is returned for subsequent requests to load the same template."
msgstr ""
"Кеширующий загрузчик шаблонов принимает список загрузчиков Он будет "
"использовать их для поиска неизвестных шаблонов, которые загружаются первый "
"раз. Затем скомпилированные ``Template`` сохраняются в памяти. "
"Закешированный объект ``Template`` возвращается при повторном поиске уже "
"загруженного шаблона."

# 516fe45b918b4719b19990806f80c661
#: ../../ref/templates/api.txt:824
msgid ""
"For example, to enable template caching with the ``filesystem`` and "
"``app_directories`` template loaders you might use the following settings::"
msgstr ""
"Например, чтобы включить кеширование с загрузчиками ``filesystem`` и "
"``app_directories``, используйте следующие настройки::"

# 524f570e0dad476b999724a81d0afd81
#: ../../ref/templates/api.txt:836
msgid ""
"All of the built-in Django template tags are safe to use with the cached "
"loader, but if you're using custom template tags that come from third party "
"packages, or that you wrote yourself, you should ensure that the ``Node`` "
"implementation for each tag is thread-safe. For more information, see :ref:"
"`template tag thread safety considerations<template_tag_thread_safety>`."
msgstr ""
"Все встроенные теги Django можно использовать с кеширующим загрузчиком, но "
"теги сторонних приложений, или ваши собственные, должны использовать "
"потокобезопасный код при использовании класса ``Node``. Смотрите :ref:"
"`Потокобезопасные шаблонные теги<template_tag_thread_safety>`."

# eeea2eb077de42bd9852eb0866145e05
#: ../../ref/templates/api.txt:845
msgid ""
"Django uses the template loaders in order according to the :setting:"
"`TEMPLATE_LOADERS` setting. It uses each loader until a loader finds a match."
msgstr ""
"Django использует загрузчики шаблонов в порядке указанном в настройке :"
"setting:`TEMPLATE_LOADERS`. Загрузчики используются пока один из них не "
"найдет шаблон."

# f50582e848c742668750b398e5eb6c3e
#: ../../ref/templates/api.txt:852
msgid "Template origin"
msgstr "Расположение шаблона"

# c9cb538fd5cd44b8a46433abba7149d7
#: ../../ref/templates/api.txt:856
msgid ""
"When :setting:`TEMPLATE_DEBUG` is ``True`` template objects will have an "
"``origin`` attribute depending on the source they are loaded from."
msgstr ""
"При :setting:`TEMPLATE_DEBUG` равном ``True`` объект шаблона содержит "
"атрибут ``origin``, который указывает на расположение шаблона."

# 3d79c7873bb94fa1a588fb55f56d7bb9
#: ../../ref/templates/api.txt:861
msgid ""
"Templates created from a template loader will use the ``django.template."
"loader.LoaderOrigin`` class."
msgstr ""
"Шаблоны, загруженные с помощью загрузчика шаблонов, будут использовать класс "
"``django.template.loader.LoaderOrigin`` как значение этого атрибута."

# e00e01fdf4e344019090411ed5fae6d5
#: ../../ref/templates/api.txt:866
msgid ""
"The path to the template as returned by the template loader. For loaders "
"that read from the file system, this is the full path to the template."
msgstr ""
"Путь к шаблону, который вернул загрузчик шаблонов. Для загрузчиков, которые "
"ищут в файловой системе, это будет полный путь к файлу шаблона."

# a206db0de1834dbf9d65e06f2f4e0caf
#: ../../ref/templates/api.txt:872
msgid "The relative path to the template as passed into the template loader."
msgstr "Относительный путь к шаблону, которые передается в загрузчик шаблонов."

# 7b5b3bc62d4a4850bc7331e3b7b5ed25
#: ../../ref/templates/api.txt:877
msgid ""
"Templates created from a ``Template`` class will use the ``django.template."
"StringOrigin`` class."
msgstr ""
"Шаблоны созданные классом ``Template`` будут использовать класс ``django."
"template.StringOrigin``."

# 95f439a87e5c4e0c9b2cc62ed5344b1e
#: ../../ref/templates/api.txt:882
msgid "The string used to create the template."
msgstr "Строка, которая использовалась для создания шаблона."

# 54b77857e724476c829d200888ceecbc
#: ../../ref/templates/api.txt:885
msgid "The ``render_to_string`` shortcut"
msgstr "Функция ``render_to_string``"

# c9b323809de74788a855878589b920aa
#: ../../ref/templates/api.txt:889
msgid ""
"To cut down on the repetitive nature of loading and rendering templates, "
"Django provides a shortcut function which largely automates the process: "
"``render_to_string()`` in :mod:`django.template.loader`, which loads a "
"template, renders it and returns the resulting string::"
msgstr ""
"Для удобства загрузки и ренедеринга шаблон Django предоставляет функцию, "
"которая упрощает это процесс: ``render_to_string()`` из :mod:`django."
"template.loader`. Она загружает шаблон, рендерит его и возвращает строку::"

# 7d1ccbdb8f384a33b92c27ca41b68891
#: ../../ref/templates/api.txt:898
msgid ""
"The ``render_to_string`` shortcut takes one required argument -- "
"``template_name``, which should be the name of the template to load and "
"render (or a list of template names, in which case Django will use the first "
"template in the list that exists) -- and two optional arguments:"
msgstr ""
"``render_to_string`` принимает один обязательный аргумент -- "
"``template_name``, который указывает название шаблона, который необходимо "
"загрузить и отрендерить (или список шаблонов, Django будет использовать "
"первый найденный шаблон) -- и два необязательных:"

# 3e7ae697fec14b89bca23571eefe1a82
#: ../../ref/templates/api.txt:906
msgid "dictionary"
msgstr "dictionary"

# 0633e44d6a314835bce68844bc39a569
#: ../../ref/templates/api.txt:904
msgid ""
"A dictionary to be used as variables and values for the template's context. "
"This can also be passed as the second positional argument."
msgstr ""
"Словарь с переменными, который будет добавлен в контекст при рендеринге. "
"Можно передавать как второй позиционный аргумент."

# 7b4223f9a7814bf79d3ba0b9d1621600
#: ../../ref/templates/api.txt:911
msgid "context_instance"
msgstr "context_instance"

# 07b5417c1796444baf5205333b8da78c
#: ../../ref/templates/api.txt:909
msgid ""
"An instance of :class:`~django.template.Context` or a subclass (e.g., an "
"instance of :class:`~django.template.RequestContext`) to use as the "
"template's context. This can also be passed as the third positional argument."
msgstr ""
"Экземпляр :class:`~django.template.Context` или под-класса (например "
"экземпляр :class:`~django.template.RequestContext`), который будет "
"использоваться как контекст. Можно передавать как третий позиционный "
"аргумент."

# cf8d59a123e84504b351826b4304c0f1
#: ../../ref/templates/api.txt:913
msgid ""
"See also the :func:`~django.shortcuts.render_to_response()` shortcut, which "
"calls ``render_to_string`` and feeds the result into an :class:`~django.http."
"HttpResponse` suitable for returning directly from a view."
msgstr ""
"Смотрите также :func:`~django.shortcuts.render_to_response()`. Она вызывает "
"``render_to_string`` и передает в :class:`~django.http.HttpResponse`, "
"который можно вернуть из представления."

# f770006c4081468e8d776053a86e9107
#: ../../ref/templates/api.txt:918
msgid "Configuring the template system in standalone mode"
msgstr "Настройка системы шаблонов в стороннем приложении"

# 03a65f3e05234e26825dca20e92ca495
#: ../../ref/templates/api.txt:922
msgid ""
"This section is only of interest to people trying to use the template system "
"as an output component in another application. If you're using the template "
"system as part of a Django application, nothing here applies to you."
msgstr ""
"Этот раздел для тех, кто хочет использовать систему шаблонов в стороннем "
"приложении. Если вы используете Django для создания приложений, можете "
"пропустить этот раздел."

# f78697993cdb4fb6a21d15e5b00c0cb5
#: ../../ref/templates/api.txt:927
msgid ""
"Normally, Django will load all the configuration information it needs from "
"its own default configuration file, combined with the settings in the module "
"given in the :envvar:`DJANGO_SETTINGS_MODULE` environment variable. But if "
"you're using the template system independently of the rest of Django, the "
"environment variable approach isn't very convenient, because you probably "
"want to configure the template system in line with the rest of your "
"application rather than dealing with settings files and pointing to them via "
"environment variables."
msgstr ""
"Обычно Django загружает настройки из внутреннего файлы настроек, который "
"содержит настройки по умолчанию, затем дополняет настройками из модуля, "
"который указан в переменной окружения :envvar:`DJANGO_SETTINGS_MODULE`. Если "
"вы хотите использовать систему шаблонов без Django, использовать переменную "
"окружения не очень удобно, т.к. скорее всего вы захотите настраивать систему "
"шаблонов как и остальную часть приложения, а не выносить отдельно настройки "
"и указывать их через переменную окружения."

# 881a440b420b4a84b1fcfdde8cd5c32b
#: ../../ref/templates/api.txt:935
msgid ""
"To solve this problem, you need to use the manual configuration option "
"described in :ref:`settings-without-django-settings-module`. Simply import "
"the appropriate pieces of the templating system and then, *before* you call "
"any of the templating functions, call :func:`django.conf.settings."
"configure()` with any settings you wish to specify. You might want to "
"consider setting at least :setting:`TEMPLATE_DIRS` (if you're going to use "
"template loaders), :setting:`DEFAULT_CHARSET` (although the default of "
"``utf-8`` is probably fine) and :setting:`TEMPLATE_DEBUG`. If you plan to "
"use the :ttag:`url` template tag, you will also need to set the :setting:"
"`ROOT_URLCONF` setting. All available settings are described in the :doc:"
"`settings documentation </ref/settings>`, and any setting starting with "
"``TEMPLATE_`` is of obvious interest."
msgstr ""
"Для этого вы должны использовать явную настройку, описанную в :ref:`settings-"
"without-django-settings-module`. Просто импортируйте необходимый модуль "
"системы шаблонов, затем, *перед* использованием какого либо функционала, "
"вызовите :func:`django.conf.settings.configure()` с необходимыми "
"настройками. В первую очередь вам следует указать :setting:`TEMPLATE_DIRS` "
"(если вы хотите использовать загрузчики шаблонов), :setting:"
"`DEFAULT_CHARSET` (если ``utf-8`` по умолчанию вас не устраивает) и :setting:"
"`TEMPLATE_DEBUG`. Если вы планируете использовать тег :ttag:`url`, "
"необходимо указать :setting:`ROOT_URLCONF`. Все доступные настройки указаны "
"в :doc:`разделе о настройках Django </ref/settings>`, в первую очередь "
"обратите внимание на настройки, которые начинают с префикса ``TEMPLATE_``."

# 7a0e4a2f481d4aeb8d460c4e4b3506ba
#: ../../ref/templates/api.txt:950
msgid "Using an alternative template language"
msgstr "Использование других языков разметки шаблонов"

# b8886e9c4f554c94bda8403017890369
#: ../../ref/templates/api.txt:952
msgid ""
"The Django ``Template`` and ``Loader`` classes implement a simple API for "
"loading and rendering templates. By providing some simple wrapper classes "
"that implement this API we can use third party template systems like `Jinja2 "
"<http://jinja.pocoo.org/docs/>`_ or `Cheetah <http://www.cheetahtemplate.org/"
">`_. This allows us to use third-party template libraries without giving up "
"useful Django features like the Django ``Context`` object and handy "
"shortcuts like :func:`~django.shortcuts.render_to_response()`."
msgstr ""
"Классы ``Template`` и ``Loader`` предоставляют простой API для загрузки и "
"рендеринга шаблонов. Реализовав этот API вы можете использовать сторонние "
"системы шаблонов, например `Jinja2 <http://jinja.pocoo.org/docs/>`_ или "
"`Cheetah <http://www.cheetahtemplate.org/>`_. Это позволяет использовать "
"различные языки разметки шаблон вместе с полезным функционалом Django, "
"например объекты ``Context`` и функцию :func:`~django.shortcuts."
"render_to_response()`."

# c761273a76c24f8795b698c47b5ad833
#: ../../ref/templates/api.txt:960
msgid ""
"The core component of the Django templating system is the ``Template`` "
"class. This class has a very simple interface: it has a constructor that "
"takes a single positional argument specifying the template string, and a "
"``render()`` method that takes a :class:`~django.template.Context` object "
"and returns a string containing the rendered response."
msgstr ""
"Главный компонент системы шаблонов Django -- класс ``Template``. Этот класс "
"предоставляет очень простой интерфейс: его конструктор принимает строку "
"шаблона, а метод ``render()`` принимает объект :class:`~django.template."
"Context`и возвращает отрендеренный шаблон."

# cf5c429e2374405885de45b6191482ae
#: ../../ref/templates/api.txt:966
msgid ""
"Suppose we're using a template language that defines a ``Template`` object "
"with a ``render()`` method that takes a dictionary rather than a ``Context`` "
"object. We can write a simple wrapper that implements the Django "
"``Template`` interface::"
msgstr ""
"Предположим мы используем систему шаблонов, которая предоставляет объект "
"``Template`` с методом ``render()``, который принимает словарь вместо "
"объекта ``Context``. Мы может создать простой класс-обертку, который "
"реализует интерфейс класса ``Template`` Django::"

# 03648e77ce7d4457918a89fe9183aaad
#: ../../ref/templates/api.txt:979
msgid ""
"That's all that's required to make our fictional ``Template`` class "
"compatible with the Django loading and rendering system!"
msgstr ""
"Это все что необходимо, чтобы наш класс ``Template`` работал с загрузкой и "
"рендерингом шаблонов Django!"

# 19af1eb9afab482da382654eb5dbed66
#: ../../ref/templates/api.txt:982
msgid ""
"The next step is to write a ``Loader`` class that returns instances of our "
"custom template class instead of the default :class:`~django.template."
"Template`. Custom ``Loader`` classes should inherit from ``django.template."
"loader.BaseLoader`` and override the ``load_template_source()`` method, "
"which takes a ``template_name`` argument, loads the template from disk (or "
"elsewhere), and returns a tuple: ``(template_string, template_origin)``."
msgstr ""
"Следующий шаг -- создать класс ``Loader``, который возвращает экземпляры "
"нашего класса, а не стандартного :class:`~django.template.Template`. Наш "
"класс ``Loader`` должен наследоваться от ``django.template.loader."
"BaseLoader`` и переопределять метод ``load_template_source()``, который "
"принимает аргумент ``template_name``, загружает шаблон с файловой системы "
"(или другого источника), и возвращает кортеж: ``(template_string, "
"template_origin)``."

# 49b9f30483244915a7e7398162a8471b
#: ../../ref/templates/api.txt:989
msgid ""
"The ``load_template()`` method of the ``Loader`` class retrieves the "
"template string by calling ``load_template_source()``, instantiates a "
"``Template`` from the template source, and returns a tuple: ``(template, "
"template_origin)``. Since this is the method that actually instantiates the "
"``Template``, we'll need to override it to use our custom template class "
"instead. We can inherit from the builtin :class:`django.template.loaders."
"app_directories.Loader` to take advantage of the ``load_template_source()`` "
"method implemented there::"
msgstr ""
"Метод ``load_template()`` класса ``Loader`` загружает содержимое шаблона, "
"используя ``load_template_source()``, создает экземпляр ``Template`` с этим "
"содержимым, и возвращает кортеж: ``(template, template_origin)``. Т.к. этот "
"метод создает экземпляр ``Template``, нам необходимо переопределить его, "
"чтобы использовать наш класс. Мы может наследоваться от :class:`django."
"template.loaders.app_directories.Loader`, чтобы использовать возможности его "
"метода ``load_template_source()``::"

# 968ec19b83d144c783db3ac24f333baf
#: ../../ref/templates/api.txt:1006
msgid ""
"Finally, we need to modify our project settings, telling Django to use our "
"custom loader. Now we can write all of our templates in our alternative "
"template language while continuing to use the rest of the Django templating "
"system."
msgstr ""
"Теперь осталось поправить настройки проекта, указав Django использовать наш "
"загрузчик шаблонов. Теперь мы можем использовать собственный язык разметки "
"шаблонов вместе с остальным функционалом Django."
