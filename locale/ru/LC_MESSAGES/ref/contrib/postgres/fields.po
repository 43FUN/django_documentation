# Russian translations for Django package.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
# Automatically generated, 2015.
#
msgid ""
msgstr ""
"Project-Id-Version: Django 1.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-04-02 10:33+0300\n"
"PO-Revision-Date: 2015-03-19 15:06+0200\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"

#: ../../ref/contrib/postgres/fields.txt:2
msgid "PostgreSQL specific model fields"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:4
msgid ""
"All of these fields are available from the ``django.contrib.postgres."
"fields`` module."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:10
msgid "ArrayField"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:14
msgid ""
"A field for storing lists of data. Most field types can be used, you simply "
"pass another field instance as the :attr:`base_field <ArrayField."
"base_field>`. You may also specify a :attr:`size <ArrayField.size>`. "
"``ArrayField`` can be nested to store multi-dimensional arrays."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:22
msgid "This is a required argument."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:24
msgid ""
"Specifies the underlying data type and behavior for the array. It should be "
"an instance of a subclass of :class:`~django.db.models.Field`. For example, "
"it could be an :class:`~django.db.models.IntegerField` or a :class:`~django."
"db.models.CharField`. Most field types are permitted, with the exception of "
"those handling relational data (:class:`~django.db.models.ForeignKey`, :"
"class:`~django.db.models.OneToOneField` and :class:`~django.db.models."
"ManyToManyField`)."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:34
msgid ""
"It is possible to nest array fields - you can specify an instance of "
"``ArrayField`` as the ``base_field``. For example::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:49
msgid ""
"Transformation of values between the database and the model, validation of "
"data and configuration, and serialization are all delegated to the "
"underlying base field."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:55
msgid "This is an optional argument."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:57
msgid ""
"If passed, the array will have a maximum size as specified. This will be "
"passed to the database, although PostgreSQL at present does not enforce the "
"restriction."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:63
msgid ""
"When nesting ``ArrayField``, whether you use the `size` parameter or not, "
"PostgreSQL requires that the arrays are rectangular::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:84
msgid ""
"If irregular shapes are required, then the underlying field should be made "
"nullable and the values padded with ``None``."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:88
msgid "Querying ArrayField"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:90
msgid ""
"There are a number of custom lookups and transforms for :class:`ArrayField`. "
"We will use the following example model::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:106
#: ../../ref/contrib/postgres/fields.txt:309
#: ../../ref/contrib/postgres/fields.txt:507
msgid "contains"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:108
msgid ""
"The :lookup:`contains` lookup is overridden on :class:`ArrayField`. The "
"returned objects will be those where the values passed are a subset of the "
"data. It uses the SQL operator ``@>``. For example::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:128
#: ../../ref/contrib/postgres/fields.txt:329
#: ../../ref/contrib/postgres/fields.txt:515
msgid "contained_by"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:130
msgid ""
"This is the inverse of the :lookup:`contains <arrayfield.contains>` lookup - "
"the objects returned will be those where the data is a subset of the values "
"passed. It uses the SQL operator ``<@``. For example::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:147
#: ../../ref/contrib/postgres/fields.txt:523
msgid "overlap"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:149
msgid ""
"Returns objects where the data shares any results with the values passed. "
"Uses the SQL operator ``&&``. For example::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:165
msgid "len"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:167
msgid ""
"Returns the length of the array. The lookups available afterwards are those "
"available for :class:`~django.db.models.IntegerField`. For example::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:179
msgid "Index transforms"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:181
msgid ""
"This class of transforms allows you to index into the array in queries. Any "
"non-negative integer can be used. There are no errors if it exceeds the :"
"attr:`size <ArrayField.size>` of the array. The lookups available after the "
"transform are those from the :attr:`base_field <ArrayField.base_field>`. For "
"example::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:201
msgid ""
"PostgreSQL uses 1-based indexing for array fields when writing raw SQL. "
"However these indexes and those used in :lookup:`slices <arrayfield.slice>` "
"use 0-based indexing to be consistent with Python."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:208
msgid "Slice transforms"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:210
msgid ""
"This class of transforms allow you to take a slice of the array. Any two non-"
"negative integers can be used, separated by a single underscore. The lookups "
"available after the transform do not change. For example::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:226
msgid ""
"PostgreSQL uses 1-based indexing for array fields when writing raw SQL. "
"However these slices and those used in :lookup:`indexes <arrayfield.index>` "
"use 0-based indexing to be consistent with Python."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:230
msgid "Multidimensional arrays with indexes and slices"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:232
msgid ""
"PostgreSQL has some rather esoteric behavior when using indexes and slices "
"on multidimensional arrays. It will always work to use indexes to reach down "
"to the final underlying data, but most other slices behave strangely at the "
"database level and cannot be supported in a logical, consistent fashion by "
"Django."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:239
msgid "Indexing ArrayField"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:241
msgid ""
"At present using :attr:`~django.db.models.Field.db_index` will create a "
"``btree`` index. This does not offer particularly significant help to "
"querying. A more useful index is a ``GIN`` index, which you should create "
"using a :class:`~django.db.migrations.operations.RunSQL` operation."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:247
msgid "HStoreField"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:251
msgid ""
"A field for storing mappings of strings to strings. The Python data type "
"used is a ``dict``."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:256
msgid ""
"On occasions it may be useful to require or restrict the keys which are "
"valid for a given field. This can be done using the :class:`~django.contrib."
"postgres.validators.KeysValidator`."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:261
msgid "Querying HStoreField"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:263
msgid ""
"In addition to the ability to query by key, there are a number of custom "
"lookups available for ``HStoreField``."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:266
msgid "We will use the following example model::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:281
msgid "Key lookups"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:283
msgid ""
"To query based on a given key, you simply use that key as the lookup name::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:291
msgid "You can chain other lookups after key lookups::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:296
msgid ""
"If the key you wish to query by clashes with the name of another lookup, you "
"need to use the :lookup:`hstorefield.contains` lookup instead."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:301
msgid ""
"Since any string could be a key in a hstore value, any lookup other than "
"those listed below will be interpreted as a key lookup. No errors are "
"raised. Be extra careful for typing mistakes, and always check your queries "
"work as you intend."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:311
msgid ""
"The :lookup:`contains` lookup is overridden on :class:`~django.contrib."
"postgres.fields.HStoreField`. The returned objects are those where the given "
"``dict`` of key-value pairs are all contained in the field. It uses the SQL "
"operator ``@>``. For example::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:331
msgid ""
"This is the inverse of the :lookup:`contains <hstorefield.contains>` lookup "
"- the objects returned will be those where the key-value pairs on the object "
"are a subset of those in the value passed. It uses the SQL operator ``<@``. "
"For example::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:349
msgid "has_key"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:351
msgid ""
"Returns objects where the given key is in the data. Uses the SQL operator ``?"
"``. For example::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:363
msgid "has_keys"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:365
msgid ""
"Returns objects where all of the given keys are in the data. Uses the SQL "
"operator ``?&``. For example::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:377
msgid "keys"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:379
msgid ""
"Returns objects where the array of keys is the given value. Note that the "
"order is not guaranteed to be reliable, so this transform is mainly useful "
"for using in conjunction with lookups on :class:`~django.contrib.postgres."
"fields.ArrayField`. Uses the SQL function ``akeys()``. For example::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:394
msgid "values"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:396
msgid ""
"Returns objects where the array of values is the given value. Note that the "
"order is not guaranteed to be reliable, so this transform is mainly useful "
"for using in conjunction with lookups on :class:`~django.contrib.postgres."
"fields.ArrayField`. Uses the SQL function ``avalues()``. For example::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:411
msgid "Range Fields"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:413
msgid ""
"There are five range field types, corresponding to the built-in range types "
"in PostgreSQL. These fields are used to store a range of values; for example "
"the start and end timestamps of an event, or the range of ages an activity "
"is suitable for."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:418
msgid ""
"All of the range fields translate to :ref:`psycopg2 Range objects <psycopg2:"
"adapt-range>` in python, but also accept tuples as input if no bounds "
"information is necessary. The default is lower bound included, upper bound "
"excluded."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:424
msgid "IntegerRangeField"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:428
msgid ""
"Stores a range of integers. Based on an :class:`~django.db.models."
"IntegerField`. Represented by an ``int4range`` in the database and a :class:"
"`~psycopg2:psycopg2.extras.NumericRange` in Python."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:434
msgid "BigIntegerRangeField"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:438
msgid ""
"Stores a range of large integers. Based on a :class:`~django.db.models."
"BigIntegerField`. Represented by an ``int8range`` in the database and a :"
"class:`~psycopg2:psycopg2.extras.NumericRange` in Python."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:444
msgid "FloatRangeField"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:448
msgid ""
"Stores a range of floating point values. Based on a :class:`~django.db."
"models.FloatField`. Represented by a ``numrange`` in the database and a :"
"class:`~psycopg2:psycopg2.extras.NumericRange` in Python."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:453
msgid "DateTimeRangeField"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:457
msgid ""
"Stores a range of timestamps. Based on a :class:`~django.db.models."
"DateTimeField`. Represented by a ``tztsrange`` in the database and a :class:"
"`~psycopg2:psycopg2.extras.DateTimeTZRange` in Python."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:463
msgid "DateRangeField"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:467
msgid ""
"Stores a range of dates. Based on a :class:`~django.db.models.DateField`. "
"Represented by a ``daterange`` in the database and a :class:`~psycopg2:"
"psycopg2.extras.DateRange` in Python."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:472
msgid "Querying Range Fields"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:474
msgid ""
"There are a number of custom lookups and transforms for range fields. They "
"are available on all the above fields, but we will use the following example "
"model::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:488
msgid "We will also use the following example objects::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:493
msgid "and ``NumericRange``:"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:498
msgid "Containment functions"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:500
msgid ""
"As with other PostgreSQL fields, there are three standard containment "
"operators: ``contains``, ``contained_by`` and ``overlap``, using the SQL "
"operators ``@>``, ``<@``, and ``&&`` respectively."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:529
msgid "Comparison functions"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:531
msgid ""
"Range fields support the standard lookups: :lookup:`lt`, :lookup:`gt`, :"
"lookup:`lte` and :lookup:`gte`. These are not particularly helpful - they "
"compare the lower bounds first and then the upper bounds only if necessary. "
"This is also the strategy used to order by a range field. It is better to "
"use the specific range comparison operators."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:540
msgid "fully_lt"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:542
msgid ""
"The returned ranges are strictly less than the passed range. In other words, "
"all the points in the returned range are less than all those in the passed "
"range."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:552
msgid "fully_gt"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:554
msgid ""
"The returned ranges are strictly greater than the passed range. In other "
"words, the all the points in the returned range are greater than all those "
"in the passed range."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:564
msgid "not_lt"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:566
msgid ""
"The returned ranges do not contain any points less than the passed range, "
"that is the lower bound of the returned range is at least the lower bound of "
"the passed range."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:576
msgid "not_gt"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:578
msgid ""
"The returned ranges do not contain any points greater than the passed range, "
"that is the upper bound of the returned range is at most the upper bound of "
"the passed range."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:588
msgid "adjacent_to"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:590
msgid "The returned ranges share a bound with the passed range."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:596
msgid "Querying using the bounds"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:598
msgid ""
"There are three transforms available for use in queries. You can extract the "
"lower or upper bound, or query based on emptiness."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:604
msgid "startswith"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:606
msgid ""
"Returned objects have the given lower bound. Can be chained to valid lookups "
"for the base field."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:615
msgid "endswith"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:617
msgid ""
"Returned objects have the given upper bound. Can be chained to valid lookups "
"for the base field."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:626
msgid "isempty"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:628
msgid ""
"Returned objects are empty ranges. Can be chained to valid lookups for a :"
"class:`~django.db.models.BooleanField`."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:635
msgid "Defining your own range types"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:637
msgid ""
"PostgreSQL allows the definition of custom range types. Django's model and "
"form field implementations use base classes below, and psycopg2 provides a :"
"func:`~psycopg2:psycopg2.extras.register_range` to allow use of custom range "
"types."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:644
msgid "Base class for model range fields."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:648
msgid "The model field to use."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:652
#: ../../ref/contrib/postgres/fields.txt:669
msgid "The psycopg2 range type to use."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:656
msgid ""
"The form field class to use. Should be a subclass of :class:`django.contrib."
"postgres.forms.BaseRangeField`."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:661
msgid "Base class for form range fields."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:665
msgid "The form field to use."
msgstr ""
