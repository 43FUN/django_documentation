# Russian translations for Django package.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
# Automatically generated <>, 2012, 2013.
#
msgid ""
msgstr ""
"Project-Id-Version: Django 1.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2013-02-27 00:21\n"
"PO-Revision-Date: 2013-05-13 00:33+0300\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"

# 649d32f81a064b32986e8b43eb7595ab
#: ../../ref/models/instances.txt:3
msgid "Model instance reference"
msgstr "Объект модели"

# c6efd924e01f4f5e85840f18f35c7521
#: ../../ref/models/instances.txt:7
msgid ""
"This document describes the details of the ``Model`` API. It builds on the "
"material presented in the :doc:`model </topics/db/models>` and :doc:"
"`database query </topics/db/queries>` guides, so you'll probably want to "
"read and understand those documents before reading this one."
msgstr ""
"Этот раздел описывает ``Model`` API. Изложенный материал опирается на "
"материал, изложенный в разделах о :doc:`моделях </topics/db/models>` и :doc:"
"`выполнении запросов </topics/db/queries>`, возможно вам следует прочитать "
"их перед прочтением этого раздела."

# 9e05c32aecc046e7ab0539d8b19518ec
#: ../../ref/models/instances.txt:12
msgid ""
"Throughout this reference we'll use the :ref:`example Weblog models "
"<queryset-model-example>` presented in the :doc:`database query guide </"
"topics/db/queries>`."
msgstr ""
"В примерах будут использованы :ref:` примеры моделей web-блога <queryset-"
"model-example>` представленные в разделе о :doc:`выполнении запросов </"
"topics/db/queries>`."

# 0c1451ca4f1545dbbb555d1be14cfe78
#: ../../ref/models/instances.txt:17
msgid "Creating objects"
msgstr "Создание объектов"

# 35323d643346474b90514a3432055e40
#: ../../ref/models/instances.txt:19
msgid ""
"To create a new instance of a model, just instantiate it like any other "
"Python class:"
msgstr ""
"Что бы создать объект модели, просто создайте ее экземпляр как любого "
"другого класса Python:"

# 23fe6764d1174f5897dac08572e9dc9b
#: ../../ref/models/instances.txt:24
msgid ""
"The keyword arguments are simply the names of the fields you've defined on "
"your model. Note that instantiating a model in no way touches your database; "
"for that, you need to :meth:`~Model.save()`."
msgstr ""
"Именованные аргументы это названия полей определенных в модели. Создание "
"экземпляра модели не выполняет никаких запросов к базе данных; для "
"сохранение вызовите метод :meth:`~Model.save()`."

# fdf8a912a25143dba9bda386a47eb2d3
#: ../../ref/models/instances.txt:30
msgid ""
"You may be tempted to customize the model by overriding the ``__init__`` "
"method. If you do so, however, take care not to change the calling signature "
"as any change may prevent the model instance from being saved. Rather than "
"overriding ``__init__``, try using one of these approaches:"
msgstr ""
"Возможно вам захочется переопределить метод ``__init__``. В таком случае не "
"переопределяйте сигнатуру вызова этого метода, иначе объект модели может не "
"сохраняться. Вместо переопределения ``__init__`` лучше используйте один из "
"следующих подходов:"

# e484785c269c4b5480bea184149e8068
#: ../../ref/models/instances.txt:35
msgid "Add a classmethod on the model class::"
msgstr "Добавить метод класса в модель::"

# 9212d78f8f2346a48ec444903a7425f0
#: ../../ref/models/instances.txt:48
msgid "Add a method on a custom manager (usually preferred)::"
msgstr "Добавить метод в менеджер модели(лучший вариант)::"

# a1af197f5374441fbd6f668e42644aef
#: ../../ref/models/instances.txt:66
msgid "Validating objects"
msgstr "Проверка объектов"

# 93bd9a6303ac44f981b1dcbe691d5c83
#: ../../ref/models/instances.txt:68
msgid "There are three steps involved in validating a model:"
msgstr "Проверка объектов модели проходив в три этапа:"

# 2d28ada844a04da99aff382e3cec5dcd
#: ../../ref/models/instances.txt:70
msgid "Validate the model fields - :meth:`Model.clean_fields()`"
msgstr "Проверка полей модели - :meth:`Model.clean_fields()`"

# 5960436d670c49339e1f8a77a898d12f
#: ../../ref/models/instances.txt:71
msgid "Validate the model as a whole - :meth:`Model.clean()`"
msgstr "Проверка всего объекта - :meth:`Model.clean()`"

# d3c5d873719c4115a6ed637da6a6642b
#: ../../ref/models/instances.txt:72
msgid "Validate the field uniqueness - :meth:`Model.validate_unique()`"
msgstr "Проверка уникальности полей - :meth:`Model.validate_unique()`"

# c04c6f856f3f42c9af2f08d69dce7d7b
#: ../../ref/models/instances.txt:74
msgid ""
"All three steps are performed when you call a model's :meth:`~Model."
"full_clean()` method."
msgstr ""
"Все три этапа выполняются при вызове метода :meth:`~Model.full_clean()`."

# 0ef0de90d1694bd6a19ea26ae8fa0ac2
#: ../../ref/models/instances.txt:77
msgid ""
"When you use a :class:`~django.forms.ModelForm`, the call to :meth:`~django."
"forms.Form.is_valid()` will perform these validation steps for all the "
"fields that are included on the form. See the :doc:`ModelForm documentation "
"</topics/forms/modelforms>` for more information. You should only need to "
"call a model's :meth:`~Model.full_clean()` method if you plan to handle "
"validation errors yourself, or if you have excluded fields from the :class:"
"`~django.forms.ModelForm` that require validation."
msgstr ""
"При использовании :class:`~django.forms.ModelForm`, вызов :meth:`~django."
"forms.Form.is_valid()` выполняет проверку для всех полей включенных в форму. "
"Подробности смотрите :doc:`раздел о ModelForm </topics/forms/modelforms>`. "
"Вы должны использовать метод :meth:`~Model.full_clean()` модели только если "
"собираетесь самостоятельно обрабатывать ошибки валидности, или если :class:"
"`~django.forms.ModelForm` не содержит поля, которые должны проверяться."

# 06e39a0d61cf4fd8b83b5cea1435e0a3
#: ../../ref/models/instances.txt:87
msgid ""
"This method calls :meth:`Model.clean_fields()`, :meth:`Model.clean()`, and :"
"meth:`Model.validate_unique()`, in that order and raises a :exc:`~django."
"core.exceptions.ValidationError` that has a ``message_dict`` attribute "
"containing errors from all three stages."
msgstr ""
"Этот метод вызывает :meth:`Model.clean_fields()`, :meth:`Model.clean()`, и :"
"meth:`Model.validate_unique()` в указанном порядке и вызывает исключение :"
"exc:`~django.core.exceptions.ValidationError`, которое содержит атрибут "
"``message_dict`` с ошибками всех трех этапов проверки."

# 63d338c2a66e4453b34aad181339d1a7
#: ../../ref/models/instances.txt:92
msgid ""
"The optional ``exclude`` argument can be used to provide a list of field "
"names that can be excluded from validation and cleaning. :class:`~django."
"forms.ModelForm` uses this argument to exclude fields that aren't present on "
"your form from being validated since any errors raised could not be "
"corrected by the user."
msgstr ""
"Необязательный аргумент ``exclude`` используется, что бы исключить часть "
"полей из проверки. :class:`~django.forms.ModelForm` использует этот аргумент "
"для полей не включенных в форму, так как ошибки для этих полей не могут быть "
"исправлены пользователем."

# 1a6a7d81bc384d96aad756aad0f488ca
#: ../../ref/models/instances.txt:98
msgid ""
"Note that ``full_clean()`` will *not* be called automatically when you call "
"your model's :meth:`~Model.save()` method, nor as a result of :class:"
"`~django.forms.ModelForm` validation. In the case of :class:`~django.forms."
"ModelForm` validation, :meth:`Model.clean_fields()`, :meth:`Model.clean()`, "
"and :meth:`Model.validate_unique()` are all called individually."
msgstr ""
"Заметим, ``full_clean()`` *не* вызывается ни при вызове метода :meth:`~Model."
"save()` модели, ни в результате проверки в :class:`~django.forms.ModelForm`. "
"В этом случае вызывается :class:`~django.forms.ModelForm` validation, :meth:"
"`Model.clean_fields()`, :meth:`Model.clean()` и :meth:`Model.validate_unique"
"()`."

# e1a3dcc242d3470fad26fa9bd9828a0d
#: ../../ref/models/instances.txt:105
msgid ""
"You'll need to call ``full_clean`` manually when you want to run one-step "
"model validation for your own manually created models. For example::"
msgstr ""
"Если вы хотите проверить созданный вами объект, вызовите ``full_clean``. "
"Например::"

# 6c596143cc8a410eadd412441a29c35c
#: ../../ref/models/instances.txt:115
msgid ""
"The first step ``full_clean()`` performs is to clean each individual field."
msgstr "Первым делом ``full_clean()`` выполняет проверку каждого поля."

# 59bc3b15bd0246f58c315b3ace31c220
#: ../../ref/models/instances.txt:119
msgid ""
"This method will validate all fields on your model. The optional ``exclude`` "
"argument lets you provide a list of field names to exclude from validation. "
"It will raise a :exc:`~django.core.exceptions.ValidationError` if any fields "
"fail validation."
msgstr ""
"Этот метод проверяет все поля модели. Необязательный аргумент ``exclude`` "
"используется, что бы исключить часть полей из проверки. Если одно из полей "
"не пройдет проверку, будет вызвано исключение :exc:`~django.core.exceptions."
"ValidationError`."

# 5a68808ab9ab4bf5a61145be54c1134a
#: ../../ref/models/instances.txt:124
msgid ""
"The second step ``full_clean()`` performs is to call :meth:`Model.clean()`. "
"This method should be overridden to perform custom validation on your model."
msgstr ""
"Следующим этапов проверки в ``full_clean()`` будет вызов метода :meth:`Model."
"clean()`. Этот метод должен быть переопределен, если вам нужна "
"дополнительная проверка модели."

# 84b3e98dac6644bfae1c75bb3ba03ba5
#: ../../ref/models/instances.txt:129
msgid ""
"This method should be used to provide custom model validation, and to modify "
"attributes on your model if desired. For instance, you could use it to "
"automatically provide a value for a field, or to do validation that requires "
"access to more than a single field::"
msgstr ""
"Этот метод должен быть переопределен, если вам нужна дополнительная проверка "
"модели или изменить значения атрибутов. Для объектов, вы можете определить "
"его для автоматического определения полей, или для проверки, которая требует "
"значения нескольких полей::"

# add054fa6fe04f13bc58b99020a5edab
#: ../../ref/models/instances.txt:143
msgid ""
"Any :exc:`~django.core.exceptions.ValidationError` exceptions raised by "
"``Model.clean()`` will be stored in a special key error dictionary key, "
"``NON_FIELD_ERRORS``, that is used for errors that are tied to the entire "
"model instead of to a specific field::"
msgstr ""
"Любое исключение :exc:`~django.core.exceptions.ValidationError` вызванное в "
"``Model.clean()`` будет сохранено со специальным ключом в словаре ошибок, "
"``NON_FIELD_ERRORS``, который используется для ошибок относящихся ко всей "
"модели, а не конкретному полю::"

# 91c9d98f74c54c40a03252a75f9e3ca8
#: ../../ref/models/instances.txt:154
msgid ""
"Finally, ``full_clean()`` will check any unique constraints on your model."
msgstr "Так же ``full_clean()`` выполняет все проверки на уникальность модели."

# 50104e825b5444d783baf3fa5ac928c7
#: ../../ref/models/instances.txt:158
msgid ""
"This method is similar to :meth:`~Model.clean_fields`, but validates all "
"uniqueness constraints on your model instead of individual field values. The "
"optional ``exclude`` argument allows you to provide a list of field names to "
"exclude from validation. It will raise a :exc:`~django.core.exceptions."
"ValidationError` if any fields fail validation."
msgstr ""
"Этот метод похож на :meth:`~Model.clean_fields`, но проверяет уникальность "
"полей, используя все определенные правила, а не значения полей."
"Необязательный аргумент ``exclude`` используется, что бы исключить часть "
"полей из проверки. Вызывает исключение :exc:`~django.core.exceptions."
"ValidationError`, если поле не прошло проверку."

# 03268cec819643c6b67a15565ec4818b
#: ../../ref/models/instances.txt:164
msgid ""
"Note that if you provide an ``exclude`` argument to ``validate_unique()``, "
"any :attr:`~django.db.models.Options.unique_together` constraint involving "
"one of the fields you provided will not be checked."
msgstr ""
"Заметим, при использовании аргумента ``exclude``, все правила определенные "
"в :attr:`~django.db.models.Options.unique_together`, включающие одно из "
"указанных полей, не будет учитываться при проверке."

# 098c3d147234461bad39df3e02a35830
#: ../../ref/models/instances.txt:170
msgid "Saving objects"
msgstr "Сохранение объектов"

# c840ed2fcba34cca99fd1acd27a82263
#: ../../ref/models/instances.txt:172
msgid "To save an object back to the database, call ``save()``:"
msgstr "Что бы сохранить объект в базе данных, используйте ``save()``:"

# 5ba36080b7ba4d20994326616e1ef50d
#: ../../ref/models/instances.txt:176
msgid ""
"If you want customized saving behavior, you can override this ``save()`` "
"method. See :ref:`overriding-model-methods` for more details."
msgstr ""
"Если вы хотите изменить процесс сохранения, переопределите метод ``save()``. "
"Подробности в разделе :ref:`overriding-model-methods`."

# c52b843201a2476fa312ed7b6bf111ec
#: ../../ref/models/instances.txt:179
msgid ""
"The model save process also has some subtleties; see the sections below."
msgstr "Процесс сохранения модели имеет ряд особенностей описанных ниже."

# f774cc85cd73454bb517c9844e7254d3
#: ../../ref/models/instances.txt:182
msgid "Auto-incrementing primary keys"
msgstr "Автоинкрементные первичные ключи"

# 40ea6476c815472688ba7fbbcfc19fa5
#: ../../ref/models/instances.txt:184
msgid ""
"If a model has an :class:`~django.db.models.AutoField` — an auto-"
"incrementing primary key — then that auto-incremented value will be "
"calculated and saved as an attribute on your object the first time you call "
"``save()``::"
msgstr ""
"Если модель содержит :class:`~django.db.models.AutoField` — автоинкрементный "
"первичный ключи — его значение будет вычислено и сохранено в атрибут объекта "
"при первом вызове метода ``save()``::"

# 651b53b421564ed38375f6909679f70e
#: ../../ref/models/instances.txt:193
msgid ""
"There's no way to tell what the value of an ID will be before you call ``save"
"()``, because that value is calculated by your database, not by Django."
msgstr ""
"Нельзя точно сказать каким будет значение ID до вызова метода ``save()``, "
"так как оно вычисляется базой данных, а не Django."

# 9b83a66be2014246a4a2c59d1d6f957e
#: ../../ref/models/instances.txt:196
msgid ""
"For convenience, each model has an :class:`~django.db.models.AutoField` "
"named ``id`` by default unless you explicitly specify ``primary_key=True`` "
"on a field in your model. See the documentation for :class:`~django.db."
"models.AutoField` for more details."
msgstr ""
"Для удобства каждая модель содержит полей :class:`~django.db.models."
"AutoField` с названием ``id``, если вы не указали параметр "
"``primary_key=True`` для поля модели. Подробности в описании :class:`~django."
"db.models.AutoField`."

# 190326b03b374f859182598c91a12f37
#: ../../ref/models/instances.txt:202
msgid "The ``pk`` property"
msgstr "Свойство ``pk``"

# f539c4204852435a95e3b12a1412b519
#: ../../ref/models/instances.txt:206
msgid ""
"Regardless of whether you define a primary key field yourself, or let Django "
"supply one for you, each model will have a property called ``pk``. It "
"behaves like a normal attribute on the model, but is actually an alias for "
"whichever attribute is the primary key field for the model. You can read and "
"set this value, just as you would for any other attribute, and it will "
"update the correct field in the model."
msgstr ""
"Независимо от того, определили вы первичный ключ самостоятельно, или "
"позволили Django добавить его, каждая модель содержит свойство ``pk``. Он "
"ведет себя как обычный атрибут, но на самом деле является псевдонимом для "
"атрибута первичного ключа. Вы можете получить или установить его значение, "
"так же как и любого другого атрибута, при этом будет обновлено "
"соответствующее поле модели."

# 206bfe2281e3478ba50e6cd99f458b05
#: ../../ref/models/instances.txt:214
msgid "Explicitly specifying auto-primary-key values"
msgstr "Явное определение значения первичного ключа"

# daf5d25b018a4eb58a7907f4d0f07994
#: ../../ref/models/instances.txt:216
msgid ""
"If a model has an :class:`~django.db.models.AutoField` but you want to "
"define a new object's ID explicitly when saving, just define it explicitly "
"before saving, rather than relying on the auto-assignment of the ID::"
msgstr ""
"Если модель содержит :class:`~django.db.models.AutoField` но вы хотите явно "
"указать значение ID нового объекта при сохранении, просто укажите его::"

# 3a93a98526b8426ab9497a2aac2905f2
#: ../../ref/models/instances.txt:225
msgid ""
"If you assign auto-primary-key values manually, make sure not to use an "
"already-existing primary-key value! If you create a new object with an "
"explicit primary-key value that already exists in the database, Django will "
"assume you're changing the existing record rather than creating a new one."
msgstr ""
"Если вы определяете значение первичного автоинкрементного ключа, убедитесь "
"что это значение не существует уже в базе данных! Если вы укажите "
"существующее в базе значение, Django предположит что вы хотите изменить "
"запись в базе данных, а не сохранить новую."

# 35bff39e62734d489e22b1fa14ae38f8
#: ../../ref/models/instances.txt:230
msgid ""
"Given the above ``'Cheddar Talk'`` blog example, this example would override "
"the previous record in the database::"
msgstr ""
"Учитывая пример с блогом ``'Cheddar Talk'`` выше, этот код перезапишет "
"предыдущий объект в базе данных::"

# 819cafcb27af459785fec1a2a0eae827
#: ../../ref/models/instances.txt:236
msgid ""
"See `How Django knows to UPDATE vs. INSERT`_, below, for the reason this "
"happens."
msgstr ""
"О том, как это определяется, смотрите `How Django knows to UPDATE vs. "
"INSERT`_ ниже."

# 5be5ef59904444f9821b174edb1dbdc0
#: ../../ref/models/instances.txt:239
msgid ""
"Explicitly specifying auto-primary-key values is mostly useful for bulk-"
"saving objects, when you're confident you won't have primary-key collision."
msgstr ""
"Явное определение первичного ключа в основном полезно при сохранении "
"множества объектов, когда вы уверенны что все значения уникальны."

# d04372d78ad4406aa992d39972fe9a8f
#: ../../ref/models/instances.txt:243
msgid "What happens when you save?"
msgstr "Что происходит при сохранении?"

# fc8ca633e516453ea0ed02cb05bd78b1
#: ../../ref/models/instances.txt:245
msgid "When you save an object, Django performs the following steps:"
msgstr "При сохранении объекта Django выполняет следующие шаги:"

# 49a649847dc940979b384aa452c71120
#: ../../ref/models/instances.txt:247
msgid ""
"**Emit a pre-save signal.** The :doc:`signal </ref/signals>` :attr:`django."
"db.models.signals.pre_save` is sent, allowing any functions listening for "
"that signal to take some customized action."
msgstr ""
"**Посылается сигнал pre-save.** Посылается сигнал :attr:`django.db.models."
"signals.pre_save`, позволяя функциям, обрабатывающим этот сигнал, выполнить "
"какие-либо действия."

# 40caa366c585447dafced6ad65484e31
#: ../../ref/models/instances.txt:252
msgid ""
"**Pre-process the data.** Each field on the object is asked to perform any "
"automated data modification that the field may need to perform."
msgstr ""
"**Предварительная обработка данных.** Каждое поле объекта выполняет "
"изменения значения поля при необходимости."

# bedb769fff8148bc9f47e76ac72d11c2
#: ../../ref/models/instances.txt:256
msgid ""
"Most fields do *no* pre-processing — the field data is kept as-is. Pre-"
"processing is only used on fields that have special behavior.  For example, "
"if your model has a :class:`~django.db.models.DateField` with "
"``auto_now=True``, the pre-save phase will alter the data in the object to "
"ensure that the date field contains the current date stamp. (Our "
"documentation doesn't yet include a list of all the fields with this "
"\"special behavior.\")"
msgstr ""
"Большинство полей *не* выполняют предварительную обработку данных — значение "
"полей сохраняется как оно есть. Она выполняется для полей с особым "
"поведением. Например, если ваша модель содержит поле :class:`~django.db."
"models.DateField` с ``auto_now=True``, на этапе предварительной обработки "
"значение поля будет установлено в текущую дату. (Наша документация пока не "
"содержит список полей с \"особым поведением\".)"

# a69652b8dc60447a952cccd013446ab8
#: ../../ref/models/instances.txt:264
msgid ""
"**Prepare the data for the database.** Each field is asked to provide its "
"current value in a data type that can be written to the database."
msgstr ""
"**Подготовка данных для базы данных.** Каждое поле преобразует текущее "
"значение к типу данных, которой может быть сохранен в базу данных."

# e82d742cedf142fc98ede65b66888951
#: ../../ref/models/instances.txt:267
msgid ""
"Most fields require *no* data preparation. Simple data types, such as "
"integers and strings, are 'ready to write' as a Python object. However, more "
"complex data types often require some modification."
msgstr ""
"Большинство полей *не* требует подготовки данных. Простые типы данных, такие "
"как числа и строки, уже 'готовы к сохранению' как объекты Python. Однако, "
"большинство сложных типов данных требуют некоторой модификации."

# e03d498e9b2240698a9d9927cea8db6b
#: ../../ref/models/instances.txt:271
msgid ""
"For example, :class:`~django.db.models.DateField` fields use a Python "
"``datetime`` object to store data. Databases don't store ``datetime`` "
"objects, so the field value must be converted into an ISO-compliant date "
"string for insertion into the database."
msgstr ""
"Например, поле :class:`~django.db.models.DateField` использует объект Python "
"``datetime`` для хранения значения. База данных не принимает объект "
"``datetime``, поэтому значение поля должно быть преобразовано в строковое "
"представление даты в соответствии стандарту ISO перед сохранением в базу "
"данных."

# 91daa17ee949449ab037d99f75483d64
#: ../../ref/models/instances.txt:276
msgid ""
"**Insert the data into the database.** The pre-processed, prepared data is "
"then composed into an SQL statement for insertion into the database."
msgstr ""
"**Сохранение данных в базе данных.** Предварительно обработанные, "
"подготовленные данные формируются в SQL запрос, который выполняется в базе "
"данных."

# 91052ed0d4524864805f7340fb7cc2f3
#: ../../ref/models/instances.txt:280
msgid ""
"**Emit a post-save signal.** The signal :attr:`django.db.models.signals."
"post_save` is sent, allowing any functions listening for that signal to take "
"some customized action."
msgstr ""
"**Посылается сигнал post-save.** Посылается сигнал :attr:`django.db.models."
"signals.post_save`, позволяя функциям, обрабатывающим этот сигнал, выполнить "
"какие-либо действия."

# 445b4fbfdf014f23bc065356b5f68677
#: ../../ref/models/instances.txt:286
msgid "How Django knows to UPDATE vs. INSERT"
msgstr "Как Django определят использовать UPDATE или INSERT"

# a692e205b6a04318ac7a2d019f0eacbb
#: ../../ref/models/instances.txt:288
msgid ""
"You may have noticed Django database objects use the same ``save()`` method "
"for creating and changing objects. Django abstracts the need to use "
"``INSERT`` or ``UPDATE`` SQL statements. Specifically, when you call ``save()"
"``, Django follows this algorithm:"
msgstr ""
"Вы уже заметили что объекты модели используют метод ``save()`` как для "
"создания так и для изменения записи в базе данных. Django самостоятельно "
"определяет использовать ``INSERT`` или ``UPDATE``. При вызове ``save()``, "
"Django следует такому алгоритму:"

# b3dcce1ebf954ca482fd930b73e57efa
#: ../../ref/models/instances.txt:293
msgid ""
"If the object's primary key attribute is set to a value that evaluates to "
"``True`` (i.e., a value other than ``None`` or the empty string), Django "
"executes a ``SELECT`` query to determine whether a record with the given "
"primary key already exists."
msgstr ""
"Если атрибут первичного ключа объекта содержи значение равное ``True`` "
"(например, не ``None`` или не пустая строка), Django выполняет ``SELECT`` "
"запрос, что бы определить существует ли запись с указанным первичным ключом."

# bed72b10d96343c4b711127d99134753
#: ../../ref/models/instances.txt:297
msgid ""
"If the record with the given primary key does already exist, Django executes "
"an ``UPDATE`` query."
msgstr ""
"Если запись с указанным первичным ключом уже существует, Django выполняет "
"``UPDATE`` запрос."

# a13f1673a6524d59a3f2dd04dc251464
#: ../../ref/models/instances.txt:299
msgid ""
"If the object's primary key attribute is *not* set, or if it's set but a "
"record doesn't exist, Django executes an ``INSERT``."
msgstr ""
"Если первичный ключ *не* указан, или указан, но запись не существует в базе "
"данных, Django выполнит ``INSERT``."

# 34aa17e5fafd43b08b28323d32cdadef
#: ../../ref/models/instances.txt:302
msgid ""
"The one gotcha here is that you should be careful not to specify a primary-"
"key value explicitly when saving new objects, if you cannot guarantee the "
"primary-key value is unused. For more on this nuance, see `Explicitly "
"specifying auto-primary-key values`_ above and `Forcing an INSERT or "
"UPDATE`_ below."
msgstr ""
"Будьте осторожны, явно указывая значение первичного ключа при сохранении "
"нового объекта, если вы не уверенны, что этот первичный ключ не "
"используется. Более подробно об этом читайте  `Explicitly specifying auto-"
"primary-key values`_ и `Принудительное выполнение INSERT или UPDATE <ref-"
"models-force-insert>`_."

# d180ef568b2b4c21a0763872d5b1b3f8
#: ../../ref/models/instances.txt:310
msgid "Forcing an INSERT or UPDATE"
msgstr "Принудительное выполнение INSERT или UPDATE"

# 46e1acd5799248f49c7010a3adb1174a
#: ../../ref/models/instances.txt:312
msgid ""
"In some rare circumstances, it's necessary to be able to force the :meth:"
"`~Model.save()` method to perform an SQL ``INSERT`` and not fall back to "
"doing an ``UPDATE``. Or vice-versa: update, if possible, but not insert a "
"new row. In these cases you can pass the ``force_insert=True`` or "
"``force_update=True`` parameters to the :meth:`~Model.save()` method. "
"Obviously, passing both parameters is an error: you cannot both insert *and* "
"update at the same time!"
msgstr ""
"В редких случаях, может понадобиться принудительно заставить метод :meth:"
"`~Model.save()` выполнить ``INSERT`` запрос вместо ``UPDATE``. Или наоборот: "
"обновить, при возможности, но не добавлять новую запись. В этом случае вы "
"можете указать аргумент ``force_insert=True`` или ``force_update=True`` для "
"метода :meth:`~Model.save()`. Очевидно, не правильно использовать оба "
"аргумента вместе: вы не можете добавлять *и* обновлять одновременно!"

# 7aa800ee3a5d43b2a798e4d6993f27f8
#: ../../ref/models/instances.txt:320
msgid ""
"It should be very rare that you'll need to use these parameters. Django will "
"almost always do the right thing and trying to override that will lead to "
"errors that are difficult to track down. This feature is for advanced use "
"only."
msgstr ""
"Вряд ли вам понадобится использовать эти параметры. Django почти всегда "
"сделает то, что вам нужно, и переопределение такого поведения может привести "
"к ошибкам, которые трудно отследить. Эта функция предназначена для опытных "
"пользователей."

# 0cd8870db8004752b273f5fcb9f3c9dc
#: ../../ref/models/instances.txt:325
msgid ""
"Using ``update_fields`` will force an update similarly to ``force_update``."
msgstr ""
"Использование ``update_fields`` инициирует обновление объекта, как и при "
"вызове ``force_update``."

# 3e9e7e8e699741929140673d8bdd9a74
#: ../../ref/models/instances.txt:328
msgid "Updating attributes based on existing fields"
msgstr "Обновление значений полей"

# 5280780451ad4fb195240aac2eacc58b
#: ../../ref/models/instances.txt:330
msgid ""
"Sometimes you'll need to perform a simple arithmetic task on a field, such "
"as incrementing or decrementing the current value. The obvious way to "
"achieve this is to do something like::"
msgstr ""
"Иногда вам может понадобиться выполнить простые арифметические операции над "
"полями, такие как увеличить или уменьшить текущее значение. Очевидный способ "
"сделать это::"

# e928f345411d488ab159890fccc309c2
#: ../../ref/models/instances.txt:338
msgid ""
"If the old ``number_sold`` value retrieved from the database was 10, then "
"the value of 11 will be written back to the database."
msgstr ""
"Если старое значение ``number_sold``, полученное из базы данных, равно 10, в "
"базу данных будет записано значение 11."

# f558936c4c5a4cce8a4a5ed14bd6f9dc
#: ../../ref/models/instances.txt:341
msgid ""
"This sequence has a standard update problem in that it contains a race "
"condition. If another thread of execution has already saved an updated value "
"after the current thread retrieved the old value, the current thread will "
"only save the old value plus one, rather than the new (current) value plus "
"one."
msgstr ""
"Этот код отображает распространенную проблему \"гонки\". Если другой поток "
"сохранил обновленное значение после того, как текущий поток прочитал старое "
"значение, текущий поток сохранит просто старое значение плюс один, а не новое"
"(текущее) значение плюс один."

# d4ecdc8b5c9d4726bce0631972668fa7
#: ../../ref/models/instances.txt:346
msgid ""
"The process can be made robust and slightly faster by expressing the update "
"relative to the original field value, rather than as an explicit assignment "
"of a new value. Django provides :ref:`F() expressions <query-expressions>` "
"for performing this kind of relative update. Using ``F()`` expressions, the "
"previous example is expressed as::"
msgstr ""
"Этот процесс может быть надежным и немного быстрее, если выполнить "
"обновление значение поля, а не явное присвоение нового значения. Django "
"предоставляет :ref:`объект F() <query-expressions>` для выполнения "
"обновления. Используя ``F()``, следующий пример будет выглядеть таким "
"образом::"

# b8bcd00048d949af8374c8169c90d582
#: ../../ref/models/instances.txt:357
msgid ""
"This approach doesn't use the initial value from the database. Instead, it "
"makes the database do the update based on whatever value is current at the "
"time that the :meth:`~Model.save()` is executed."
msgstr ""
"Такой подход не использует начальное значение из базы данных. Вместо этого, "
"база данных выполнит обновление текущего значения при вызове метода :meth:"
"`~Model.save()`."

# 0a6dd6bd5ca042abad21f7a3d651f1ba
#: ../../ref/models/instances.txt:361
msgid ""
"Once the object has been saved, you must reload the object in order to "
"access the actual value that was applied to the updated field::"
msgstr ""
"Как только объект был сохранен, необходимо перезагрузить объект для доступа "
"к значению, которое было установлено при обновлении поля::"

# 243276e7f53b4e898cafe9c475d44fa8
#: ../../ref/models/instances.txt:368
msgid ""
"For more details, see the documentation on :ref:`F() expressions <query-"
"expressions>` and their :ref:`use in update queries <topics-db-queries-"
"update>`."
msgstr ""
"Подробности смотрите в описании :ref:`объекта F() <query-expressions>` и "
"его :ref:`использование в запросах обновления <topics-db-queries-update>`."

# cf9cce4cc6d648e397d828700475686a
#: ../../ref/models/instances.txt:373
msgid "Specifying which fields to save"
msgstr "Указываем какие поля сохранять"

# d44d33036cd24ff7a4e8f6a13cc28a44
#: ../../ref/models/instances.txt:377
msgid ""
"If ``save()`` is passed a list of field names in keyword argument "
"``update_fields``, only the fields named in that list will be updated. This "
"may be desirable if you want to update just one or a few fields on an "
"object. There will be a slight performance benefit from preventing all of "
"the model fields from being updated in the database. For example::"
msgstr ""
"Если в ``save()`` передать именованный аргумент ``update_fields`` со списком "
"полей модели, только эти поля будут обновлены. Это может пригодиться, если "
"вы хотите обновить одно или несколько полей. Таким образом можно получить "
"небольшой прирост в производительности. Например::"

# 1a08e6b87af34a76ad19581af20ed6bc
#: ../../ref/models/instances.txt:386
msgid ""
"The ``update_fields`` argument can be any iterable containing strings. An "
"empty ``update_fields`` iterable will skip the save. A value of None will "
"perform an update on all fields."
msgstr ""
"``update_fields`` может принимать любой итератор строк. Пустой "
"``update_fields`` пропустит сохранение. None сохранит все поля."

# 543907df97154c85a0766942aee3fddb
#: ../../ref/models/instances.txt:390
msgid "Specifying ``update_fields`` will force an update."
msgstr "Указав ``update_fields`` вы инициируете редактирование записи."

# 2aeecc4ffc9b43f5868ae4fd5ae12425
#: ../../ref/models/instances.txt:392
msgid ""
"When saving a model fetched through deferred model loading (:meth:`~django."
"db.models.query.QuerySet.only()` or :meth:`~django.db.models.query.QuerySet."
"defer()`) only the fields loaded from the DB will get updated. In effect "
"there is an automatic ``update_fields`` in this case. If you assign or "
"change any deferred field value, the field will be added to the updated "
"fields."
msgstr ""
"Если модель была загружена не со всеми полями (через :meth:`~django.db."
"models.query.QuerySet.only()` или :meth:`~django.db.models.query.QuerySet."
"defer()`), только загруженные поля будут сохранены. В этом случае "
"``update_fields`` будет определен автоматически. Если значение поля будет "
"изменено, оно будет добавлено в список для обновления."

# 5710063c94b64f6a9867bbff8de57716
#: ../../ref/models/instances.txt:400
msgid "Deleting objects"
msgstr "Удаление объектов"

# e7946ed560a34e83b2c99a904e4407cf
#: ../../ref/models/instances.txt:404
msgid ""
"Issues a SQL ``DELETE`` for the object. This only deletes the object in the "
"database; the Python instance will still exist and will still have data in "
"its fields."
msgstr ""
"Выполняет ``DELETE`` запрос для объекта. Удаляет объекты только из базы "
"данных; объекты Python будут существовать и содержать данные."

# 76bbf5d60a17460c98f0e01eaa8ecc3a
#: ../../ref/models/instances.txt:408
msgid ""
"For more details, including how to delete objects in bulk, see :ref:`topics-"
"db-queries-delete`."
msgstr ""
"Подробности, включая как удалить множество объектов, смотрите в :ref:`topics-"
"db-queries-delete`."

# 15b756b0ac7d48188d9957ab58daff95
#: ../../ref/models/instances.txt:411
msgid ""
"If you want customized deletion behavior, you can override the ``delete()`` "
"method. See :ref:`overriding-model-methods` for more details."
msgstr ""
"Если вам нужно изменить процесс удаления, переопределите метод ``delete()``. "
"Подробности в :ref:`overriding-model-methods`."

# 722e6dd3564f4c2a821c76ed276b03c9
#: ../../ref/models/instances.txt:417
msgid "Other model instance methods"
msgstr "Остальные методы модели"

# b485a9afc82343eeab9befa8696e54ac
#: ../../ref/models/instances.txt:419
msgid "A few object methods have special purposes."
msgstr "Несколько методов имеют специальное назначение."

# 77ddec81cdd4478dac1e8dcf53721767
#: ../../ref/models/instances.txt:422
msgid "``__unicode__``"
msgstr "``__unicode__``"

# 322fead3b40a4c5780afc817e7714563
#: ../../ref/models/instances.txt:426
msgid ""
"The ``__unicode__()`` method is called whenever you call ``unicode()`` on an "
"object. Django uses ``unicode(obj)`` (or the related function, :meth:`str"
"(obj) <Model.__str__>`) in a number of places. Most notably, to display an "
"object in the Django admin site and as the value inserted into a template "
"when it displays an object. Thus, you should always return a nice, human-"
"readable representation of the model from the ``__unicode__()`` method."
msgstr ""
"Метод ``__unicode__()`` вызывается когда вы применяете функцию ``unicode()`` "
"к объекту. Django использует ``unicode(obj)`` (или похожую функцию :meth:`str"
"(obj) <Model.__str__>`) вы нескольких местах. В частности, для отображения "
"объектов в интерфейсе администратора Django и в качестве значения, "
"вставляемого в шаблон, при отображении объекта. Поэтому, вы должны всегда "
"возвращать в методе ``__unicode__()`` красивое и удобное для восприятия "
"представление объекта."

# 5b4e92636d0f4db499d2704f36b4edfb
# f0f49d96bd0242a4bb39fa7a3a784269
#: ../../ref/models/instances.txt:433 ../../ref/models/instances.txt:479
#: ../../ref/models/instances.txt:488 ../../ref/models/instances.txt:632
msgid "For example::"
msgstr "Например::"

# 77610f5d55554d99963e837d02254090
#: ../../ref/models/instances.txt:442
msgid ""
"If you define a ``__unicode__()`` method on your model and not a :meth:"
"`~Model.__str__()` method, Django will automatically provide you with a :"
"meth:`~Model.__str__()` that calls ``__unicode__()`` and then converts the "
"result correctly to a UTF-8 encoded string object. This is recommended "
"development practice: define only ``__unicode__()`` and let Django take care "
"of the conversion to string objects when required."
msgstr ""
"Если вы определили метод ``__unicode__()`` и не определили :meth:`~Model."
"__str__()`, Django самостоятельно добавит метод :meth:`~Model.__str__()` "
"который вызывает ``__unicode__()``, затем преобразует результат в строку в "
"кодировке UTF-8. Это рекомендуемый подход: определить только ``__unicode__()"
"`` и позволить Django самостоятельно преобразовать в строку при "
"необходимости."

# 811e6bcf2367418bb7cdc15a31029b32
#: ../../ref/models/instances.txt:450
msgid "``__str__``"
msgstr "``__str__``"

# c1169ef193684b02a2f0ff7ea349c3bd
#: ../../ref/models/instances.txt:454
msgid ""
"The ``__str__()`` method is called whenever you call ``str()`` on an object. "
"The main use for this method directly inside Django is when the ``repr()`` "
"output of a model is displayed anywhere (for example, in debugging output). "
"Thus, you should return a nice, human-readable string for the object's "
"``__str__()``.  It isn't required to put ``__str__()`` methods everywhere if "
"you have sensible :meth:`~Model.__unicode__()` methods."
msgstr ""
"Метод ``__str__()`` вызывается, когда вы применяет функцию ``str()`` к "
"объекту. Django использует его если нужно вывести результат функции ``repr()"
"`` (например, при отладке). Поэтому, вы должны всегда возвращать в методе "
"``__str__()`` красивое и удобное для восприятия представление объекта. "
"Определять метод ``__str__()`` не обязательно, если вы определили метод :"
"meth:`~Model.__unicode__()`."

# 389315b6074e4b5ebd98d75cde5e3c31
#: ../../ref/models/instances.txt:458
msgid ""
"The previous :meth:`~Model.__unicode__()` example could be similarly written "
"using ``__str__()`` like this::"
msgstr ""
"Предыдущий пример метода :meth:`~Model.__unicode__()` может аналогично "
"использоваться и в ``__str__()``::"

# 7be347663638442f8bf2f6a99674af1d
#: ../../ref/models/instances.txt:471
msgid "``get_absolute_url``"
msgstr "``get_absolute_url``"

# 170be423e7b9487797847057de6377f5
#: ../../ref/models/instances.txt:475
msgid ""
"Define a ``get_absolute_url()`` method to tell Django how to calculate the "
"canonical URL for an object. To callers, this method should appear to return "
"a string that can be used to refer to the object over HTTP."
msgstr ""
"Определите метод ``get_absolute_url()`` что бы указать Django как вычислить "
"URL для объекта. Метод должен вернуть строку, которая может быть "
"использована в HTTP запросе."

# c2e13c9d8417413bac11402b7b71ad6d
#: ../../ref/models/instances.txt:484
msgid ""
"(Whilst this code is correct and simple, it may not be the most portable way "
"to write this kind of method. The :func:`~django.core.urlresolvers.reverse` "
"function is usually the best approach.)"
msgstr ""
"(Хотя это код правильный и простой, но такой подход не самый лучший для "
"создания подобных методов. Лучше использовать функцию :func:`~django.core."
"urlresolvers.reverse`.)"

# f01a31faf0bc4c679cb0db2cfa8b3b01
#: ../../ref/models/instances.txt:493
msgid ""
"One place Django uses ``get_absolute_url()`` is in the admin app. If an "
"object defines this method, the object-editing page will have a \"View on "
"site\" link that will jump you directly to the object's public view, as "
"given by ``get_absolute_url()``."
msgstr ""
"Django использует ``get_absolute_url()`` в интерфейсе администратора. Если "
"объект содержит этот метод, страница редактирования объекта будет содержать "
"ссылку \"Показать на сайте\", которая приведет к странице отображения "
"объекта, ссылку на которую возвращает ``get_absolute_url()``."

# f16957c12a9b4c5184b86620d3f85233
#: ../../ref/models/instances.txt:498
msgid ""
"Similarly, a couple of other bits of Django, such as the :doc:`syndication "
"feed framework </ref/contrib/syndication>`, use ``get_absolute_url()`` when "
"it is defined. If it makes sense for your model's instances to each have a "
"unique URL, you should define ``get_absolute_url()``."
msgstr ""
"Кроме того, несколько приложений Django так же используют этот метод, "
"например :doc:`syndication feed framework </ref/contrib/syndication>`. Если "
"объект модели представляет какой-то уникальный URL, вам стоит определить "
"метод ``get_absolute_url()``."

# c79820e1a3f049c6b2afbf034475175e
#: ../../ref/models/instances.txt:503
msgid ""
"It's good practice to use ``get_absolute_url()`` in templates, instead of "
"hard-coding your objects' URLs. For example, this template code is bad:"
msgstr ""
"Хорошая практика использовать ``get_absolute_url()`` в шаблонах, вместо того "
"что бы \"хард-кодить\" URL-ы. Например, это плохой подход:"

# 366627a9ab644c97b9436cbfe11008c1
#: ../../ref/models/instances.txt:511
msgid "This template code is much better:"
msgstr "Этот шаблон значительно лучше:"

# f6ba7b82b1be4413bd17195594598517
#: ../../ref/models/instances.txt:517
msgid ""
"The logic here is that if you change the URL structure of your objects, even "
"for something simple such as correcting a spelling error, you don't want to "
"have to track down every place that the URL might be created. Specify it "
"once, in ``get_absolute_url()`` and have all your other code call that one "
"place."
msgstr ""
"Идея в том что, если вы измените структуру URL-а для объекта, или просто "
"исправите опечатку, вам не нужно исправлять его во всех местах, где этот URL "
"используется. Просто определите его один раз в методе ``get_absolute_url()"
"``, и пусть остальной код использует его."

# 2b5c045aaa9a42faa0fac63212011858
#: ../../ref/models/instances.txt:523
msgid ""
"The string you return from ``get_absolute_url()`` **must** contain only "
"ASCII characters (required by the URI specfication, :rfc:`2396`) and be URL-"
"encoded, if necessary."
msgstr ""
"Строка, которую возвращает ``get_absolute_url()``, **должна** состоять "
"только из ASCII символов (требуется спецификацией URI, :rfc:`2396`) и быть "
"закодированной для URL, если необходимо."

# a2803a2645ed46faa1d84776eab4976a
#: ../../ref/models/instances.txt:527
msgid ""
"Code and templates calling ``get_absolute_url()`` should be able to use the "
"result directly without any further processing. You may wish to use the "
"``django.utils.encoding.iri_to_uri()`` function to help with this if you are "
"using unicode strings containing characters outside the ASCII range at all."
msgstr ""
"Код и шаблоны, использующие ``get_absolute_url()``, должны иметь возможность "
"использовать результат без обработки. Вы можете использовать функцию "
"``django.utils.encoding.iri_to_uri()``, если используете unicode-строку, "
"которая содержит не ASCII символы."

# 2543e14c1a644a1e8e41151dbeeab8ab
#: ../../ref/models/instances.txt:534
msgid "The ``permalink`` decorator"
msgstr "Декоратор ``permalink``"

# a0a6eae7bb9d4ef7a81fa0512c5fede1
#: ../../ref/models/instances.txt:538
msgid ""
"The ``permalink`` decorator is no longer recommended. You should use :func:"
"`~django.core.urlresolvers.reverse` in the body of your ``get_absolute_url`` "
"method instead."
msgstr ""
"Декоратор ``permalink`` больше не рекомендуется. Следует использовать :func:"
"`~django.core.urlresolvers.reverse` в методе ``get_absolute_url``."

# 0f2a9906c5454e6f8e5d462596a1630d
#: ../../ref/models/instances.txt:542
msgid ""
"In early versions of Django, there wasn't an easy way to use URLs defined in "
"URLconf file inside :meth:`~django.db.models.Model.get_absolute_url`. That "
"meant you would need to define the URL both in URLConf and :meth:`~django.db."
"models.Model.get_absolute_url`. The ``permalink`` decorator was added to "
"overcome this DRY principle violation. However, since the introduction of :"
"func:`~django.core.urlresolvers.reverse` there is no reason to use "
"``permalink`` any more."
msgstr ""
"В ранних версиях Django не было просто способа использовать URL определенный "
"в URLconf в методе :meth:`~django.db.models.Model.get_absolute_url`. Вам "
"приходилось определять URL и в URLConf и в :meth:`~django.db.models.Model."
"get_absolute_url`. Для соблюдения DRY принципа был добавлен декоратор "
"``permalink``. Но после представления функции :func:`~django.core."
"urlresolvers.reverse` отпала надобность в ``permalink``."

# 0de89d47f43f44d49c394757dba7a1cb
#: ../../ref/models/instances.txt:552
msgid ""
"This decorator takes the name of a URL pattern (either a view name or a URL "
"pattern name) and a list of position or keyword arguments and uses the "
"URLconf patterns to construct the correct, full URL. It returns a string for "
"the correct URL, with all parameters substituted in the correct positions."
msgstr ""
"Этот декоратор принимает названия шаблона URL (либо имя представления, либо "
"название шаблона URL) и список позиционных или именованных аргументов "
"шаблона URLconf для вычисления правильного и полного URL. Он возвращает "
"правильный URL, с учетом всех аргументов."

# daa122604922490fb98638f694970b68
#: ../../ref/models/instances.txt:557
msgid ""
"The ``permalink`` decorator is a Python-level equivalent to the :ttag:`url` "
"template tag and a high-level wrapper for the :func:`~django.core."
"urlresolvers.reverse` function."
msgstr ""
"Декоратор ``permalink`` это эквивалент шаблонного тега :ttag:`url` и обертка "
"для функции :func:`~django.core.urlresolvers.reverse`."

# 1655bcda94964ca3bf1dbeae206f18d7
#: ../../ref/models/instances.txt:561
msgid ""
"An example should make it clear how to use ``permalink()``. Suppose your "
"URLconf contains a line such as::"
msgstr ""
"Пример покажет как использовать ``permalink()``. Предположим у на есть такой "
"URLconf::"

# b7b893018cd1456b8026524b479956c1
#: ../../ref/models/instances.txt:566
msgid ""
"...your model could have a :meth:`~django.db.models.Model.get_absolute_url` "
"method that looked like this::"
msgstr ""
"...ваша модель может определить метод :meth:`~django.db.models.Model."
"get_absolute_url` таким образом::"

# 802da1e481af4c5082ad2fed6faeaae9
#: ../../ref/models/instances.txt:575
msgid "Similarly, if you had a URLconf entry that looked like::"
msgstr "Добавим еще одну строку в URLconf::"

# f6bc301e2a664f01ad133cd4048eb2db
#: ../../ref/models/instances.txt:579
msgid "...you could reference this using ``permalink()`` as follows::"
msgstr "...теперь ``permalink()`` можно использовать таким образом::"

# 12d9d11a392c4ece98b445b7838fcf84
#: ../../ref/models/instances.txt:588
msgid ""
"Notice that we specify an empty sequence for the second parameter in this "
"case, because we only want to pass keyword parameters, not positional ones."
msgstr ""
"Обратите внимание, мы указали пустую последовательность вторым параметром, "
"потому что хотим использовать только именованные аргументы."

# 316dfa73947d483685e17f74efb6264d
#: ../../ref/models/instances.txt:591
msgid ""
"In this way, you're associating the model's absolute path with the view that "
"is used to display it, without repeating the view's URL information "
"anywhere. You can still use the :meth:`~django.db.models.Model."
"get_absolute_url()` method in templates, as before."
msgstr ""
"Таким образом, мы связали абсолютный путь модели с представлением, которое "
"отображает ее, без повторного упоминания информации про URL. Вы можете "
"использовать метод :meth:`~django.db.models.Model.get_absolute_url()` в "
"шаблоне, как было показано выше."

# 57204706e08e4e6ca39b05f42d2dea98
#: ../../ref/models/instances.txt:596
msgid ""
"In some cases, such as the use of generic views or the re-use of custom "
"views for multiple models, specifying the view function may confuse the "
"reverse URL matcher (because multiple patterns point to the same view). For "
"that case, Django has :ref:`named URL patterns <naming-url-patterns>`. Using "
"a named URL pattern, it's possible to give a name to a pattern, and then "
"reference the name rather than the view function. A named URL pattern is "
"defined by replacing the pattern tuple by a call to the ``url`` function)::"
msgstr ""
"В некоторых случаях, таких, как использование общих представлений или "
"повторное использование представления для нескольких моделей, использование "
"представления может обескуражить определение URL (так как несколько шаблонов "
"используют одно представление). Для таких случаев, Django имеет :ref:"
"`именованные шаблоны URL <naming-url-patterns>`. При их использовании, можно "
"добавить название для шаблона URL, и использовать его вместо функции "
"представления при определении URL, именованные шаблоны URL определяются "
"заменой кортежа в URLconf на вызов функции ``url``)::"

# ee9251dfedba4df1bee846838c55e640
#: ../../ref/models/instances.txt:608
msgid ""
"...and then using that name to perform the reverse URL resolution instead of "
"the view name::"
msgstr ""
"...а затем использовать это название вместо названия функции представления "
"для вычисления URL::"

# cfc54b578d704da8b1de4d5c5351a237
#: ../../ref/models/instances.txt:617
msgid ""
"More details on named URL patterns are in the :doc:`URL dispatch "
"documentation </topics/http/urls>`."
msgstr ""
"Подробности вы можете узнать в разделе о :doc:`менеджере URL </topics/http/"
"urls>`."

# 453c15c6a8844c309a23b08f28369113
#: ../../ref/models/instances.txt:621
msgid "Extra instance methods"
msgstr "Дополнительные методы модели"

# cf5de768199043bc8999fe4610b43407
#: ../../ref/models/instances.txt:623
msgid ""
"In addition to :meth:`~Model.save()`, :meth:`~Model.delete()`, a model "
"object might have some of the following methods:"
msgstr ""
"В дополнение к методам :meth:`~Model.save()`, :meth:`~Model.delete()`, "
"объект модели может содержать некоторые из этих методов:"

# e0af5f91ae4a45bfa89adb4e84adaa04
#: ../../ref/models/instances.txt:628
msgid ""
"For every field that has :attr:`~django.db.models.Field.choices` set, the "
"object will have a ``get_FOO_display()`` method, where ``FOO`` is the name "
"of the field. This method returns the \"human-readable\" value of the field."
msgstr ""
"Для каждого поля, которое содержит :attr:`~django.db.models.Field.choices`, "
"объект будет иметь метод ``get_FOO_display()``, где ``FOO`` имя поля. Этот "
"метод возвращает удобное для восприятия название для значения поля."

# 29b4c3a7c4604d31883039917f636f41
#: ../../ref/models/instances.txt:657
msgid ""
"For every :class:`~django.db.models.DateField` and :class:`~django.db.models."
"DateTimeField` that does not have :attr:`null=True <django.db.models.Field."
"null>`, the object will have ``get_next_by_FOO()`` and ``get_previous_by_FOO"
"()`` methods, where ``FOO`` is the name of the field. This returns the next "
"and previous object with respect to the date field, raising a :exc:`~django."
"core.exceptions.DoesNotExist` exception when appropriate."
msgstr ""
"Для каждого поля :class:`~django.db.models.DateField` и :class:`~django.db."
"models.DateTimeField`, которое не содержит :attr:`null=True <django.db."
"models.Field.null>`, объект будет иметь методы ``get_next_by_FOO()`` и "
"``get_previous_by_FOO()``, где ``FOO`` название поля. Они возвращают "
"следующий и предыдущий объект в соответствии со значением этого поля, "
"вызывая соответствующее исключение :exc:`~django.db.DoesNotExist`, если "
"объект не существует."

# 806da9d072664e75a06d22615ab20138
#: ../../ref/models/instances.txt:664
msgid ""
"Both methods accept optional keyword arguments, which should be in the "
"format described in :ref:`Field lookups <field-lookups>`."
msgstr ""
"Оба метода принимают не обязательные именованные аргументы, которые должны "
"быть в формате описанном в разделе об :ref:`операциях фильтрации <field-"
"lookups>`."

# ee2b2e31cf7b488799a7efffc60e78a9
#: ../../ref/models/instances.txt:667
msgid ""
"Note that in the case of identical date values, these methods will use the "
"primary key as a tie-breaker. This guarantees that no records are skipped or "
"duplicated. That also means you cannot use those methods on unsaved objects."
msgstr ""
"Заметим, что в случае одинаковых значений даты, эти методы будут "
"использовать значение первичного ключа, для определения порядка объектов. "
"Это гарантирует, что записи не будут пропущены или дублированы. Это так же "
"означает, что вы не можете использовать эти методы для не сохраненных "
"объектов."

# ba18aee0c7da4eab844b716ea7779a0f
#~ msgid "Example::"
#~ msgstr "Например::"

# b1b78646f341486084aa97e70c0f5d6d
#~ msgid ""
#~ "The way we wrote ``get_absolute_url()`` above is a slightly violation of "
#~ "the DRY principle: the URL for this object is defined both in the URLconf "
#~ "file and in the model."
#~ msgstr ""
#~ "То, как мы написали метод ``get_absolute_url()``, немного нарушает "
#~ "принцип DRY: URL для объекта определяется и в URLconf, и в модели."

# 6654de20a4484ebdb2ef73cbedb9e69e
#~ msgid ""
#~ "You can decouple your models from the URLconf using the ``permalink`` "
#~ "decorator:"
#~ msgstr ""
#~ "Вы можете использовать определение URL из URLconf в вашей модели, "
#~ "используя декоратор ``permalink``:"

# 1dcb1fbfbcd94144ab4b08557dac8804
#~ msgid ""
#~ "...each ``Person`` instance will have a ``get_gender_display()`` method. "
#~ "Example::"
#~ msgstr ""
#~ "...каждый объект ``Person`` будет иметь метод ``get_gender_display()``. "
#~ "Например::"
