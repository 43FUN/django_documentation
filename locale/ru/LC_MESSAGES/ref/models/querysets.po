# Russian translations for Django package.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
# Automatically generated <>, 2012.
#
msgid ""
msgstr ""
"Project-Id-Version: Django 1.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2013-11-07 10:34\n"
"PO-Revision-Date: 2013-09-12 15:23+0300\n"
"Last-Translator: Dmitriy Kostochko <alerion.um@gmail.com>\n"
"Language-Team: none\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"

# a4ddc79d3d4240fbaf014357723dd45c
#: ../../ref/models/querysets.txt:3
msgid "QuerySet API reference"
msgstr "QuerySet API"

# 93dca2c82f0c42dc9c97bbfb3a7a319a
#: ../../ref/models/querysets.txt:7
msgid ""
"This document describes the details of the ``QuerySet`` API. It builds on "
"the material presented in the :doc:`model </topics/db/models>` and :doc:"
"`database query </topics/db/queries>` guides, so you'll probably want to "
"read and understand those documents before reading this one."
msgstr ""
"Этот раздел описывает ``QuerySet`` API. Изложенный материал опирается на "
"материал, изложенный в разделах о :doc:`моделях </topics/db/models>` и :doc:"
"`выполнении запросов </topics/db/queries>`, возможно вам следует прочитать "
"их перед прочтением этого раздела."

# f19e85b7e4874b628b1f97996cd04bd3
#: ../../ref/models/querysets.txt:12
msgid ""
"Throughout this reference we'll use the :ref:`example Weblog models "
"<queryset-model-example>` presented in the :doc:`database query guide </"
"topics/db/queries>`."
msgstr ""
"В примерах будут использованы :ref:` примеры моделей web-блога <queryset-"
"model-example>` представленные в разделе о :doc:`выполнении запросов </"
"topics/db/queries>`."

# ae28fbbf5a5c49d1ac0b40f966930aab
#: ../../ref/models/querysets.txt:19
msgid "When QuerySets are evaluated"
msgstr "Когда вычисляется QuerySets"

# 5dd5377703a945e4bcde2e5797e707bf
#: ../../ref/models/querysets.txt:21
msgid ""
"Internally, a ``QuerySet`` can be constructed, filtered, sliced, and "
"generally passed around without actually hitting the database. No database "
"activity actually occurs until you do something to evaluate the queryset."
msgstr ""
"``QuerySet`` может быть создан, отфильтрован, ограничен и использован "
"фактически без выполнения запросов к базе данных. База данных не будет "
"затронута, пока вы не спровоцируете выполнение QuerySet."

# ef3c207e9e724decb242d6fab6847a5c
#: ../../ref/models/querysets.txt:25
msgid "You can evaluate a ``QuerySet`` in the following ways:"
msgstr "``QuerySet`` будет вычислен при таких действиях:"

# e9bffa6ccc09496581d31d19a0e48c7c
#: ../../ref/models/querysets.txt:27
msgid ""
"**Iteration.** A ``QuerySet`` is iterable, and it executes its database "
"query the first time you iterate over it. For example, this will print the "
"headline of all entries in the database::"
msgstr ""
"**Итерация.** ``QuerySet`` -- это итератор, и при первом выполнении итерации "
"будет произведен запрос к базе данных. Например, этот код выводи заголовки "
"статей из базы данных::"

# 64e106da47db49398858e730d80ca97e
#: ../../ref/models/querysets.txt:34
msgid ""
"Note: Don't use this if all you want to do is determine if at least one "
"result exists. It's more efficient to use :meth:`~QuerySet.exists`."
msgstr ""
"Заметка: *не используйте* такой подходи, если необходимо всего лишь узнать "
"содержит ли результат запроса хотя бы один объект, и вам не нужен сам "
"результат. Эффективнее использовать метод :meth:`~QuerySet.exists`."

# ea019d80409d44c082b23bd353e993ae
#: ../../ref/models/querysets.txt:37
msgid ""
"**Slicing.** As explained in :ref:`limiting-querysets`, a ``QuerySet`` can "
"be sliced, using Python's array-slicing syntax. Slicing an unevaluated "
"``QuerySet`` usually returns another unevaluated ``QuerySet``, but Django "
"will execute the database query if you use the \"step\" parameter of slice "
"syntax, and will return a list. Slicing a ``QuerySet`` that has been "
"evaluated (partially or fully) also returns a list."
msgstr ""
"**Ограничение выборки.** Как описано в :ref:`limiting-querysets`, выборка "
"``QuerySet`` может быть ограничена, используя синтаксис срезов в Python. "
"Срез не вычисленного ``QuerySet`` обычно возвращает новый не вычисленный "
"``QuerySet``, но Django выполнит запрос, если будет указан шаг среза и "
"вернет список. Срез ``QuerySet``, который был вычислен(частично или "
"полностью), так же вернет список. "

# 99a34d84d70f4617ae3ff5339d628e09
#: ../../ref/models/querysets.txt:44
msgid ""
"**Pickling/Caching.** See the following section for details of what is "
"involved when `pickling QuerySets`_. The important thing for the purposes of "
"this section is that the results are read from the database."
msgstr ""
"**Pickling/кэширование.** Смотрите соответствующий раздел о `pickling "
"QuerySets`_. Основное замечание это то, что при этих операциях будет "
"выполнен запрос к базе данных."

# 872279b13af94aec98b1ca373cc0e01b
#: ../../ref/models/querysets.txt:48
msgid ""
"**repr().** A ``QuerySet`` is evaluated when you call ``repr()`` on it. This "
"is for convenience in the Python interactive interpreter, so you can "
"immediately see your results when using the API interactively."
msgstr ""
"**repr().** ``QuerySet`` будет вычислен при вызове ``repr()``. Это сделано "
"для удобства использования в консоли Python, вы можете сразу увидеть "
"результат работая с ``QuerySet`` в консоли."

# e36ca60edd4a42f8a1ae96714efea75f
#: ../../ref/models/querysets.txt:52
msgid ""
"**len().** A ``QuerySet`` is evaluated when you call ``len()`` on it. This, "
"as you might expect, returns the length of the result list."
msgstr ""
"**len().** ``QuerySet`` будет вычислен при выполнении ``len()`` над ним. Как "
"вы и ожидаете будет возвращено количество объектов в результате выборки."

# 4e7152e7b8a54da19602177972d20d79
#: ../../ref/models/querysets.txt:55
msgid ""
"Note: *Don't* use ``len()`` on ``QuerySet``\\s if all you want to do is "
"determine the number of records in the set. It's much more efficient to "
"handle a count at the database level, using SQL's ``SELECT COUNT(*)``, and "
"Django provides a ``count()`` method for precisely this reason. See ``count()"
"`` below."
msgstr ""
"Заметка: *Не используйте* ``len()`` с ``QuerySet`` если вам нужно узнать "
"только количество записей в выборке. Эффективнее использовать подсчет на "
"уровне базы данных, используя оператор SQL ``SELECT COUNT(*)``, и Django "
"предоставляет метод ``count()`` для этого. Смотрите ``count()`` ниже."

# f2ee6259dad84d99beaf8af8932b6442
#: ../../ref/models/querysets.txt:61
msgid ""
"**list().** Force evaluation of a ``QuerySet`` by calling ``list()`` on it. "
"For example::"
msgstr ""
"**list().** ``QuerySet`` будет вычислен при использовании ``list()`` над "
"ним. Например::"

# 0528f3a870d4462abb105f30ba474788
#: ../../ref/models/querysets.txt:66
msgid ""
"Be warned, though, that this could have a large memory overhead, because "
"Django will load each element of the list into memory. In contrast, "
"iterating over a ``QuerySet`` will take advantage of your database to load "
"data and instantiate objects only as you need them."
msgstr ""
"Будьте осторожны, так как при этом может быть использовано большое "
"количество памяти, т.к. Django загрузит каждый элемент списка в память. В "
"отличии от итерации по ``QuerySet``, при которой будут получены данные из "
"базы данных, но объекты будут созданы только при обращении к ним."

# 3e3a9035098f45a3a55134c68417686e
#: ../../ref/models/querysets.txt:71
msgid ""
"**bool().** Testing a ``QuerySet`` in a boolean context, such as using ``bool"
"()``, ``or``, ``and`` or an ``if`` statement, will cause the query to be "
"executed. If there is at least one result, the ``QuerySet`` is ``True``, "
"otherwise ``False``. For example::"
msgstr ""
"**bool().** При вычислении булевого значения ``QuerySet``, например "
"выполнении ``bool()``,  использовании с ``or``, ``and`` или ``if``. Если "
"``QuerySet`` содержит хотя бы один элемент, результат будет ``True``, иначе "
"-- ``False``. Например::"

# 64e106da47db49398858e730d80ca97e
#: ../../ref/models/querysets.txt:79
msgid ""
"Note: *Don't* use this if all you want to do is determine if at least one "
"result exists, and don't need the actual objects. It's more efficient to "
"use :meth:`~QuerySet.exists` (see below)."
msgstr ""
"Заметка: *не используйте* такой подходи, если необходимо всего лишь узнать "
"содержит ли результат запроса хотя бы один объект, и вам не нужен сам "
"результат. Эффективнее использовать метод :meth:`~QuerySet.exists` (смотрите "
"ниже)."

# 5b6bb2dcb2784b5cb020f75b74b30426
#: ../../ref/models/querysets.txt:86
msgid "Pickling QuerySets"
msgstr "Сериализация QuerySets"

# 0eed6a4a90c14a68ae30b17236be7a56
#: ../../ref/models/querysets.txt:88
msgid ""
"If you :mod:`pickle` a ``QuerySet``, this will force all the results to be "
"loaded into memory prior to pickling. Pickling is usually used as a "
"precursor to caching and when the cached queryset is reloaded, you want the "
"results to already be present and ready for use (reading from the database "
"can take some time, defeating the purpose of caching). This means that when "
"you unpickle a ``QuerySet``, it contains the results at the moment it was "
"pickled, rather than the results that are currently in the database."
msgstr ""
"Используя :mod:`pickle` для ``QuerySet``, будет выполнен запрос к базе "
"данных что бы загрузить данные в память для сериализации. Сериализация "
"обычно используется перед кэшированием ``QuerySet`` или загрузкой из кеша, "
"необходимо что бы результат был доступен для использования сразу после "
"загрузки (чтение с базы данных занимает некоторое время, что свело бы всю "
"пользу кэширования к нулю). Это означает что после восстановления "
"сериализованного ``QuerySet``, он будет содержать результат на момент "
"сериализации, а не тот, который хранится в базе данных на текущий момент."

# b306d47b2f0c4e4a89b8cc7e5977f198
#: ../../ref/models/querysets.txt:96
msgid ""
"If you only want to pickle the necessary information to recreate the "
"``QuerySet`` from the database at a later time, pickle the ``query`` "
"attribute of the ``QuerySet``. You can then recreate the original "
"``QuerySet`` (without any results loaded) using some code like this::"
msgstr ""
"Если вам необходимо сохранить запрос выполняемый ``QuerySet``, что бы "
"получить данные позже, сериализируйте атрибут ``query`` ``QuerySet``. Позже "
"вы можете воссоздать первоначальный ``QuerySet`` (без загрузки результата) "
"используя такой код::"

# a2e2110a529c4eaab208a5965f96bd47
#: ../../ref/models/querysets.txt:106
msgid ""
"The ``query`` attribute is an opaque object. It represents the internals of "
"the query construction and is not part of the public API. However, it is "
"safe (and fully supported) to pickle and unpickle the attribute's contents "
"as described here."
msgstr ""
"Атрибут ``query`` не является частью публичного API, и является частью "
"внутреннего механизма создания запросов. Однако, поддерживает использование "
"``pickle`` и ``unpickle`` как показано в примере выше."

# 5138d41bc219471096f24197c2187b31
#: ../../ref/models/querysets.txt:113
msgid ""
"Pickles of ``QuerySets`` are only valid for the version of Django that was "
"used to generate them. If you generate a pickle using Django version N, "
"there is no guarantee that pickle will be readable with Django version N+1. "
"Pickles should not be used as part of a long-term archival strategy."
msgstr ""
"Сериализация ``QuerySets`` возможна только для версии Django, которая была "
"использована при сохранении объекта. При сериализации объекта в версии "
"Django N, нет гарантии что, его можно будет восстановить в версии Django N"
"+1. Сериализация не должна быть использована для долговременного хранения "
"данных."

# 8908ae5fd52d421ca02f08f6bd313113
#: ../../ref/models/querysets.txt:122
msgid "QuerySet API"
msgstr "QuerySet API"

# e5857f02298d4e58bcdf7f6a439ff2c6
#: ../../ref/models/querysets.txt:124
msgid ""
"Though you usually won't create one manually — you'll go through a :class:"
"`~django.db.models.Manager` — here's the formal declaration of a "
"``QuerySet``:"
msgstr ""
"Хоть вам и не нужно создавать экземпляр ``QuerySet`` самостоятельно — он "
"создается через :class:`~django.db.models.Manager` — вот как это происходит:"

# 53e27b9c3de54a2fbd32c666d6c04e4d
#: ../../ref/models/querysets.txt:130
msgid ""
"Usually when you'll interact with a ``QuerySet`` you'll use it by :ref:"
"`chaining filters <chaining-filters>`. To make this work, most ``QuerySet`` "
"methods return new querysets. These methods are covered in detail later in "
"this section."
msgstr ""
"Обычно работа с ``QuerySet`` состоит в использовании :ref:`цепочек фильтров "
"<chaining-filters>`. Для этого большинство методов ``QuerySet`` возвращает "
"новый \"queryset\". Эти методы описаны далее."

# 018b3bc308034a708b2a93706cdd4981
#: ../../ref/models/querysets.txt:135
msgid ""
"The ``QuerySet`` class has two public attributes you can use for "
"introspection:"
msgstr "Класс ``QuerySet`` имеет два публичных атрибута:"

# 1158362f2a7041c090f146c7b5ce2225
#: ../../ref/models/querysets.txt:140
msgid ""
"``True`` if the ``QuerySet`` is ordered — i.e. has an :meth:`order_by()` "
"clause or a default ordering on the model. ``False`` otherwise."
msgstr ""
"``True`` если ``QuerySet`` использует сортировку — то есть использован "
"метод :meth:`order_by()` или модель содержит сортировку по-умолчанию. Иначе "
"``False``."

# d6fda43d8834411c9ce1bc9945085409
#: ../../ref/models/querysets.txt:146
msgid "The database that will be used if this query is executed now."
msgstr "База данных, которая будет использована для выполнения запроса."

# 8395b9df63654ec483d35040b7b08ab0
#: ../../ref/models/querysets.txt:150
msgid ""
"The ``query`` parameter to :class:`QuerySet` exists so that specialized "
"query subclasses such as :class:`~django.contrib.gis.db.models.GeoQuerySet` "
"can reconstruct internal query state. The value of the parameter is an "
"opaque representation of that query state and is not part of a public API. "
"To put it simply: if you need to ask, you don't need to use it."
msgstr ""
"Так же присутствует атрибут ``query`` класса :class:`QuerySet`. Подклассы :"
"class:`QuerySet`, такие как :class:`~django.contrib.gis.db.models."
"GeoQuerySet` могут переопределить структуру запроса используя этот аргумент. "
"Значение атрибута является скрытым представлением состояния запроса и не "
"является частью публичного API. Проще говоря, если вам нужно рассказывать о "
"нем, значит вам не стоит его использовать."

# cc754084a78646b4aed2e7a7dac0209e
#: ../../ref/models/querysets.txt:160
msgid "Methods that return new QuerySets"
msgstr "Методы, которые возвращают новый QuerySets"

# 8da92a93adba4090a21bda07d305cf9e
#: ../../ref/models/querysets.txt:162
msgid ""
"Django provides a range of ``QuerySet`` refinement methods that modify "
"either the types of results returned by the ``QuerySet`` or the way its SQL "
"query is executed."
msgstr ""
"Django предоставляет набор методов ``QuerySet``, которые изменяют "
"возвращаемый результат или выполнение SQL запроса."

# 19a92a74d013406e9d778a85e53da6a8
#: ../../ref/models/querysets.txt:167
msgid "filter"
msgstr "filter"

# 19caf98180104d82850aba702557d77d
#: ../../ref/models/querysets.txt:171
msgid ""
"Returns a new ``QuerySet`` containing objects that match the given lookup "
"parameters."
msgstr ""
"Возвращает новый ``QuerySet`` содержащий объекты отвечающие параметрам "
"фильтрации."

# 3c339c8df1204cfb9765ef08fa9589d9
#: ../../ref/models/querysets.txt:174
msgid ""
"The lookup parameters (``**kwargs``) should be in the format described in "
"`Field lookups`_ below. Multiple parameters are joined via ``AND`` in the "
"underlying SQL statement."
msgstr ""
"Параметры фильтрации (``**kwargs``) должны отвечать формату описанному в :"
"ref:`соответствующем разделе <field-lookups>`. Несколько параметров "
"объединяются оператором SQL ``AND``."

# 28aa203a3e1a435c96eb81c24c2e689c
#: ../../ref/models/querysets.txt:179
msgid "exclude"
msgstr "exclude"

# 5f4da46a6bdc421a8b7e893cd9da1d9b
#: ../../ref/models/querysets.txt:183
msgid ""
"Returns a new ``QuerySet`` containing objects that do *not* match the given "
"lookup parameters."
msgstr ""
"Возвращает новый ``QuerySet`` содержащий объекты *не* отвечающие параметрам "
"фильтрации."

# 6b1617a52446469eac978adbd18f4ead
#: ../../ref/models/querysets.txt:186
msgid ""
"The lookup parameters (``**kwargs``) should be in the format described in "
"`Field lookups`_ below. Multiple parameters are joined via ``AND`` in the "
"underlying SQL statement, and the whole thing is enclosed in a ``NOT()``."
msgstr ""
"Параметры фильтрации (``**kwargs``) должны отвечать формату описанному в :"
"ref:`соответствующем разделе <field-lookups>`. Несколько параметров "
"объединяются оператором SQL ``AND`` и все это замыкается оператором ``NOT()"
"``."

# 4cd38f0d4a4e4ed99da118a46297684f
#: ../../ref/models/querysets.txt:190
msgid ""
"This example excludes all entries whose ``pub_date`` is later than 2005-1-3 "
"AND whose ``headline`` is \"Hello\"::"
msgstr ""
"Этот пример исключает все записи с ``pub_date`` раньше 3.01.2005 И с "
"``headline`` равным \"Hello\"::"

# 89b7076d784e406bb11a99a9952fe728
# 0ad334998d0a41a7bb92d33376bc41eb
#: ../../ref/models/querysets.txt:195 ../../ref/models/querysets.txt:205
msgid "In SQL terms, that evaluates to::"
msgstr "Это эквивалентно запросу SQL::"

# 48b1915862b34bb89734a35d07fc6dc9
#: ../../ref/models/querysets.txt:200
msgid ""
"This example excludes all entries whose ``pub_date`` is later than 2005-1-3 "
"OR whose headline is \"Hello\"::"
msgstr ""
"Этот пример исключает все записи с ``pub_date``  раньше 3.01.2005 ИЛИ с "
"``headline`` равным \"Hello\"::"

# fef8b484158d43c09d30be0e0d5c42dd
#: ../../ref/models/querysets.txt:211
msgid "Note the second example is more restrictive."
msgstr ""
"Обратите внимание на второй пример, который больше ограничивает выборку."

# a2293c04f4024a0a9cb06fd346095b62
#: ../../ref/models/querysets.txt:214
msgid "annotate"
msgstr "annotate"

# 864b816187e342588c274fee7e4b1a21
#: ../../ref/models/querysets.txt:218
msgid ""
"Annotates each object in the ``QuerySet`` with the provided list of "
"aggregate values (averages, sums, etc) that have been computed over the "
"objects that are related to the objects in the ``QuerySet``. Each argument "
"to ``annotate()`` is an annotation that will be added to each object in the "
"``QuerySet`` that is returned."
msgstr ""
"\"Аннотирует\" каждый объект в ``QuerySet`` агрегированным значением "
"(среднее, суииа и др.), которое будет вычислено из данных связанных "
"объектов, которые связанны с объектами из``QuerySet``. Аргументы ``annotate()"
"`` это \"аннотация\", которая будет добавлена для каждого объекта "
"возвращаемого ``QuerySet``."

# 26a461f5b7274dc4a735bbb9fce4ba5a
# 4fe4f86b68b6440db1d38c51360ca1b7
#: ../../ref/models/querysets.txt:224 ../../ref/models/querysets.txt:1684
msgid ""
"The aggregation functions that are provided by Django are described in "
"`Aggregation Functions`_ below."
msgstr ""
"Функции агрегации описаны в :ref:`соответствующем разделе <aggregation-"
"functions>` ниже."

# 1294149d7e0f4999b399e546ea71cba2
#: ../../ref/models/querysets.txt:227
msgid ""
"Annotations specified using keyword arguments will use the keyword as the "
"alias for the annotation. Anonymous arguments will have an alias generated "
"for them based upon the name of the aggregate function and the model field "
"that is being aggregated."
msgstr ""
"Аннотация определенная именованными аргументами будет использовать имя "
"аргумента как название аннотации. Для позиционного аргумента будет "
"использовано имя созданное с названия функции агрегации и используемого поля "
"модели."

# bc4c877ba3e64badbbd94b6f46f45600
#: ../../ref/models/querysets.txt:232
msgid ""
"For example, if you were manipulating a list of blogs, you may want to "
"determine how many entries have been made in each blog::"
msgstr ""
"Например, получая список блогов, вы захотите получить так же и количество "
"записей в каждом блоге::"

# ccaaae1b195c44628f3315859b9bb718
#: ../../ref/models/querysets.txt:244
msgid ""
"The ``Blog`` model doesn't define an ``entry__count`` attribute by itself, "
"but by using a keyword argument to specify the aggregate function, you can "
"control the name of the annotation::"
msgstr ""
"Модель ``Blog`` не определяет атрибут ``entry__count``, используя "
"именованный аргументы вы можете переопределить название этого атрибута::"

# 06fa46ba1eb442a985458a09dd622220
# ab78c4ab8814417ba4e5cfdfb7472acc
#: ../../ref/models/querysets.txt:253 ../../ref/models/querysets.txt:1705
msgid ""
"For an in-depth discussion of aggregation, see :doc:`the topic guide on "
"Aggregation </topics/db/aggregation>`."
msgstr ""
"Для углубленного изучения агрегации смотрите :doc:`раздел про агрегацию </"
"topics/db/aggregation>`."

# 8389c0aa80de40d7823b3188341d69d1
#: ../../ref/models/querysets.txt:257
msgid "order_by"
msgstr "order_by"

# 4ce6382747e147e6b4c2c894014e9fdd
#: ../../ref/models/querysets.txt:261
msgid ""
"By default, results returned by a ``QuerySet`` are ordered by the ordering "
"tuple given by the ``ordering`` option in the model's ``Meta``. You can "
"override this on a per-``QuerySet`` basis by using the ``order_by`` method."
msgstr ""
"По-умолчанию, результат возвращаемый ``QuerySet``, отсортирован по полям "
"указанным в аргументе ``ordering`` класса ``Meta`` модели. Вы можете "
"переопределить сортировку используя метод ``order_by``."

# 9d69c8c34bb94cfb9f72158f427d9875
# 281b9774fa0d46529ee6c3c477956ff0
# bd3e7a153bd546bfa12e3e064720c459
# 7485308321904c3e86cc39e8910894cf
# a8749cbfd9144937b06db38a2f4ddbc1
# 4e7d2c4f218141e08e5318b264b7539d
# b66cc768e92f4b00854574e0f7a09126
# f684b5f11b1e4ce297dd1cbb0f927d5b
# 5216d8bec88c49baa9125fff2593910c
# 86cd4ddefdec4f10abdd2b4c12921b5c
# 90a5adbaedd94557b72e697a0a3902f7
# acc746828da84a32aec741c47c86164f
# 283c07c48d2b4ce4b00f12b3c1f0efd4
# eea33b1aeada471fbe719406b859dbb6
# 826d3125f3e54acebbcc86e452cdbe87
# cef75640dadb4cdab7865b789b2aed99
# 023748dbdf60440bac260fd3f787fe80
# 138ad121b8974c83997cf5ec1f4adadc
# 0382f09a65854e21892f5b81d95a1a53
# 6ae4ead3d03541bda278d48c33a12fdd
# cad7f2ad2c194100be061b225b5520ab
# 8436a2d96dbb4cf9a815ec6e24c1f0ba
# 5c2e58ba392c495cb905b93975f4f58f
# b2988e279ef34f8a8639ab324df8bc0e
# e033341134a04405a431b26b35ed31c1
#: ../../ref/models/querysets.txt:265 ../../ref/models/querysets.txt:468
#: ../../ref/models/querysets.txt:991 ../../ref/models/querysets.txt:1060
#: ../../ref/models/querysets.txt:1118 ../../ref/models/querysets.txt:1543
#: ../../ref/models/querysets.txt:1569 ../../ref/models/querysets.txt:1655
#: ../../ref/models/querysets.txt:1926 ../../ref/models/querysets.txt:1951
#: ../../ref/models/querysets.txt:1976 ../../ref/models/querysets.txt:1997
#: ../../ref/models/querysets.txt:2054 ../../ref/models/querysets.txt:2090
#: ../../ref/models/querysets.txt:2108 ../../ref/models/querysets.txt:2129
#: ../../ref/models/querysets.txt:2150 ../../ref/models/querysets.txt:2171
#: ../../ref/models/querysets.txt:2203 ../../ref/models/querysets.txt:2224
#: ../../ref/models/querysets.txt:2245 ../../ref/models/querysets.txt:2272
#: ../../ref/models/querysets.txt:2296 ../../ref/models/querysets.txt:2318
#: ../../ref/models/querysets.txt:2340 ../../ref/models/querysets.txt:2361
#: ../../ref/models/querysets.txt:2377 ../../ref/models/querysets.txt:2404
#: ../../ref/models/querysets.txt:2428
msgid "Example::"
msgstr "Например::"

# 388c881a8f9746d4ae76faba940c86d3
#: ../../ref/models/querysets.txt:269
msgid ""
"The result above will be ordered by ``pub_date`` descending, then by "
"``headline`` ascending. The negative sign in front of ``\"-pub_date\"`` "
"indicates *descending* order. Ascending order is implied. To order randomly, "
"use ``\"?\"``, like so::"
msgstr ""
"Результат выше будет отсортирован в обратном порядке по полю ``pub_date``, "
"далее по полю ``headline``. Знак \"минус\" в ``\"-pub_date\"`` указывает на "
"\"нисходящую\" сортировку. Сортировка по возрастанию подразумевается по-"
"умолчанию. Что бы отсортировать случайно используйте ``\"?\"``, например::"

# c941f625bb1945f18e21bfb4770ddf97
#: ../../ref/models/querysets.txt:276
msgid ""
"Note: ``order_by('?')`` queries may be expensive and slow, depending on the "
"database backend you're using."
msgstr ""
"Заметка: запрос с ``order_by('?')`` может быть медленным и сильно нагружать "
"базу данных, зависит от типа базы данных, которую вы используете."

# 0feb041843864550815406170d7b62c2
#: ../../ref/models/querysets.txt:279
msgid ""
"To order by a field in a different model, use the same syntax as when you "
"are querying across model relations. That is, the name of the field, "
"followed by a double underscore (``__``), followed by the name of the field "
"in the new model, and so on for as many models as you want to join. For "
"example::"
msgstr ""
"Для сортировки по полю из другой модели, используйте синтаксис аналогичный "
"тому, который используется при фильтрации по полям связанной модели. То "
"есть, название поля, далее два нижних подчеркивания (``__``), и имя поля в "
"новой модели, и так далее. Например::"

# ca5d43c386634e059a7d177dc4a37ca4
#: ../../ref/models/querysets.txt:286
msgid ""
"If you try to order by a field that is a relation to another model, Django "
"will use the default ordering on the related model (or order by the related "
"model's primary key if there is no :attr:`Meta.ordering <django.db.models."
"Options.ordering>` specified. For example::"
msgstr ""
"Если вы пытаетесь отсортировать по полю, которое является связью на другую "
"модель, Django будет использовать сортировку по-умолчанию связанной модели "
"(или же сортировку по первичному ключу связанной модели если :attr:`Meta."
"ordering <django.db.models.Options.ordering>` не указан). Например::"

# 1e58dbcf06c84eeba4053165e5509788
#: ../../ref/models/querysets.txt:293
msgid "...is identical to::"
msgstr "...идентично::"

# de174d006189426bb977b1724a79c2b4
#: ../../ref/models/querysets.txt:297
msgid "...since the ``Blog`` model has no default ordering specified."
msgstr "...т.к. модель ``Blog`` не содержит сортировки по-умолчанию."

# 0b0c59c51c0841ac9e6768b430ecd9ee
#: ../../ref/models/querysets.txt:299
msgid ""
"Be cautious when ordering by fields in related models if you are also using :"
"meth:`distinct()`. See the note in :meth:`distinct` for an explanation of "
"how related model ordering can change the expected results."
msgstr ""
"Будьте осторожны используя по полю из связанной модели и метод :meth:"
"`distinct()`. Смотрите описание метода :meth:`distinct` для информации как "
"сортировка по связанной модели может повлиять на ожидаемый результат."

# 7f1e286972b14790a8a82298dbc01f1c
#: ../../ref/models/querysets.txt:304
msgid ""
"It is permissible to specify a multi-valued field to order the results by "
"(for example, a :class:`~django.db.models.ManyToManyField` field, or the "
"reverse relation of a :class:`~django.db.models.ForeignKey` field)."
msgstr ""
"Можно использовать поля с множеством значений для фильтрации результатов "
"(например, поле :class:`~django.db.models.ManyToManyField`, или обратную "
"связь для поля :class:`~django.db.models.ForeignKey`)."

# 35465e7b81454c2e9e1e6418666353d8
#: ../../ref/models/querysets.txt:308
msgid "Consider this case::"
msgstr "Возьмем такой код::"

# 2c6e7c1632fd45b7bed7894360261b8b
#: ../../ref/models/querysets.txt:316
msgid ""
"Here, there could potentially be multiple ordering data for each ``Event``; "
"each ``Event`` with multiple ``children`` will be returned multiple times "
"into the new ``QuerySet`` that ``order_by()`` creates. In other words, using "
"``order_by()`` on the ``QuerySet`` could return more items than you were "
"working on to begin with - which is probably neither expected nor useful."
msgstr ""
"В таком случае может быть несколько значений указывающих парядок для объекта "
"``Event``. ``Event`` с несколькими ``children`` будет возвращен несколько "
"раз в ``QuerySet`` созданном ``order_by()``. Другими словами, использование "
"``order_by()`` больше объектов чем вы изначальном ``QuerySet``."

# 46269e7ffaf74797bfa27edbab392ba7
#: ../../ref/models/querysets.txt:323
msgid ""
"Thus, take care when using multi-valued field to order the results. **If** "
"you can be sure that there will only be one ordering piece of data for each "
"of the items you're ordering, this approach should not present problems. If "
"not, make sure the results are what you expect."
msgstr ""
"Будьте внимательны, когда используете поля с множеством значений для "
"сортировки. **Если** вы уверенны, что существует только одно значение для "
"объекта определяющее порядок сортировки, у вас не должно быть проблем. Иначе "
"убедитесь что полученый результат - это то, что вам нужно."

# dcef496eed3240d8b7da2df94461eddb
#: ../../ref/models/querysets.txt:328
msgid ""
"There's no way to specify whether ordering should be case sensitive. With "
"respect to case-sensitivity, Django will order results however your database "
"backend normally orders them."
msgstr ""
"Нет способа указать должна ли сортировка учитывать регистр. По этому Django "
"возвращает результат в таком порядке, в каком его вернула используемая база "
"данных."

# d072c96416f2478aa9c3ef185dc17d86
#: ../../ref/models/querysets.txt:332
msgid ""
"If you don't want any ordering to be applied to a query, not even the "
"default ordering, call :meth:`order_by()` with no parameters."
msgstr ""
"Если вы не хотите использовать сортировку, даже указанную по-умолчанию, "
"выполните метод :meth:`order_by()` без аргументов."

# 4272697bbb1f4191ac30eb51e396b2b1
#: ../../ref/models/querysets.txt:335
msgid ""
"You can tell if a query is ordered or not by checking the :attr:`.QuerySet."
"ordered` attribute, which will be ``True`` if the ``QuerySet`` has been "
"ordered in any way."
msgstr ""
"Вы можете определить используется сортировка или нет проверив атрибут :attr:"
"`.QuerySet.ordered`, который будет равен ``True``, если сортировка была "
"применена для ``QuerySet`` каким-либо образом."

# ab3d940be09f46aca7d5c324fa3b7a02
#: ../../ref/models/querysets.txt:341
msgid ""
"Ordering is not a free operation. Each field you add to the ordering incurs "
"a cost to your database. Each foreign key you add will implicitly include "
"all of its default orderings as well."
msgstr ""

# 7d4492b3420a46a3ba839688362008f5
#: ../../ref/models/querysets.txt:346
msgid "reverse"
msgstr "reverse"

# db69345ef8f94265988237ef355b596c
#: ../../ref/models/querysets.txt:350
msgid ""
"Use the ``reverse()`` method to reverse the order in which a queryset's "
"elements are returned. Calling ``reverse()`` a second time restores the "
"ordering back to the normal direction."
msgstr ""
"Используйте метод ``reverse()`` что бы изменить порядок сортировки на "
"обратный. Вызов ``reverse()`` повторно восстановит изначальную сортировку."

# 62d776aa895846de9f16c2f531915fe5
#: ../../ref/models/querysets.txt:354
msgid "To retrieve the \"last\" five items in a queryset, you could do this::"
msgstr "Что бы получить \"последние\" пять объектов выполните::"

# 55474eae90b641b8937651614d331aa1
#: ../../ref/models/querysets.txt:358
msgid ""
"Note that this is not quite the same as slicing from the end of a sequence "
"in Python. The above example will return the last item first, then the "
"penultimate item and so on. If we had a Python sequence and looked at ``seq"
"[-5:]``, we would see the fifth-last item first. Django doesn't support that "
"mode of access (slicing from the end), because it's not possible to do it "
"efficiently in SQL."
msgstr ""
"Обратите внимание, что это не совсем аналог среза Python с конца. Этот "
"пример вернет сначала последний элемент, потом предпоследний и так далее. "
"Используя список Python и сделав срез ``seq[-5:]``, мы увидим пятый элемент "
"с конца первым. Django не поддерживает подобное (срез с конца), т.к. нет "
"способа интерпретировать это в эфективный SQL."

# 1a84791f3be9472b8ccb5dbf8582be18
#: ../../ref/models/querysets.txt:365
msgid ""
"Also, note that ``reverse()`` should generally only be called on a "
"``QuerySet`` which has a defined ordering (e.g., when querying against a "
"model which defines a default ordering, or when using :meth:`order_by()`). "
"If no such ordering is defined for a given ``QuerySet``, calling ``reverse()"
"`` on it has no real effect (the ordering was undefined prior to calling "
"``reverse()``, and will remain undefined afterward)."
msgstr ""
"Метод ``reverse()`` должен быть вызван для ``QuerySet`` с определенной "
"сортировкой (например, при запросе модели с сортировкой по-умолчанию или "
"после использования метода :meth:`order_by()`). Если сортировка не "
"определена , вызов ``reverse()`` не будет иметь никакого эффекта."

# 57e6d48e5bd743858191f3211a9d3569
#: ../../ref/models/querysets.txt:373
msgid "distinct"
msgstr "distinct"

# f780c96158b04c1080f955a673f86a88
#: ../../ref/models/querysets.txt:377
msgid ""
"Returns a new ``QuerySet`` that uses ``SELECT DISTINCT`` in its SQL query. "
"This eliminates duplicate rows from the query results."
msgstr ""
"Возвращает ``QuerySet`` с добавленным ``SELECT DISTINCT`` в SQL запрос.  "
"Повторяющиеся записи будут исключены из результатов запроса."

# 72d0db17e03a42fcae1ab2c942ccd8d7
#: ../../ref/models/querysets.txt:380
msgid ""
"By default, a ``QuerySet`` will not eliminate duplicate rows. In practice, "
"this is rarely a problem, because simple queries such as ``Blog.objects.all()"
"`` don't introduce the possibility of duplicate result rows. However, if "
"your query spans multiple tables, it's possible to get duplicate results "
"when a ``QuerySet`` is evaluated. That's when you'd use ``distinct()``."
msgstr ""
"По-умолчанию, ``QuerySet`` не исключает повторяющиеся записи. На практике, "
"это редко является проблемой, простые запросы вроде ``Blog.objects.all()`` "
"не создают повторяющиеся записи. Однако, если запрос использует несколько "
"таблиц, возможно что ``QuerySet`` вернет повторяющиеся записи. И здесь вам "
"пригодится ``distinct()``."

# 85c89befa0194d3a905a5addc20971b9
#: ../../ref/models/querysets.txt:387
msgid ""
"Any fields used in an :meth:`order_by` call are included in the SQL "
"``SELECT`` columns. This can sometimes lead to unexpected results when used "
"in conjunction with ``distinct()``. If you order by fields from a related "
"model, those fields will be added to the selected columns and they may make "
"otherwise duplicate rows appear to be distinct. Since the extra columns "
"don't appear in the returned results (they are only there to support "
"ordering), it sometimes looks like non-distinct results are being returned."
msgstr ""
"Любое поле используемое в :meth:`order_by` будет добавлено в список "
"выбираемых колонок в части ``SELECT`` SQL запроса. Это может привести к "
"непредвиденным результатам если вы используете ``distinct()``. При "
"сортировке по колонке из связанной таблицы, эти колонки будет включены в "
"список выбираемых колонок, что может сделать одинаковые строки результата "
"уникальными. Т.к. эти дополнительные колонки не будет включены в результат"
"(они используются только для определения сортировки), будет выглядеть так, "
"вроде бы ``distinct()`` возвращает не уникальные элементы результатов."

# 27904ac42d8f4813ba4c11520f61cf48
#: ../../ref/models/querysets.txt:395
msgid ""
"Similarly, if you use a :meth:`values()` query to restrict the columns "
"selected, the columns used in any :meth:`order_by()` (or default model "
"ordering) will still be involved and may affect uniqueness of the results."
msgstr ""
"Так же, если вы используете метод :meth:`values()` что бы ограничить "
"выбираемые поля, поля из :meth:`order_by()` (или сортировки по-умолчанию "
"модели) так же будут включены и могут повлиять на уникальность результатов."

# b6960fd26547439c90f298d3376f6055
#: ../../ref/models/querysets.txt:399
msgid ""
"The moral here is that if you are using ``distinct()`` be careful about "
"ordering by related models. Similarly, when using ``distinct()`` and :meth:"
"`values()` together, be careful when ordering by fields not in the :meth:"
"`values()` call."
msgstr ""
"Мораль всего этого -- будьте осторожны при использовании ``distinct()`` и "
"сортировки по полям из связанных моделей. Так же, при использовании "
"``distinct()`` и :meth:`values()` вместе, будьте осторожны сортируя по полям "
"не включенным в :meth:`values()`."

# 34765e81d5274c3f8b717f2d80f1ffbb
#: ../../ref/models/querysets.txt:404
#, fuzzy
msgid ""
"On PostgreSQL only, you can pass positional arguments (``*fields``) in order "
"to specify the names of fields to which the ``DISTINCT`` should apply. This "
"translates to a ``SELECT DISTINCT ON`` SQL query. Here's the difference. For "
"a normal ``distinct()`` call, the database compares *each* field in each row "
"when determining which rows are distinct. For a ``distinct()`` call with "
"specified field names, the database will only compare the specified field "
"names."
msgstr ""
"Вот в чем разница. При обычном вызове ``distinct()``, база данных сравнивает "
"*каждое* поле каждой строки для определения уникальности записи. При "
"передаче полей в ``distinct()``, база данных будет сравнивать только "
"указанные поля."

# 9eb9408232844162b66ce5cef3025bc0
#: ../../ref/models/querysets.txt:412
msgid ""
"When you specify field names, you *must* provide an ``order_by()`` in the "
"``QuerySet``, and the fields in ``order_by()`` must start with the fields in "
"``distinct()``, in the same order."
msgstr ""
"Если вы указываете поля, вы *должны* определить так же и ``order_by()`` для "
"``QuerySet``, и поля в ``order_by()`` должны начинаться с полей указанных в "
"``distinct()``, в том же порядке."

# 468448fbce544d7c9d8fbea48c3d1025
#: ../../ref/models/querysets.txt:416
msgid ""
"For example, ``SELECT DISTINCT ON (a)`` gives you the first row for each "
"value in column ``a``. If you don't specify an order, you'll get some "
"arbitrary row."
msgstr ""
"Например, ``SELECT DISTINCT ON (a)`` возвращает вам первую запись для "
"каждого уникального значения колонки ``a``. Если вы не определите "
"сортировку, будут возвращены случайные записи для каждого уникального "
"значения."

# fde9c3fdeaee4e41ae6134df439fbd1a
#: ../../ref/models/querysets.txt:420
msgid "Examples (those after the first will only work on PostgreSQL)::"
msgstr ""

# af5851511053417684d907a9326d9023
#: ../../ref/models/querysets.txt:441
msgid "values"
msgstr "values"

# 49fb7386a28047a38968129991eba91f
#: ../../ref/models/querysets.txt:445
msgid ""
"Returns a ``ValuesQuerySet`` — a ``QuerySet`` subclass that returns "
"dictionaries when used as an iterable, rather than model-instance objects."
msgstr ""
"Возвращает ``ValuesQuerySet`` — подкласс ``QuerySet``, который возвращает "
"словари с результатом вместо объектов моделей."

# cb5947d3cddb4e288c8bcaf10bd28e35
#: ../../ref/models/querysets.txt:448
msgid ""
"Each of those dictionaries represents an object, with the keys corresponding "
"to the attribute names of model objects."
msgstr ""
"Каждый словарь представляет объект, ключи которого соответствуют полям "
"модели."

# ac94864efe7e413881125d12d960d3f1
#: ../../ref/models/querysets.txt:451
msgid ""
"This example compares the dictionaries of ``values()`` with the normal model "
"objects::"
msgstr ""
"Этот пример показывает разницу между результатом возвращаемым ``values()`` и "
"объектами модели::"

# 6a895173a763438790f5974f0d8306a9
#: ../../ref/models/querysets.txt:462
msgid ""
"The ``values()`` method takes optional positional arguments, ``*fields``, "
"which specify field names to which the ``SELECT`` should be limited. If you "
"specify the fields, each dictionary will contain only the field keys/values "
"for the fields you specify. If you don't specify the fields, each dictionary "
"will contain a key and value for every field in the database table."
msgstr ""
"Метод ``values()`` принимает дополнительные позиционные аргументы, "
"``*fields``, которые определяют какие поля будут получены через ``SELECT``. "
"Каждый словарь будет содержать только указанные поля. Если поля не указаны, "
"каждый словарь будет содержать все данные из таблицы в базе данных."

# e78f74bf322a45fbb3d7aadac36bf87a
#: ../../ref/models/querysets.txt:475
msgid "A few subtleties that are worth mentioning:"
msgstr "Следует упомянуть несколько тонкостей:"

# e4db51fd4b5e405383e764d1d9ea1047
#: ../../ref/models/querysets.txt:477
msgid ""
"If you have a field called ``foo`` that is a :class:`~django.db.models."
"ForeignKey`, the default ``values()`` call will return a dictionary key "
"called ``foo_id``, since this is the name of the hidden model attribute that "
"stores the actual value (the ``foo`` attribute refers to the related model). "
"When you are calling ``values()`` and passing in field names, you can pass "
"in either ``foo`` or ``foo_id`` and you will get back the same thing (the "
"dictionary key will match the field name you passed in)."
msgstr ""
"Если модель содержит поле ``foo`` типа :class:`~django.db.models."
"ForeignKey`, по-умолчанию ``values()`` вернет словарь с ключом ``foo_id``, т."
"к. это названия скрытого поля, которое на самом деле хранит значение "
"(атрибут ``foo`` отображает связанную модель). Вызывая ``values()`` вы "
"можете передать ``foo`` или ``foo_id`` и получите тот же результат (ключ "
"словаря будет равен переданному значению)."

# 3103ac6bd6f34454baf5fc60b4160233
# c5738a85fd984c2fa84d5a69a91a2452
# d9dec8adfce64fdcb8581558ebfde631
# c1089638b0ad4386bd46c32864e5fcac
#: ../../ref/models/querysets.txt:486 ../../ref/models/querysets.txt:1099
#: ../../ref/models/querysets.txt:1276 ../../ref/models/querysets.txt:1292
msgid "For example::"
msgstr "Например::"

# 51b23e8160934f9c82dda9f6b81f91a3
#: ../../ref/models/querysets.txt:497
msgid ""
"When using ``values()`` together with :meth:`distinct()`, be aware that "
"ordering can affect the results. See the note in :meth:`distinct` for "
"details."
msgstr ""
"Используя ``values()`` с :meth:`distinct()`, обратите внимание, что "
"сортировка может повлиять на результат. Подробности в описании метода :meth:"
"`distinct`."

# 1708b68a0b5d4d5b870cc5907d019f08
#: ../../ref/models/querysets.txt:501
msgid ""
"If you use a ``values()`` clause after an :meth:`extra()` call, any fields "
"defined by a ``select`` argument in the :meth:`extra()` must be explicitly "
"included in the ``values()`` call. Any :meth:`extra()` call made after a "
"``values()`` call will have its extra selected fields ignored."
msgstr ""
"Используя ``values()`` после вызова :meth:`extra()`, добавьте в ``values()`` "
"все поля указанные в аргументе ``select`` использованном при вызове :meth:"
"`extra()`. При вызове :meth:`extra()` после ``values()`` все указанные "
"дополнительные поля будут проигнорированы."

# 1015bea283fc4547a2248e39469a320e
#: ../../ref/models/querysets.txt:507
msgid ""
"A ``ValuesQuerySet`` is useful when you know you're only going to need "
"values from a small number of the available fields and you won't need the "
"functionality of a model instance object. It's more efficient to select only "
"the fields you need to use."
msgstr ""
"``ValuesQuerySet`` полезен, если вам нужны только данные некоторых полей и "
"не нужен функционал объектов моделей. Более эффективно получить только "
"необходимые данные."

# e0be586998f34c22a49475475a9f6309
#: ../../ref/models/querysets.txt:512
msgid ""
"Finally, note a ``ValuesQuerySet`` is a subclass of ``QuerySet``, so it has "
"all methods of ``QuerySet``. You can call ``filter()`` on it, or ``order_by()"
"``, or whatever. Yes, that means these two calls are identical::"
msgstr ""
"Заметим, что ``ValuesQuerySet`` подкласс ``QuerySet``, и содержит все методы "
"``QuerySet``. Вы можете вызвать ``filter()`` или ``order_by()``, или любой "
"другой метод. Это означает, что эти два куска кода идентичны::"

# d65a646eb811447a9b6958db3e21d60b
#: ../../ref/models/querysets.txt:519
msgid ""
"The people who made Django prefer to put all the SQL-affecting methods "
"first, followed (optionally) by any output-affecting methods (such as "
"``values()``), but it doesn't really matter. This is your chance to really "
"flaunt your individualism."
msgstr ""
"Разработчики Django предпочитают использовать в первую очередь методы "
"влияющие на SQL-запрос, далее методы влияющие на вывод данных (такие как "
"``values()``), хотя это и не имеет значения. Это ваш шанс проявить "
"индивидуальность."

# f5eb1490873243d494cb93a58ebf85e9
#: ../../ref/models/querysets.txt:524
msgid ""
"You can also refer to fields on related models with reverse relations "
"through ``OneToOneField``, ``ForeignKey`` and ``ManyToManyField`` "
"attributes::"
msgstr ""
"Вы также можете обратиться к обратно связанным моделям через поля "
"``OneToOneField``, ``ForeignKey`` и ``ManyToManyField``::"

# 7557f8612db24cc198d2c6484189d537
#: ../../ref/models/querysets.txt:533
msgid ""
"Because :class:`~django.db.models.ManyToManyField` attributes and reverse "
"relations can have multiple related rows, including these can have a "
"multiplier effect on the size of your result set. This will be especially "
"pronounced if you include multiple such fields in your ``values()`` query, "
"in which case all possible combinations will be returned."
msgstr ""
"Так как :class:`~django.db.models.ManyToManyField` и обратная связь может "
"содержать множество связанных записей, выбор этих данных может многократно "
"увеличить размер возвращаемых данных. Это будет особенно заметно, если вы "
"включите несколько таких полей в ``values()``, в таком случае будут "
"возвращены все возможные комбинации значений."

# 579aab5752cb438d80b3c2f226e36cb8
#: ../../ref/models/querysets.txt:540
msgid "values_list"
msgstr "values_list"

# 97303ab27631499da3fc7e3e9328ecf6
#: ../../ref/models/querysets.txt:544
msgid ""
"This is similar to ``values()`` except that instead of returning "
"dictionaries, it returns tuples when iterated over. Each tuple contains the "
"value from the respective field passed into the ``values_list()`` call — so "
"the first item is the first field, etc. For example::"
msgstr ""
"Аналогичен ``values()``, но вместо словаря возвращает кортеж. Каждый кортеж "
"содержит значения полей указанных при вызове ``values_list()`` в том же "
"порядке — первый элемент значение первого поля и т.д. Например::"

# ccb1350a9f4141cfa5cad5c849fdb5d5
#: ../../ref/models/querysets.txt:552
msgid ""
"If you only pass in a single field, you can also pass in the ``flat`` "
"parameter. If ``True``, this will mean the returned results are single "
"values, rather than one-tuples. An example should make the difference "
"clearer::"
msgstr ""
"Если вы указали одно поле, можете указать аргумент ``flat``. При ``True``, "
"каждая запись будет возвращена как отдельное значение, а не одноэлементный "
"кортеж. Например::"

# 0b0afc3c5ba6418da21a36cf1b7de005
#: ../../ref/models/querysets.txt:562
msgid "It is an error to pass in ``flat`` when there is more than one field."
msgstr ""
"Если вы указали больше одного поля, использование ``flat`` будет ошибкой."

# a90ae6bd840642f39a79a2a6b105be21
#: ../../ref/models/querysets.txt:564
msgid ""
"If you don't pass any values to ``values_list()``, it will return all the "
"fields in the model, in the order they were declared."
msgstr ""
"Если поля не будут указаны при вызове ``values_list()``, будут возвращены "
"все поля модели в порядке, в котором они были объявлены."

# b0ad5e5c848348dea33d1f14a680895d
#: ../../ref/models/querysets.txt:567
msgid ""
"Note that this method returns a ``ValuesListQuerySet``. This class behaves "
"like a list. Most of the time this is enough, but if you require an actual "
"Python list object, you can simply call ``list()`` on it, which will "
"evaluate the queryset."
msgstr ""

# 357b1daa9bcd4dea9ec83499a76f89d3
#: ../../ref/models/querysets.txt:573
msgid "dates"
msgstr "dates"

# 39c9d32ce13e4247960fb10a992f4943
#: ../../ref/models/querysets.txt:577
#, fuzzy
msgid ""
"Returns a ``DateQuerySet`` — a ``QuerySet`` that evaluates to a list of :"
"class:`datetime.date` objects representing all available dates of a "
"particular kind within the contents of the ``QuerySet``."
msgstr ""
"Возвращает ``DateQuerySet`` — ``QuerySet`` возвращающий список объектов "
"``datetime.datetime`` отображающих возможные даты в контексте ``QuerySet``."

# 4c676dfb14b54e969e866cc4eb76811d
#: ../../ref/models/querysets.txt:585
#, fuzzy
msgid "``field`` should be the name of a ``DateField`` of your model."
msgstr ""
"``field`` -- название поля модели типа ``DateField`` или ``DateTimeField``."

# 7a8b45479ff14c29a5adbde580e97125
#: ../../ref/models/querysets.txt:591
#, fuzzy
msgid ""
"``kind`` should be either ``\"year\"``, ``\"month\"`` or ``\"day\"``. Each "
"``datetime.date`` object in the result list is \"truncated\" to the given "
"``type``."
msgstr ""
"``kind`` должен быть ``\"year\"``, ``\"month\"`` или ``\"day\"``. Каждый "
"объект ``datetime.datetime`` - результат \"урезания\" данных в соответствии "
"с указанным ``type``."

# af481c348edd403dbe26e806860a8cc2
#: ../../ref/models/querysets.txt:595
msgid "``\"year\"`` returns a list of all distinct year values for the field."
msgstr ""
"``\"year\"`` возвращает список уникальных значений года из всех дат "
"указанного поля."

# 4045d630ba0d47af887dd450631e3549
#: ../../ref/models/querysets.txt:596
msgid ""
"``\"month\"`` returns a list of all distinct year/month values for the field."
msgstr ""
"``\"month\"`` возвращает список уникальных значений года/месяца из всех дат "
"указанного поля."

# b3c5624dc54c4b8fa4ba0682ea138ef7
#: ../../ref/models/querysets.txt:598
msgid ""
"``\"day\"`` returns a list of all distinct year/month/day values for the "
"field."
msgstr ""
"``\"day\"`` возвращает список уникальных значений года/месяца/дня из всех "
"дат указанного поля."

# 500c765dc01140819e5dd68e8ac42e59
#: ../../ref/models/querysets.txt:601 ../../ref/models/querysets.txt:634
msgid ""
"``order``, which defaults to ``'ASC'``, should be either ``'ASC'`` or "
"``'DESC'``. This specifies how to order the results."
msgstr ""
"``order`` -- сортировка значений. По-умолчанию``'ASC'``, должна быть  "
"``'ASC'`` или ``'DESC'``."

# 12ffb7971cd54ddb86243f6be88eba97
# a1594fb3f3764aa29bb1251fe9792b80
# 23387ea901374de5b1c31ae9b2f22556
# b327b9678e274966b4d91cac79c5d6e1
#: ../../ref/models/querysets.txt:604 ../../ref/models/querysets.txt:672
#: ../../ref/models/querysets.txt:1900
msgid "Examples::"
msgstr "Например::"

# 357b1daa9bcd4dea9ec83499a76f89d3
#: ../../ref/models/querysets.txt:618
#, fuzzy
msgid "datetimes"
msgstr "dates"

# 39c9d32ce13e4247960fb10a992f4943
#: ../../ref/models/querysets.txt:624
#, fuzzy
msgid ""
"Returns a ``DateTimeQuerySet`` — a ``QuerySet`` that evaluates to a list of :"
"class:`datetime.datetime` objects representing all available dates of a "
"particular kind within the contents of the ``QuerySet``."
msgstr ""
"Возвращает ``DateQuerySet`` — ``QuerySet`` возвращающий список объектов "
"``datetime.datetime`` отображающих возможные даты в контексте ``QuerySet``."

# 4c676dfb14b54e969e866cc4eb76811d
#: ../../ref/models/querysets.txt:628
#, fuzzy
msgid "``field`` should be the name of a ``DateTimeField`` of your model."
msgstr ""
"``field`` -- название поля модели типа ``DateField`` или ``DateTimeField``."

# 7a8b45479ff14c29a5adbde580e97125
#: ../../ref/models/querysets.txt:630
#, fuzzy
msgid ""
"``kind`` should be either ``\"year\"``, ``\"month\"``, ``\"day\"``, ``\"hour"
"\"``, ``\"minute\"`` or ``\"second\"``. Each ``datetime.datetime`` object in "
"the result list is \"truncated\" to the given ``type``."
msgstr ""
"``kind`` должен быть ``\"year\"``, ``\"month\"`` или ``\"day\"``. Каждый "
"объект ``datetime.datetime`` результат \"урезания\" данных в соответствии с "
"указанным ``kind``."

# bc9e881a6bbb4af09f0793ed6b9a89b2
#: ../../ref/models/querysets.txt:637
msgid ""
"``tzinfo`` defines the time zone to which datetimes are converted prior to "
"truncation. Indeed, a given datetime has different representations depending "
"on the time zone in use. This parameter must be a :class:`datetime.tzinfo` "
"object. If it's ``None``, Django uses the :ref:`current time zone <default-"
"current-time-zone>`. It has no effect when :setting:`USE_TZ` is ``False``."
msgstr ""

# 57e651fbcf294534a031ebfb87a6cd60
#: ../../ref/models/querysets.txt:648
msgid ""
"This function performs time zone conversions directly in the database. As a "
"consequence, your database must be able to interpret the value of ``tzinfo."
"tzname(None)``. This translates into the following requirements:"
msgstr ""

# c02286dfc0714cb79386449c1a4f59fe
#: ../../ref/models/querysets.txt:652
msgid "SQLite: install pytz_ — conversions are actually performed in Python."
msgstr ""

# 4729dc1f08964e7f95223516a0acb706
#: ../../ref/models/querysets.txt:653
msgid "PostgreSQL: no requirements (see `Time Zones`_)."
msgstr ""

# 7620300112df42548672eaf4b476ca92
#: ../../ref/models/querysets.txt:654
msgid "Oracle: no requirements (see `Choosing a Time Zone File`_)."
msgstr ""

# ee76f7ef2af5491dbfd763b2d4cdd593
#: ../../ref/models/querysets.txt:655
msgid ""
"MySQL: install pytz_ and load the time zone tables with "
"`mysql_tzinfo_to_sql`_."
msgstr ""

# 11d5eb8529f54db2a837985ac116e865
#: ../../ref/models/querysets.txt:664
msgid "none"
msgstr "none"

# 51b96358f163485ab9441693642e9d23
#: ../../ref/models/querysets.txt:668
msgid ""
"Calling none() will create a queryset that never returns any objects and no "
"query will be executed when accessing the results. A qs.none() queryset is "
"an instance of ``EmptyQuerySet``."
msgstr ""

# a2890d41c32d43eb9432fc98eb1227b8
#: ../../ref/models/querysets.txt:681
msgid "all"
msgstr "all"

# 572293992d5a4f12b4507aaa97e801e3
#: ../../ref/models/querysets.txt:685
msgid ""
"Returns a *copy* of the current ``QuerySet`` (or ``QuerySet`` subclass).  "
"This can be useful in situations where you might want to pass in either a "
"model manager or a ``QuerySet`` and do further filtering on the result. "
"After calling ``all()`` on either object, you'll definitely have a "
"``QuerySet`` to work with."
msgstr ""
"Возвращает *копию* текущего ``QuerySet`` (или подкласса ``QuerySet``).  Это "
"может быть полезно, если вам нужно передать в функцию менеджер модели или "
"``QuerySet`` и выполнить дальнейшую фильтрацию результата. После вызова ``all"
"()`` вы получите копию ``QuerySet``, которую можно передать в функцию не "
"боясь, что она изменит текущий ``QuerySet``."

# c49b527e87f04a66adda31c1a3327a74
#: ../../ref/models/querysets.txt:691
msgid "select_related"
msgstr "select_related"

# 2dbb0260148b4133baccddfbf37f18eb
#: ../../ref/models/querysets.txt:695
msgid ""
"Returns a ``QuerySet`` that will automatically \"follow\" foreign-key "
"relationships, selecting that additional related-object data when it "
"executes its query. This is a performance booster which results in "
"(sometimes much) larger queries but means later use of foreign-key "
"relationships won't require database queries."
msgstr ""
"Возвращает ``QuerySet`` который автоматически включает в выборку данные "
"связанных объектов при выполнении запроса. Повышает производительность, но "
"увеличивает(иногда значительно) объем получаемых данных, в результате, при "
"доступе к связанным объектам через модель, не потребуются дополнительные "
"запросы в базу данных."

# f4caa3922bd7491d99841d4199f56b42
#: ../../ref/models/querysets.txt:701
msgid ""
"The following examples illustrate the difference between plain lookups and "
"``select_related()`` lookups. Here's standard lookup::"
msgstr ""
"Этот пример отображает разницу между обычной выборкой и с ``select_related()"
"``. Обычная выборка::"

# b563008653c34aee865d8f3f69ed0969
#: ../../ref/models/querysets.txt:710
msgid "And here's ``select_related`` lookup::"
msgstr "И с ``select_related``::"

# e3f6354104e0493a9a828ef9334fdeea
#: ../../ref/models/querysets.txt:719
msgid ""
"``select_related()`` follows foreign keys as far as possible. If you have "
"the following models::"
msgstr ""
"``select_related()`` выбирает связанные объекты максимально доступной "
"вложенности. Например, у нас есть такие модели::"

# 26ababe5af374ddab78c493810a3d259
#: ../../ref/models/querysets.txt:736
msgid ""
"...then a call to ``Book.objects.select_related().get(id=4)`` will cache the "
"related ``Person`` *and* the related ``City``::"
msgstr ""
"...тогда вызов ``Book.objects.select_related().get(id=4)`` получит данные "
"связанных ``Person`` *и* связанных ``City``::"

# c42207566e5848fea57f695f19c1ce3c
#: ../../ref/models/querysets.txt:747
msgid ""
"Note that, by default, ``select_related()`` does not follow foreign keys "
"that have ``null=True``."
msgstr ""
"Заметим, по-умолчанию ``select_related()`` не учитывает внешние ключи с "
"``null=True``."

# 1f46130a9ade4bb688f2110f4ee5aa5c
#: ../../ref/models/querysets.txt:750
msgid ""
"Usually, using ``select_related()`` can vastly improve performance because "
"your app can avoid many database calls. However, there are times you are "
"only interested in specific related models, or have deeply nested sets of "
"relationships, and in these cases ``select_related()`` can be optimized by "
"explicitly passing the related field names you are interested in. Only the "
"specified relations will be followed."
msgstr ""
"Обычно, использование ``select_related()`` может значительно увеличить "
"производительность т.к. ваше приложение не будет выполнять дополнительные "
"запросы при доступе к связанным объектам. Однако, в случае глубокой "
"вложенности связанных объектов, ``select_related()`` может привести к "
"\"обработке\" слишком большого количества связей, и создаст в конечном итоге "
"сложный и значительно медленный запрос. Вы можете передать названия внешних "
"ключей, которые следует обрабатывать."

# 79ff5ffc434c4030ab8a94299c91e338
#: ../../ref/models/querysets.txt:757
msgid ""
"You can even do this for models that are more than one relation away by "
"separating the field names with double underscores, just as for filters. For "
"example, if you have this model::"
msgstr ""
"Вы можете определять связанные модели любой вложенности, разделяя имена "
"внешних ключей двойным нижним подчеркиванием. Например, у вас есть модель::"

# ec74245305334c98ab756c026129189b
#: ../../ref/models/querysets.txt:771
msgid ""
"...and you only needed to work with the ``room`` and ``subject`` attributes, "
"you could write this::"
msgstr "...и вам нужны только  ``room`` и ``subject``::"

# 6e7d6366f5524863bcfd865a431a0256
#: ../../ref/models/querysets.txt:776
msgid "This is also valid::"
msgstr "Так же можно::"

# 840699198ee1475c9ffdf250ab771ac7
#: ../../ref/models/querysets.txt:780
msgid "...and would also pull in the ``building`` relation."
msgstr "...в результате будет так же использована связь ``building``."

# 62befa03faea415d880cf52741f205fe
#: ../../ref/models/querysets.txt:782
msgid ""
"You can refer to any :class:`~django.db.models.ForeignKey` or :class:"
"`~django.db.models.OneToOneField` relation in the list of fields passed to "
"``select_related()``. This includes foreign keys that have ``null=True`` "
"(which are omitted in a no-parameter ``select_related()`` call). It's an "
"error to use both a list of fields and the ``depth`` parameter in the same "
"``select_related()`` call; they are conflicting options."
msgstr ""
"Можно указать любые :class:`~django.db.models.ForeignKey` или :class:"
"`~django.db.models.OneToOneField` связи при вызове ``select_related()``. "
"Принимаются только внешние ключи с ``null=True`` (которые будет использова "
"ны при вызове ``select_related()`` без аргументов). Нельзя использовать "
"аргумент ``depth`` и список полей вместе, эти параметры несовместимы."

# f0695e8976554521ad36bd94ee905e2b
#: ../../ref/models/querysets.txt:789
msgid ""
"You can also refer to the reverse direction of a :class:`~django.db.models."
"OneToOneField` in the list of fields passed to ``select_related`` — that is, "
"you can traverse a :class:`~django.db.models.OneToOneField` back to the "
"object on which the field is defined. Instead of specifying the field name, "
"use the :attr:`related_name <django.db.models.ForeignKey.related_name>` for "
"the field on the related object."
msgstr ""
"Вы можете указать обратную связь для :class:`~django.db.models."
"OneToOneField` в списке полей — то есть, вы можете получить объект в котором "
"определено поле :class:`~django.db.models.OneToOneField`. Вместо названия "
"поля используйте значение параметра :attr:`related_name <django.db.models."
"ForeignKey.related_name>`."

# 5782a17c48c4436e999a91a12322d796
#: ../../ref/models/querysets.txt:798
msgid ""
"If you need to clear the list of related fields added by past calls of "
"``select_related`` on a ``QuerySet``, you can pass ``None`` as a parameter::"
msgstr ""

# 13743d5ec15143f898643c04641f1dee
#: ../../ref/models/querysets.txt:808
msgid "A depth limit of relationships to follow can also be specified::"
msgstr "Глубину следования связям можно указать следующим образом::"

# 0cd784213a2c4dafad8091eada5a4bc7
#: ../../ref/models/querysets.txt:814
msgid ""
"A :class:`~django.db.models.OneToOneField` is not traversed in the reverse "
"direction if you are performing a depth-based ``select_related()`` call."
msgstr ""
"Обратная связь для :class:`~django.db.models.OneToOneField` не учитывается "
"при вызове ``select_related()``, если она явно не указана в аргументах."

# c88e911f60014854a17560028894701a
#: ../../ref/models/querysets.txt:818
msgid "prefetch_related"
msgstr "prefetch_related"

# 549d0360b83f45e5b22af301ab7d707c
#: ../../ref/models/querysets.txt:822
msgid ""
"Returns a ``QuerySet`` that will automatically retrieve, in a single batch, "
"related objects for each of the specified lookups."
msgstr ""
"Возвращает ``QuerySet``, который получает \"за один подход\" связанные "
"объекты для каждого из указанных параметра поиска."

# 9f0ccc75a72444f0afeb9cd747791de4
#: ../../ref/models/querysets.txt:825
msgid ""
"This has a similar purpose to ``select_related``, in that both are designed "
"to stop the deluge of database queries that is caused by accessing related "
"objects, but the strategy is quite different."
msgstr ""
"Смысл такой же как и у ``select_related``, избежать нарастающего количества "
"запросов при обращении к связанным объектам, но смысл работы немного другой."

# 9c1bd26fc3c1409caeb9d73b158aec1a
#: ../../ref/models/querysets.txt:829
#, fuzzy
msgid ""
"``select_related`` works by creating an SQL join and including the fields of "
"the related object in the ``SELECT`` statement. For this reason, "
"``select_related`` gets the related objects in the same database query. "
"However, to avoid the much larger result set that would result from joining "
"across a 'many' relationship, ``select_related`` is limited to single-valued "
"relationships - foreign key and one-to-one."
msgstr ""
"``select_related`` создает запрос SQL объединяющий связанные таблицы и "
"включая дополнительные поля в SELECT. По этой причине, ``select_related`` "
"получает связанные объекты в том же запросе. Однако, что бы избежать "
"большого количества возвращаемых данных при обработке \"множественных\" "
"связей, ``select_related`` работает только со связями возвращающими один "
"объект - внешний ключ и связь один-к-одному."

# d3ca3301d5f04a74adc64b849150dec0
#: ../../ref/models/querysets.txt:836
msgid ""
"``prefetch_related``, on the other hand, does a separate lookup for each "
"relationship, and does the 'joining' in Python. This allows it to prefetch "
"many-to-many and many-to-one objects, which cannot be done using "
"``select_related``, in addition to the foreign key and one-to-one "
"relationships that are supported by ``select_related``. It also supports "
"prefetching of :class:`~django.contrib.contenttypes.generic.GenericRelation` "
"and :class:`~django.contrib.contenttypes.generic.GenericForeignKey`."
msgstr ""
"``prefetch_related``, с другой стороны, выбирает данные для каждой связи "
"отдельно, и выполняет \"объединение\" на уровне Python. Благодаря этому "
"могут быть обработаны связи многое-ко-многим и многое-к-одному, которые не "
"обрабатывает ``select_related``, в том числе и внешние ключи и связь один-к-"
"одному поддерживаемые ``select_related``. Так же поддерживается "
"предварительная выборка для :class:`~django.contrib.contenttypes.generic."
"GenericRelation` и :class:`~django.contrib.contenttypes.generic."
"GenericForeignKey`."

# 008a1928e12d487aa0ede700f59f8cb2
#: ../../ref/models/querysets.txt:844
msgid "For example, suppose you have these models::"
msgstr "Например, у вас есть две модели::"

# 35465e7b81454c2e9e1e6418666353d8
#: ../../ref/models/querysets.txt:860
msgid "and run::"
msgstr "и выполняется такой код::"

# 753863380a5a47199cd6d3d853437c53
#: ../../ref/models/querysets.txt:865
msgid ""
"The problem with this is that every time ``Pizza.__unicode__()`` asks for "
"``self.toppings.all()`` it has to query the database, so ``Pizza.objects.all"
"()`` will run a query on the Toppings table for **every** item in the Pizza "
"``QuerySet``."
msgstr ""
"Проблема в том, что ``Pizza.__unicode__()`` вызывая ``self.toppings.all()`` "
"выполняет запрос к базе данных, и ``Pizza.objects.all()`` выполнит запрос к "
"таблице Toppings для **каждого** объекта Pizza в ``QuerySet``."

# e439e97e543849a98b81a06423129015
#: ../../ref/models/querysets.txt:870
msgid "We can reduce to just two queries using ``prefetch_related``:"
msgstr ""
"Мы можем уменьшить количество запросов до двух используя "
"``prefetch_related``:"

# bd6f5c62f9cf477caa6b78b79d31b29b
#: ../../ref/models/querysets.txt:874
msgid ""
"This implies a ``self.toppings.all()`` for each ``Pizza``; now each time "
"``self.toppings.all()`` is called, instead of having to go to the database "
"for the items, it will find them in a prefetched ``QuerySet`` cache that was "
"populated in a single query."
msgstr ""
"В этом случае ``self.toppings.all()`` подгружается для каждого объекта "
"``Pizza`` и при вызове ``self.toppings.all()`` будут использоватсья "
"подгруженные данные, вместо запроса к БД."

# 4d10c7e6aa5f4733bcee31330f527481
#: ../../ref/models/querysets.txt:879
msgid ""
"That is, all the relevant toppings will have been fetched in a single query, "
"and used to make ``QuerySets`` that have a pre-filled cache of the relevant "
"results; these ``QuerySets`` are then used in the ``self.toppings.all()`` "
"calls."
msgstr ""
"Все соответствующие начинки(toppings) будут получены одним запросом, что бы "
"создать ``QuerySets``, который имеет предварительно заполненный кэш "
"соответствующих результатов. Этот ``QuerySets`` будет использован при вызове "
"``self.toppings.all()``."

# 57fb4b4edc2448c78f79f7a26f560ec0
#: ../../ref/models/querysets.txt:883
msgid ""
"The additional queries in ``prefetch_related()`` are executed after the "
"``QuerySet`` has begun to be evaluated and the primary query has been "
"executed."
msgstr ""
"Запрос для загрузки данных указанных в ``prefetch_related()`` будет выполнен "
"после выполнения основного запроса."

# 10fa255f68f044dbb2e14e867da74c51
#: ../../ref/models/querysets.txt:886
msgid ""
"Note that the result cache of the primary ``QuerySet`` and all specified "
"related objects will then be fully loaded into memory. This changes the "
"typical behavior of ``QuerySets``, which normally try to avoid loading all "
"objects into memory before they are needed, even after a query has been "
"executed in the database."
msgstr ""
"Обратите внимание, что будет \"закеширован\" также результат выполнения "
"основного ``QuerySet``, а также будут загружены все связанные объекты. Это "
"отличается от стандратного поведения ``QuerySets``, при котором Django "
"старается не загружать связанные данные как можно дольше."

# 3a4a1d81d12140e09e5217ecdbe41461
#: ../../ref/models/querysets.txt:894
msgid ""
"Remember that, as always with ``QuerySets``, any subsequent chained methods "
"which imply a different database query will ignore previously cached "
"results, and retrieve data using a fresh database query. So, if you write "
"the following:"
msgstr ""
"Помните, для всех ``QuerySets`` любой последующий метод, который изменяет "
"запрос, проигнорирует ранее загруженный кэш и получит данные выполнив новый "
"запрос. Итак, используя такой код:"

# cc5a38e36ca249b498d95ff562f0a09b
#: ../../ref/models/querysets.txt:902
msgid ""
"...then the fact that ``pizza.toppings.all()`` has been prefetched will not "
"help you. The ``prefetch_related('toppings')`` implied ``pizza.toppings.all()"
"``, but ``pizza.toppings.filter()`` is a new and different query. The "
"prefetched cache can't help here; in fact it hurts performance, since you "
"have done a database query that you haven't used. So use this feature with "
"caution!"
msgstr ""
"...тот факт, что ``pizza.toppings.all()`` предварительно загружает данные, "
"не поможет вам. ``prefetch_related('toppings')`` применяется к ``pizza."
"toppings.all()``, а ``pizza.toppings.filter()`` совершенно другой запрос. "
"Загруженный кеш не будет использоваться и будут выполнены дополнительные "
"запросы. Пользуйтесь этим методом осторожно!"

# 30ec294f1d1b45ef9d561c09d8fbebe9
#: ../../ref/models/querysets.txt:909
msgid ""
"You can also use the normal join syntax to do related fields of related "
"fields. Suppose we have an additional model to the example above::"
msgstr ""
"Вы можете использовать стандартный синтаксис для обращения к связанным "
"моделям. Например, добавим еще одну модель в пример выше::"

# aa3de7da48e74729858e02c95fdab3ed
#: ../../ref/models/querysets.txt:916
msgid "The following are all legal:"
msgstr "Можно использовать такой запрос:"

# 0765ed76370c4aac8b32b94a346d58d1
#: ../../ref/models/querysets.txt:920
msgid ""
"This will prefetch all pizzas belonging to restaurants, and all toppings "
"belonging to those pizzas. This will result in a total of 3 database queries "
"- one for the restaurants, one for the pizzas, and one for the toppings."
msgstr ""
"Этот запрос выполнит предварительную загрузку всех пицц(Pizza) для ресторанов"
"(Restaurant) и всех ингредиентов(Topping) для пицц. В результате будет "
"выполнено 3 запроса - один для Restaurant, один для Pizza, и один для "
"Topping."

# 1bc723b8cd1e47a69ebf5503049d2624
#: ../../ref/models/querysets.txt:926
msgid ""
"This will fetch the best pizza and all the toppings for the best pizza for "
"each restaurant. This will be done in 3 database queries - one for the "
"restaurants, one for the 'best pizzas', and one for one for the toppings."
msgstr ""
"Это вернет \"best pizza\" и все \"toppings\" для них для каждого ресторана. "
"Будет выполнено 3 запроса."

# 233b470234a044dea1c1a4dc463043f8
#: ../../ref/models/querysets.txt:930
msgid ""
"Of course, the ``best_pizza`` relationship could also be fetched using "
"``select_related`` to reduce the query count to 2:"
msgstr ""
"Конечно, связь ``best_pizza`` может быть получена через ``select_related`` "
"что бы уменьшить количество запросов до двух:"

# deae4b56bee74a058123faf94d41f183
#: ../../ref/models/querysets.txt:935
msgid ""
"Since the prefetch is executed after the main query (which includes the "
"joins needed by ``select_related``), it is able to detect that the "
"``best_pizza`` objects have already been fetched, and it will skip fetching "
"them again."
msgstr ""
"Так как предварительная загрузка выполняется после основного запроса "
"(который включает все необходимые объединения таблиц для обработки "
"``select_related``), она способна определить что объекты ``best_pizza`` уже "
"получены и не выполнит их загрузку снова."

# 89590e17c2a44ebd8b013ceaf3c4d642
#: ../../ref/models/querysets.txt:939
msgid ""
"Chaining ``prefetch_related`` calls will accumulate the lookups that are "
"prefetched. To clear any ``prefetch_related`` behavior, pass `None` as a "
"parameter::"
msgstr ""
"Использование нескольких вызовов ``prefetch_related`` соберет вместе все "
"предварительно загружаемые поля. Что бы из обнулить вызовите метод "
"``prefetch_related`` с аргументом `None`::"

# 46a774303a8e4a7fa40a14a9936f9a7b
#: ../../ref/models/querysets.txt:945
msgid ""
"One difference to note when using ``prefetch_related`` is that objects "
"created by a query can be shared between the different objects that they are "
"related to i.e. a single Python model instance can appear at more than one "
"point in the tree of objects that are returned. This will normally happen "
"with foreign key relationships. Typically this behavior will not be a "
"problem, and will in fact save both memory and CPU time."
msgstr ""
"Одна особенность вызова ``prefetch_related``, про которую следует упомянуть, "
"объекты созданные в результате выполнения запроса могут быть использованы "
"различными связанными объектами, то есть один экземпляр модели может "
"оказаться более чем в одной точке в дереве возвращенных объектов. Это обычно "
"случается с внешними ключами. Скорее всего это не вызовет никаких проблем, и "
"даже сохранит память и время CPU."

# 0224fa29d695415f9fb9841e6691546c
#: ../../ref/models/querysets.txt:952
msgid ""
"While ``prefetch_related`` supports prefetching ``GenericForeignKey`` "
"relationships, the number of queries will depend on the data. Since a "
"``GenericForeignKey`` can reference data in multiple tables, one query per "
"table referenced is needed, rather than one query for all the items. There "
"could be additional queries on the ``ContentType`` table if the relevant "
"rows have not already been fetched."
msgstr ""
"Так как ``prefetch_related`` поддерживает предварительную загрузку "
"``GenericForeignKey``, количество запросов зависит от данных. Так как "
"``GenericForeignKey`` может ссылаться на данные из разных таблиц, необходим "
"один запрос на одну таблицу, вместо одного запроса для всех данных. Так же "
"может понадобится дополнительный запрос к таблице ``ContentType`` если "
"соответствующие данные еще не загружены."

# 3738fd126f124d05a43e190ffd4e7d1c
#: ../../ref/models/querysets.txt:959
#, fuzzy
msgid ""
"``prefetch_related`` in most cases will be implemented using an SQL query "
"that uses the 'IN' operator. This means that for a large ``QuerySet`` a "
"large 'IN' clause could be generated, which, depending on the database, "
"might have performance problems of its own when it comes to parsing or "
"executing the SQL query. Always profile for your use case!"
msgstr ""
"``prefetch_related`` в основном использует оператор `IN` SQL запроса. Это "
"означает, что для больших QuerySet может быть создано сложное условие 'IN', "
"что, в зависимости от базы данных, может привести к проблемам с "
"производительностью при разборе и выполнении SQL запроса. Всегда анализируйте"
"(profile) ваш запрос!"

# fb07b22e96bf4735aab0e4f4ebac9843
#: ../../ref/models/querysets.txt:965
msgid ""
"Note that if you use ``iterator()`` to run the query, ``prefetch_related()`` "
"calls will be ignored since these two optimizations do not make sense "
"together."
msgstr ""
"Заметим, если вы используете ``iterator()`` для выполнения запроса, вызов "
"``prefetch_related()`` будет проигнорирован т.к. использование этих двух "
"оптимизаций вместе не имеет смысла."

# 3de60b9d93e9467288b16597a3aeafd4
#: ../../ref/models/querysets.txt:969
msgid "extra"
msgstr "extra"

# d259661cdd444f0e8c4d38c129301258
#: ../../ref/models/querysets.txt:973
msgid ""
"Sometimes, the Django query syntax by itself can't easily express a complex "
"``WHERE`` clause. For these edge cases, Django provides the ``extra()`` "
"``QuerySet`` modifier — a hook for injecting specific clauses into the SQL "
"generated by a ``QuerySet``."
msgstr ""
"Иногда, стандартных возможностей Django не хватает для создания сложного "
"условия ``WHERE`` запроса. Для таких случаев, Django предоставляет метод "
"``extra()`` ``QuerySet`` — метод позволяющий изменять  SQL сгенерированный "
"``QuerySet``."

# 06b847bf877049b8b0e89f52e3b22595
#: ../../ref/models/querysets.txt:978
msgid ""
"By definition, these extra lookups may not be portable to different database "
"engines (because you're explicitly writing SQL code) and violate the DRY "
"principle, so you should avoid them if possible."
msgstr ""
"По определению, дополнительные параметры поиска определенные в ``extra()`` "
"не переносимы между различными типами данных(потому что вы используете "
"непосредственно SQL) и нарушает принцип DRY, по этому вы должны избегать "
"использование этого метода."

# c4b07a1884d34cadb7a66854fbe8015d
#: ../../ref/models/querysets.txt:982
msgid ""
"Specify one or more of ``params``, ``select``, ``where`` or ``tables``. None "
"of the arguments is required, but you should use at least one of them."
msgstr ""
"Укажите одни или несколько параметров ``params``, ``select``, ``where`` или "
"``tables``. Ни один из аргументов не обязателен, но вы должны указать хотя "
"бы один."

# d477098199c549dea385dbc618304381
#: ../../ref/models/querysets.txt:985
msgid "``select``"
msgstr "``select``"

# e2677340436845e38f1c1eeadc0f6b3f
#: ../../ref/models/querysets.txt:987
msgid ""
"The ``select`` argument lets you put extra fields in the ``SELECT`` clause.  "
"It should be a dictionary mapping attribute names to SQL clauses to use to "
"calculate that attribute."
msgstr ""
"Параметр ``select`` позволяет добавить дополнительные поля в ``SELECT``. Это "
"должен быть словарь отображающий названия атрибутов и выражение SQL для "
"вычисления значения этого атрибута."

# fafc90c64c654582b9d9e27bf6a470e9
#: ../../ref/models/querysets.txt:995
msgid ""
"As a result, each ``Entry`` object will have an extra attribute, "
"``is_recent``, a boolean representing whether the entry's ``pub_date`` is "
"greater than Jan. 1, 2006."
msgstr ""
"В результате, каждый объект ``Entry`` будет содержать дополнительный "
"атрибут, ``is_recent``, булево значение определяющее больше ли значение "
"``pub_date`` чем 1 января 2006."

# f74fe8ea7ff94428a66e466b3fca6b38
#: ../../ref/models/querysets.txt:999
msgid ""
"Django inserts the given SQL snippet directly into the ``SELECT`` statement, "
"so the resulting SQL of the above example would be something like::"
msgstr ""
"Django вставит добавленный кусок SQL непосредственно в оператор ``SELECT``, "
"полученный SQL выглядит таким образом::"

# 311cf9d3932c448a9198013546ec6801
#: ../../ref/models/querysets.txt:1007
msgid ""
"The next example is more advanced; it does a subquery to give each resulting "
"``Blog`` object an ``entry_count`` attribute, an integer count of associated "
"``Entry`` objects::"
msgstr ""
"Следующий пример сложнее. Он добавляет подзапрос, что бы добавить каждому "
"объекту ``Blog`` атрибут ``entry_count``, который равен количеству связанных "
"объектов ``Entry``::"

# 963282dfaebf4a4d90d8ffed765150a2
#: ../../ref/models/querysets.txt:1017
msgid ""
"In this particular case, we're exploiting the fact that the query will "
"already contain the ``blog_blog`` table in its ``FROM`` clause."
msgstr ""
"В это примере, мы используем тот факт, что запрос уже будет содержать "
"таблицу ``blog_blog`` в операторе ``FROM``."

# dd1c35b12b744f459c6310f3c405b46a
#: ../../ref/models/querysets.txt:1020
msgid "The resulting SQL of the above example would be::"
msgstr "Полученный SQL запрос выглядит таким образом::"

# d833e4e577c646539ca26fafe4303729
#: ../../ref/models/querysets.txt:1025
msgid ""
"Note that the parentheses required by most database engines around "
"subqueries are not required in Django's ``select`` clauses. Also note that "
"some database backends, such as some MySQL versions, don't support "
"subqueries."
msgstr ""
"Заметим, что скобки вокруг подзапроса, обязательные для некоторых баз "
"данных, не обязательны для параметра ``select`` в Django. Так же заметим, "
"что некоторые типы баз данных, такие как некоторые версии MySQL, не "
"поддерживают подзапросы."

# c8f82a29773e419780c274f05434651e
#: ../../ref/models/querysets.txt:1030
msgid ""
"In some rare cases, you might wish to pass parameters to the SQL fragments "
"in ``extra(select=...)``. For this purpose, use the ``select_params`` "
"parameter. Since ``select_params`` is a sequence and the ``select`` "
"attribute is a dictionary, some care is required so that the parameters are "
"matched up correctly with the extra select pieces. In this situation, you "
"should use a :class:`django.utils.datastructures.SortedDict` for the "
"``select`` value, not just a normal Python dictionary."
msgstr ""
"В некоторых редких случаях, вам понадобится передать параметры в фрагмент "
"SQL из ``extra(select=...)``. Для этого, используйте параметр "
"``select_params``. Так как ``select_params`` это последовательность, а "
"атрибут ``select`` словарь, необходима некоторая внимательность, что бы "
"параметры корректно были добавлены в оператор ``SELECT``. В этом случае "
"следует использовать a :class:`django.utils.datastructures.SortedDict` для "
"значения ``select``, вместо обычного словаря Python."

# 1923cc211ba8437b90a6ca5321cef560
#: ../../ref/models/querysets.txt:1039
msgid "This will work, for example::"
msgstr "Например::"

# 28a4898245f3431383d4f394c9cbb7bb
#: ../../ref/models/querysets.txt:1045
msgid ""
"The only thing to be careful about when using select parameters in ``extra()"
"`` is to avoid using the substring ``\"%%s\"`` (that's *two* percent "
"characters before the ``s``) in the select strings. Django's tracking of "
"parameters looks for ``%s`` and an escaped ``%`` character like this isn't "
"detected. That will lead to incorrect results."
msgstr ""
"Единственное, что нужно помнить используя параметры в ``extra()`` -- "
"избегать использование ``\"%%s\"`` (тут *два* знака процента перед ``s``) в "
"параметре ``select``. Django ищет ``%s`` и экранированный символ ``%`` не "
"будет распознан. Это приведет к неверным результатам."

# c89f9dbedbe2441c8c70b5ba0f33f091
#: ../../ref/models/querysets.txt:1051
msgid "``where`` / ``tables``"
msgstr "``where`` / ``tables``"

# 8ff13dbb2f414cd0b147bb464f97f439
#: ../../ref/models/querysets.txt:1053
msgid ""
"You can define explicit SQL ``WHERE`` clauses — perhaps to perform non-"
"explicit joins — by using ``where``. You can manually add tables to the SQL "
"``FROM`` clause by using ``tables``."
msgstr ""
"Вы можете добавить оператор SQL ``WHERE`` — возможно для выполнения не "
"явного объединения таблиц — by using ``where``. Используя параметр "
"``tables`` можно добавить таблицы в оператор SQL ``FROM``."

# 15c331c702b043e68d0e634bb76a0727
#: ../../ref/models/querysets.txt:1057
msgid ""
"``where`` and ``tables`` both take a list of strings. All ``where`` "
"parameters are \"AND\"ed to any other search criteria."
msgstr ""
"``where`` и ``tables`` принимают список строк. Все параметры ``where`` будут "
"добавлены к остальным критериям через оператор \"AND\" ."

# e1286287c0154eb1b785dcebbcdec4e8
#: ../../ref/models/querysets.txt:1064
msgid "...translates (roughly) into the following SQL::"
msgstr "...будет переведено (примерно) в следующий SQL::"

# 713d4dbee21f487bb2fa345c5d1f24b9
#: ../../ref/models/querysets.txt:1068
msgid ""
"Be careful when using the ``tables`` parameter if you're specifying tables "
"that are already used in the query. When you add extra tables via the "
"``tables`` parameter, Django assumes you want that table included an extra "
"time, if it is already included. That creates a problem, since the table "
"name will then be given an alias. If a table appears multiple times in an "
"SQL statement, the second and subsequent occurrences must use aliases so the "
"database can tell them apart. If you're referring to the extra table you "
"added in the extra ``where`` parameter this is going to cause errors."
msgstr ""
"Будьте внимательны при добавлении в параметр ``tables`` таблиц, которые уже "
"используются запросом. В таком случае Django предполагает, что вы хотите "
"добавить их повторно. Это создает проблему, т.к. таблица будет добавлена с "
"псевдонимом(an alias). Если таблица несколько раз используется в запросе, "
"второй и последующие вхождения должны использовать псевдонимы, что бы база "
"данных могла различить их. При обращении к добавленной таблице в параметре "
"``where`` вы получите ошибку."

# 842b9a6d4fac4b8d8ab926eefa4f72ac
#: ../../ref/models/querysets.txt:1078
msgid ""
"Normally you'll only be adding extra tables that don't already appear in the "
"query. However, if the case outlined above does occur, there are a few "
"solutions. First, see if you can get by without including the extra table "
"and use the one already in the query. If that isn't possible, put your "
"``extra()`` call at the front of the queryset construction so that your "
"table is the first use of that table. Finally, if all else fails, look at "
"the query produced and rewrite your ``where`` addition to use the alias "
"given to your extra table. The alias will be the same each time you "
"construct the queryset in the same way, so you can rely upon the alias name "
"to not change."
msgstr ""
"Скорее всего вы будете использовать дополнительные таблицы, которые еще не "
"добавлены в запрос. Однако, если все таки возникнет описанная выше ситуация, "
"существует несколько способов ее решить. Первый, посмотрите возможно ли "
"использовать уже добавленную в запрос таблицу. Если это не возможно, "
"используйте вызов ``extra()`` в начале конструкции запроса, что бы ваша "
"таблица использовалась первой. В конце концов, если каким-то образом все "
"остальное вам не помогло, посмотрите на созданный запрос и перепишите "
"параметр ``where`` таким образом, что бы использовался псевдоним назначенный "
"дополнительной таблице. При одинаковом способе создать запрос псевдоним "
"будет всегда не измененным."

# 1a5e940cb73b484ca39666c8fa38f4df
#: ../../ref/models/querysets.txt:1089
msgid "``order_by``"
msgstr "``order_by``"

# 65361163de7e445db05dc6a18d46b3e5
#: ../../ref/models/querysets.txt:1091
msgid ""
"If you need to order the resulting queryset using some of the new fields or "
"tables you have included via ``extra()`` use the ``order_by`` parameter to "
"``extra()`` and pass in a sequence of strings. These strings should either "
"be model fields (as in the normal :meth:`order_by()` method on querysets), "
"of the form ``table_name.column_name`` or an alias for a column that you "
"specified in the ``select`` parameter to ``extra()``."
msgstr ""
"Если вам необходимо отсортировать полученный ``QuerySet`` используя новые "
"поля или таблицы, которые вы добавили через ``extra()``, используйте "
"параметр ``order_by`` передав последовательность строк. Эти строки должны "
"быть полями модели (как и в обычном методе :meth:`order_by()`), в формате "
"``table_name.column_name`` или псевдонимы колонок которые вы указали в "
"параметре ``select`` при вызове ``extra()``."

# b7ff1c442c394f2182b9b9bd354ac00d
#: ../../ref/models/querysets.txt:1104
msgid ""
"This would sort all the items for which ``is_recent`` is true to the front "
"of the result set (``True`` sorts before ``False`` in a descending ordering)."
msgstr ""
"Это запрос должен отсортировать все записи, у которых ``is_recent`` равен "
"``True``, перед остальными записями (``True`` следует перед ``False`` при "
"ниспадающей сортировке)."

# f03db6ccfc0f4194a54586b94ab8477a
#: ../../ref/models/querysets.txt:1108
msgid ""
"This shows, by the way, that you can make multiple calls to ``extra()`` and "
"it will behave as you expect (adding new constraints each time)."
msgstr ""
"Вы можете заметить, между прочим, что можно выполнить несколько вызовов "
"``extra()`` (добавляя новые параметры каждый раз)."

# 9e193718998d4537860ecf5b0b8cba65
#: ../../ref/models/querysets.txt:1111
msgid "``params``"
msgstr "``params``"

# bb4b27c71c0f4cc2a4146feaa9e1b6be
#: ../../ref/models/querysets.txt:1113
msgid ""
"The ``where`` parameter described above may use standard Python database "
"string placeholders — ``'%s'`` to indicate parameters the database engine "
"should automatically quote. The ``params`` argument is a list of any extra "
"parameters to be substituted."
msgstr ""
"Параметр ``where`` описанный выше может использовать стандартный синтаксис "
"Python подстановки параметров в строку — ``'%s'``, что бы указать какие "
"параметры должны быть экранированы базой данных. Аргумент ``params`` это "
"список дополнительных параметров, которые будут подставлены в условие "
"``where``."

# 7d12b53fac8047c6bb0e88e741a2b18b
#: ../../ref/models/querysets.txt:1122
msgid ""
"Always use ``params`` instead of embedding values directly into ``where`` "
"because ``params`` will ensure values are quoted correctly according to your "
"particular backend. For example, quotes will be escaped correctly."
msgstr ""
"Всегда используйте ``params`` вместо добавления значений непосредственно в "
"``where`` т.к. ``params`` гарантирует, что все значения будут экранированы в "
"соответствиями с синтаксисом используемой базы данных. Например, кавычки "
"будут экранированы правильно."

# 20cd30fc891c435583d2d1a75a857de9
#: ../../ref/models/querysets.txt:1127
msgid "Bad::"
msgstr "Не верно::"

# 2cada5cb69334006baed723e8a319829
#: ../../ref/models/querysets.txt:1131
msgid "Good::"
msgstr "Верно::"

# 3afdacafdbad455b9e1e7a53ec7b6031
#: ../../ref/models/querysets.txt:1136
msgid "defer"
msgstr "defer"

# 5fb61d8241314a7d8629423a425a203d
#: ../../ref/models/querysets.txt:1140
msgid ""
"In some complex data-modeling situations, your models might contain a lot of "
"fields, some of which could contain a lot of data (for example, text "
"fields), or require expensive processing to convert them to Python objects. "
"If you are using the results of a queryset in some situation where you don't "
"know if you need those particular fields when you initially fetch the data, "
"you can tell Django not to retrieve them from the database."
msgstr ""
"При сложной структуре данных модели могут содержать большое количество "
"полей, некоторые из которых могут содержать большие объемы данных(например, "
"текстовые поля), или использовать ресурсоемкий процесс преобразования данных "
"в объекты Python. Если вы точно знаете, что данные этих полей не будут "
"использоваться при работе с результатами запроса, вы можете указать Django "
"не выбирать эти поля из базы данных."

# 8a7ee38eda6e48f5a857685809cadd15
#: ../../ref/models/querysets.txt:1147
msgid ""
"This is done by passing the names of the fields to not load to ``defer()``::"
msgstr ""
"Это делается передачей названия полей, которые не должны быть загружены, в "
"метод ``defer()``::"

# 5043e37328554995a7a9d3bef5998780
#: ../../ref/models/querysets.txt:1151
msgid ""
"A queryset that has deferred fields will still return model instances. Each "
"deferred field will be retrieved from the database if you access that field "
"(one at a time, not all the deferred fields at once)."
msgstr ""
"Результат все так же будет содержать объекты модели. Каждое не выбранное "
"поле будет получено из базы данных при обращении к нему (одна за раз, не все "
"\"отложенные\" поля сразу)."

# 2414a9daaa19429ea819d61b4dcac085
#: ../../ref/models/querysets.txt:1155
msgid ""
"You can make multiple calls to ``defer()``. Each call adds new fields to the "
"deferred set::"
msgstr ""
"Вы можете выполнить несколько вызовов ``defer()``. Каждый вызов добавит "
"новые поля в список \"отложенных\"::"

# 9b26c911e7364b98a3df1e2144bf0fee
#: ../../ref/models/querysets.txt:1161
msgid ""
"The order in which fields are added to the deferred set does not matter. "
"Calling ``defer()`` with a field name that has already been deferred is "
"harmless (the field will still be deferred)."
msgstr ""
"Порядок добавления полей не имеет значения. Вызов ``defer()`` с полем, "
"которое уже было добавлено в список \"отложенных\", ничего не изменит (поле "
"все так же не будет выбираться из базы данных)."

# e3730cc7e91a4db8947ac048149bbce2
#: ../../ref/models/querysets.txt:1165
msgid ""
"You can defer loading of fields in related models (if the related models are "
"loading via :meth:`select_related()`) by using the standard double-"
"underscore notation to separate related fields::"
msgstr ""
"Вы можете указать поля связанных моделей (если эти модели загружаются через :"
"meth:`select_related()`) используя стандартный синтаксис двух нижних "
"подчеркиваний для разделения полей::"

# 4d3acc1cb7244585844db63a13fa8a8b
#: ../../ref/models/querysets.txt:1171
msgid ""
"If you want to clear the set of deferred fields, pass ``None`` as a "
"parameter to ``defer()``::"
msgstr ""
"Если вы хотите очистить список \"отложенных\" полей, передайте ``None`` как "
"параметр для ``defer()``::"

# 8c60db197c4d46d29ef25f0c8e5ffed7
#: ../../ref/models/querysets.txt:1187
msgid ""
"The ``defer()`` method (and its cousin, :meth:`only()`, below) are only for "
"advanced use-cases. They provide an optimization for when you have analyzed "
"your queries closely and understand *exactly* what information you need and "
"have measured that the difference between returning the fields you need and "
"the full set of fields for the model will be significant."
msgstr ""
"Метод ``defer()`` (и его \"коллега\" :meth:`only()`) предназначены только "
"для опытных пользователей. Они предоставляют возможность оптимизировать "
"запрос. Но для начала вам следует проанализировать его, *точно* определить "
"какие данные вам необходимы и удостовериться, что разница между получением "
"всех полей и получением определенных, будет значительной."

# 86de8b7daf0c424ebf32ea779c4f9355
#: ../../ref/models/querysets.txt:1193
msgid ""
"Even if you think you are in the advanced use-case situation, **only use "
"defer() when you cannot, at queryset load time, determine if you will need "
"the extra fields or not**. If you are frequently loading and using a "
"particular subset of your data, the best choice you can make is to normalize "
"your models and put the non-loaded data into a separate model (and database "
"table). If the columns *must* stay in the one table for some reason, create "
"a model with ``Meta.managed = False`` (see the :attr:`managed attribute "
"<django.db.models.Options.managed>` documentation) containing just the "
"fields you normally need to load and use that where you might otherwise call "
"``defer()``. This makes your code more explicit to the reader, is slightly "
"faster and consumes a little less memory in the Python process."
msgstr ""
"Даже если вы думаете, что у вас сложная ситуация требующая использовать "
"``defer() ``, **используйте его только будучи уверенным, что \"отложенные\" "
"поля не понадобятся далее в коде**. Если вы часто загружаете и используете "
"только часть полей, лучшим решением будет нормализировать модели и вынести "
"не загружаемые поля в отдельную модель(и таблицу базы данных). Если поля "
"*должны* по каким-то причинам находится в одной таблице, создайте модель с "
"``Meta.managed = False`` (смотрите документацию о :attr:`managed attribute "
"<django.db.models.Options.managed>`) содержащую только используемые поля, и "
"используйте ее вместо ``defer()``. Это делает ваш код более читабельным, "
"немного быстрее и экономит немного памяти используемой процессом Python."

# d10c44560a604b16a8175e4fac57031a
# 5f5f007b756449fe9e963847fc4aa688
#: ../../ref/models/querysets.txt:1210
msgid ""
"When calling :meth:`~django.db.models.Model.save()` for instances with "
"deferred fields, only the loaded fields will be saved. See :meth:`~django.db."
"models.Model.save()` for more details."
msgstr ""
"При вызове :meth:`~django.db.models.Model.save()` для объектов с отложенными "
"полями, только загруженные поля будут сохранены. Подробности смотрите в "
"описании :meth:`~django.db.models.Model.save()`."

# 9f71a64c63c64187aaff40d5dd2b2bf9
#: ../../ref/models/querysets.txt:1216
msgid "only"
msgstr "only"

# 9c86c8cdfbd645e2986802c35fcd31ce
#: ../../ref/models/querysets.txt:1220
msgid ""
"The ``only()`` method is more or less the opposite of :meth:`defer()`. You "
"call it with the fields that should *not* be deferred when retrieving a "
"model.  If you have a model where almost all the fields need to be deferred, "
"using ``only()`` to specify the complementary set of fields can result in "
"simpler code."
msgstr ""
"Метод ``only()``-- противоположность метода :meth:`defer()`. Вызывайте его с "
"полями, получение которых *не* должно быть отложено.  Если у вас есть "
"модель, почти все поля которой не должны выбираться из базы данных, "
"используйте ``only()``. Это сделает ваш код проще."

# 3609e904db4c4df0b4bcfe0dcb3c6e62
#: ../../ref/models/querysets.txt:1226
msgid ""
"Suppose you have a model with fields ``name``, ``age`` and ``biography``. "
"The following two querysets are the same, in terms of deferred fields::"
msgstr ""
"Например, у вас есть модель с полями ``name``, ``age`` и ``biography``. Эти "
"два запроса идентичны в плане полученных полей::"

# 08006732a6df4c2f826a7c5677070617
#: ../../ref/models/querysets.txt:1232
msgid ""
"Whenever you call ``only()`` it *replaces* the set of fields to load "
"immediately. The method's name is mnemonic: **only** those fields are loaded "
"immediately; the remainder are deferred. Thus, successive calls to ``only()"
"`` result in only the final fields being considered::"
msgstr ""
"При вызове ``only()`` будет *заменено* множество загружаемых полей. Название "
"метода говорит само за себя: **только** эти поля должны быть загружены; все "
"остальные -- \"отложены\". Таким образом при последовательном вызове ``only()"
"`` несколько раз, только поля из последнего вызова будут загружены::"

# 289793a330b14607b189dae4cfb8c2f5
#: ../../ref/models/querysets.txt:1240
msgid ""
"Since ``defer()`` acts incrementally (adding fields to the deferred list), "
"you can combine calls to ``only()`` and ``defer()`` and things will behave "
"logically::"
msgstr ""
"Так как ``defer()`` добавляет поля в список \"отложенных\" при множественном "
"вызове, вы можете совмещать вызовы ``only()`` и ``defer()``, что будет "
"работать вполне логично::"

# dee05b337045471ca43bce707de47a2a
#: ../../ref/models/querysets.txt:1251
#, fuzzy
msgid ""
"All of the cautions in the note for the :meth:`defer` documentation apply to "
"``only()`` as well. Use it cautiously and only after exhausting your other "
"options."
msgstr ""
"Все замечания описанные для метода :meth:`defer` применимы так же и к методу "
"``only()``. Используйте его с осторожностью и только в отсутствии других "
"вариантов. Так же помните, что исключения полей указанных в :meth:"
"`select_related` вызовет ошибку."

# be693002305d4620b81f6195a5f605e7
#: ../../ref/models/querysets.txt:1267
msgid "using"
msgstr "using"

# 095673642a8347009402505bb8f4a742
#: ../../ref/models/querysets.txt:1271
msgid ""
"This method is for controlling which database the ``QuerySet`` will be "
"evaluated against if you are using more than one database.  The only "
"argument this method takes is the alias of a database, as defined in :"
"setting:`DATABASES`."
msgstr ""
"Этот метод контролирует какую базу данных будет использовать ``QuerySet`` "
"для запроса, если вы используете несколько баз данных.  Единственный "
"аргумент это псевдоним базы данных указанный в настройке проекта :setting:"
"`DATABASES`."

# a20c8197c2c240d6a5dfa723b62c89b9
#: ../../ref/models/querysets.txt:1285
msgid "select_for_update"
msgstr "select_for_update"

# 0e55c2aba7894748bc2d007c5f1ad3ab
#: ../../ref/models/querysets.txt:1289
msgid ""
"Returns a queryset that will lock rows until the end of the transaction, "
"generating a ``SELECT ... FOR UPDATE`` SQL statement on supported databases."
msgstr ""
"Возвращает ``QuerySet`` блокирующий записи до завершения транзакции, "
"используя оператор SQL ``SELECT ... FOR UPDATE`` используемой базы данных."

# 0792902df92a4a47812cba16662d35a0
#: ../../ref/models/querysets.txt:1296
msgid ""
"All matched entries will be locked until the end of the transaction block, "
"meaning that other transactions will be prevented from changing or acquiring "
"locks on them."
msgstr ""
"Все, удовлетворяющие фильтрам, строки будут заблокированы до завершения "
"транзакции, то есть другие транзакции не смогут изменить или заблокировать "
"это строки."

# 95d7fbe01a0446028ce3ab946096fc9a
#: ../../ref/models/querysets.txt:1300
msgid ""
"Usually, if another transaction has already acquired a lock on one of the "
"selected rows, the query will block until the lock is released. If this is "
"not the behavior you want, call ``select_for_update(nowait=True)``. This "
"will make the call non-blocking. If a conflicting lock is already acquired "
"by another transaction, :exc:`~django.db.DatabaseError` will be raised when "
"the queryset is evaluated."
msgstr ""
"Обычно, если другая транзакция заблокировала одну из выбранных записей, "
"запрос будет заблокирован до снятия блокировки. Если вы не желаете этого, "
"используйте ``select_for_update(nowait=True)``. Вызов будет не "
"блокированным, если записи уже заблокированы, будет вызвано исключение :exc:"
"`~django.db.DatabaseError` при вычислении ``QuerySet``."

# 8e0acd3a01d64552a267b44d229abd28
#: ../../ref/models/querysets.txt:1307
msgid ""
"Currently, the ``postgresql_psycopg2``, ``oracle``, and ``mysql`` database "
"backends support ``select_for_update()``. However, MySQL has no support for "
"the ``nowait`` argument. Obviously, users of external third-party backends "
"should check with their backend's documentation for specifics in those cases."
msgstr ""
"На данный момент, ``postgresql_psycopg2``, ``oracle``, и ``mysql`` \"бэкэнды"
"\" базы данных поддерживают ``select_for_update()``. Однако, MySQL не "
"поддерживает аргумент ``nowait``. Пользователи других баз данных должны "
"уточнить эту информацию в документации используемой базы данных."

# 07555036d70443c1abefc233b4f6a63e
#: ../../ref/models/querysets.txt:1312
msgid ""
"Passing ``nowait=True`` to ``select_for_update`` using database backends "
"that do not support ``nowait``, such as MySQL, will cause a :exc:`~django.db."
"DatabaseError` to be raised. This is in order to prevent code unexpectedly "
"blocking."
msgstr ""
"Использование ``nowait=True`` в ``select_for_update`` для базы данных, "
"которая не поддерживает ``nowait``, такой как MySQL, вызовет исключение :exc:"
"`~django.db.DatabaseError`. Это делается чтобы предотвратить непредвиденную "
"блокировку кода."

# 468b0dff8e6147dbafa260f11136e211
#: ../../ref/models/querysets.txt:1317
msgid ""
"Using ``select_for_update`` on backends which do not support ``SELECT ... "
"FOR UPDATE`` (such as SQLite) will have no effect."
msgstr ""
"Использование ``select_for_update`` с базой данных, которая не поддерживает "
"``SELECT ... FOR UPDATE`` (например, SQLite) не будет иметь никакого эфекта."

# cf54942aad72476b975aeab0c6d46b05
#: ../../ref/models/querysets.txt:1321
msgid "Methods that do not return QuerySets"
msgstr "Методы, которые не возвращают QuerySets"

# e2cc8170101f4de6a8d642df4f66c0ba
#: ../../ref/models/querysets.txt:1323
msgid ""
"The following ``QuerySet`` methods evaluate the ``QuerySet`` and return "
"something *other than* a ``QuerySet``."
msgstr ""
"Следующие методы выполняют ``QuerySet`` и возвращают *не* ``QuerySet``."

# 5e5113f0ef414577825e47219fb7d53e
#: ../../ref/models/querysets.txt:1326
msgid ""
"These methods do not use a cache (see :ref:`caching-and-querysets`). Rather, "
"they query the database each time they're called."
msgstr ""
"Эти методы не используют кэш (смотрите :ref:`caching-and-querysets`) и "
"выполняют запрос к базе данных при каждом вызове."

# 215fe858f64a4e35b05940589525f55c
#: ../../ref/models/querysets.txt:1330
msgid "get"
msgstr "get"

# a4c76c594925430f9360797d2ed288fd
#: ../../ref/models/querysets.txt:1334
msgid ""
"Returns the object matching the given lookup parameters, which should be in "
"the format described in `Field lookups`_."
msgstr ""
"Возвращает объект соответствующий параметрам поиска, которые должны быть "
"указанны в формате описаном в :ref:`разделе о параметрах поиска <field-"
"lookups>`"

# ceedda62705e4961aa2713b4025293b3
#: ../../ref/models/querysets.txt:1337
msgid ""
"``get()`` raises :exc:`~django.core.exceptions.MultipleObjectsReturned` if "
"more than one object was found. The :exc:`~django.core.exceptions."
"MultipleObjectsReturned` exception is an attribute of the model class."
msgstr ""
"``get()`` вызывает исключение :exc:`~django.core.exceptions."
"MultipleObjectsReturned`, если найдено более одно объекта. :exc:`~django."
"core.excpetions.MultipleObjectsReturned` -- атрибут класса модели."

# 8b9d9fa4a3d84d18af471fd705e7b7fd
#: ../../ref/models/querysets.txt:1342
msgid ""
"``get()`` raises a :exc:`~django.core.exceptions.DoesNotExist` exception if "
"an object wasn't found for the given parameters. This exception is also an "
"attribute of the model class. Example::"
msgstr ""
"``get()`` вызывает исключение :exc:`~django.core.exceptions.DoesNotExist`, "
"ни один объект не был найден. Это исключение так же атрибут класса модели. "
"Например::"

# 1de14e70fc794c9fb9d8de5acbc06d5e
#: ../../ref/models/querysets.txt:1348
msgid ""
"The :exc:`~django.core.exceptions.DoesNotExist` exception inherits from :exc:"
"`django.core.exceptions.ObjectDoesNotExist`, so you can target multiple :exc:"
"`~django.core.exceptions.DoesNotExist` exceptions. Example::"
msgstr ""
"Исключение :exc:`~django.core.exceptions.DoesNotExist` унаследовано от :exc:"
"`django.core.exceptions.ObjectDoesNotExist`,таким образом можно обработать "
"несколько исключений :exc:`~django.core.exceptions.DoesNotExist`. Например::"

# 48c322aa8440460f81b4545e4404fcae
#: ../../ref/models/querysets.txt:1360
msgid "create"
msgstr "create"

# dc1f60acc08941bf90036eec5558cfcc
#: ../../ref/models/querysets.txt:1364
msgid ""
"A convenience method for creating an object and saving it all in one step.  "
"Thus::"
msgstr "Удобный метод создать и сохранить объект. Таким образом::"

# 6e7c183bfa21425aab2a2e428662ae84
#: ../../ref/models/querysets.txt:1368
msgid "and::"
msgstr "и::"

# 76da19f0fec2474ea112e705f5b05126
#: ../../ref/models/querysets.txt:1373
msgid "are equivalent."
msgstr "эквивалентны."

# 1213699156fb41af9b4150ec19cb1b60
#: ../../ref/models/querysets.txt:1375
msgid ""
"The :ref:`force_insert <ref-models-force-insert>` parameter is documented "
"elsewhere, but all it means is that a new object will always be created. "
"Normally you won't need to worry about this. However, if your model contains "
"a manual primary key value that you set and if that value already exists in "
"the database, a call to ``create()`` will fail with an :exc:`~django.db."
"IntegrityError` since primary keys must be unique. Be prepared to handle the "
"exception if you are using manual primary keys."
msgstr ""
"Параметр :ref:`force_insert <ref-models-force-insert>` описан в другом "
"разделе, он означает, что всегда будет  создаваться новый объект. Обычно вам "
"не нужно беспокоиться об этом. Однако, если ваш объект содержит значение "
"первичного ключа и этот ключ уже существует в базе данных, метод ``create()"
"`` вызовет исключение :exc:`~django.db.IntegrityError` т.к. первичный ключ "
"должен быть уникальным. Будьте готовы обработать исключение, если вы "
"самостоятельно указываете первичный ключ."

# 733254dc1264496dbe4cb36d871b2d9b
#: ../../ref/models/querysets.txt:1384
msgid "get_or_create"
msgstr "get_or_create"

# e3c560b3981d4cfcbf09766623b6825e
#: ../../ref/models/querysets.txt:1388
#, fuzzy
msgid ""
"A convenience method for looking up an object with the given ``kwargs`` (may "
"be empty if your model has defaults for all fields), creating one if "
"necessary."
msgstr ""
"Удобный метод для поиска объекта по заданным параметрам поиска ``kwargs``, и "
"создания нового при необходимости."

# 0b3c276a1737474fa728a52a3e7d52f1
#: ../../ref/models/querysets.txt:1395
msgid ""
"Returns a tuple of ``(object, created)``, where ``object`` is the retrieved "
"or created object and ``created`` is a boolean specifying whether a new "
"object was created."
msgstr ""
"Возвращает кортеж ``(object, created)``, где ``object`` полученный или "
"созданный объект и ``created`` -- булево значение, указывающее был ли создан "
"объект."

# 10b4d4b11a0f4074ad32685049291aca
#: ../../ref/models/querysets.txt:1399
msgid "This is meant as a shortcut to boilerplatish code. For example::"
msgstr "Этот метод удобно использовать для скриптов импорта данных. Например::"

# 69f33df6b87b42b1850c128fb7f06ed9
#: ../../ref/models/querysets.txt:1407
msgid ""
"This pattern gets quite unwieldy as the number of fields in a model goes up. "
"The above example can be rewritten using ``get_or_create()`` like so::"
msgstr ""
"Такой способ становится весьма громоздким при увеличении количества полей "
"модели. Пример выше может быть переписан с использованием метода "
"``get_or_create()``::"

# f45bcfa02f864a63bc20bd2a9c6eac1a
#: ../../ref/models/querysets.txt:1413
msgid ""
"Any keyword arguments passed to ``get_or_create()`` — *except* an optional "
"one called ``defaults`` — will be used in a :meth:`get()` call. If an object "
"is found, ``get_or_create()`` returns a tuple of that object and ``False``. "
"If multiple objects are found, ``get_or_create`` raises :exc:`~django.core."
"exceptions.MultipleObjectsReturned`. If an object is *not* found, "
"``get_or_create()`` will instantiate and save a new object, returning a "
"tuple of the new object and ``True``. The new object will be created roughly "
"according to this algorithm::"
msgstr ""
"Все именованные аргументы переданные в ``get_or_create()`` — *кроме* одного "
"не обязательного ``defaults`` — будут использованы при вызове :meth:`get()`. "
"Если объект найден, ``get_or_create()`` вернет этот объект и ``False``. Если "
"найдено несколько объектов - будет вызвано исключение :exc:`~django.core."
"exceptions.MultipleObjectsReturned`.  Если объект *не* найден, "
"``get_or_create()`` создаст и сохранит новый объект, возвращая новый объект "
"и ``True``. Новый объект будет создан примерно за таким алгоритмом::"

# ad18a6924b624c0096c7101f2630df89
#: ../../ref/models/querysets.txt:1428
msgid ""
"In English, that means start with any non-``'defaults'`` keyword argument "
"that doesn't contain a double underscore (which would indicate a non-exact "
"lookup). Then add the contents of ``defaults``, overriding any keys if "
"necessary, and use the result as the keyword arguments to the model class. "
"As hinted at above, this is a simplification of the algorithm that is used, "
"but it contains all the pertinent details. The internal implementation has "
"some more error-checking than this and handles some extra edge-conditions; "
"if you're interested, read the code."
msgstr ""
"Это означает, что будут выбраны именованные аргументы кроме ``'defaults'`` и "
"не содержащие двойное нижнее подчеркивание (которые указывают на не-точный "
"поиск). Затем добавляются значения из ``defaults``, перезаписывая ключи при "
"необходимости, полученные данные используются как аргументы для конструктора "
"класса модели. Как уже указывалось выше, это упрощенный алгоритм, но все "
"важные детали указаны. Внутренняя реализация одержит больше проверок ошибок "
"и различных условий; если вам интересно, можете посмотреть исходный код."

# fc2b1c12110e425ca3dcf375800ef326
#: ../../ref/models/querysets.txt:1437
msgid ""
"If you have a field named ``defaults`` and want to use it as an exact lookup "
"in ``get_or_create()``, just use ``'defaults__exact'``, like so::"
msgstr ""
"Если модель содержит поле ``defaults`` и вы хотите использовать его в "
"параметрах поиска в ``get_or_create()``, просто используйте "
"``'defaults__exact'``::"

# ac3893de8cff4a62aab3cafad3e10525
#: ../../ref/models/querysets.txt:1442
msgid ""
"The ``get_or_create()`` method has similar error behavior to :meth:`create()"
"` when you're using manually specified primary keys. If an object needs to "
"be created and the key already exists in the database, an :exc:`~django.db."
"IntegrityError` will be raised."
msgstr ""
"Метод ``get_or_create()`` использует аналогичное поведение с ошибками что и "
"метод :meth:`create()`, если вы самостоятельно определяете значение "
"первичного ключа. Если объект должен быть создан и значение первичного ключа "
"уже существует в базе данных, будет вызвано исключение :exc:`~django.db."
"IntegrityError`."

# fc0c7946f5364275970cd01dc58b8245
#: ../../ref/models/querysets.txt:1447
msgid ""
"This method is atomic assuming correct usage, correct database "
"configuration, and correct behavior of the underlying database. However, if "
"uniqueness is not enforced at the database level for the ``kwargs`` used in "
"a ``get_or_create`` call (see :attr:`~django.db.models.Field.unique` or :"
"attr:`~django.db.models.Options.unique_together`), this method is prone to a "
"race-condition which can result in multiple rows with the same parameters "
"being inserted simultaneously."
msgstr ""
"Этот метод атомарный при правильном использовании, правильной настройке и "
"работе БД. Однако, если уникальность полей не контролируется на уровне БД(:"
"attr:`~django.db.models.Field.unique` или :attr:`~django.db.models.Options."
"unique_together`), этот метод сколнен к \"гонке-состояний\" и в БД могут "
"попасть не уникальные данные(прим. пер. - Django то проверить уникальность, "
"но при нескольких процессах запросы могут одновременно отправиться на "
"выполнения к БД, а там уже ничего не проверяется)."

# b919494887204dfc9fc2a93e35470019
#: ../../ref/models/querysets.txt:1455
msgid ""
"If you are using MySQL, be sure to use the ``READ COMMITTED`` isolation "
"level rather than ``REPEATABLE READ`` (the default), otherwise you may see "
"cases where ``get_or_create`` will raise an :exc:`~django.db.IntegrityError` "
"but the object won't appear in a subsequent :meth:`~django.db.models.query."
"QuerySet.get` call."
msgstr ""
"При использовании MySQL, убедитесь что используете ``READ COMMITTED`` вместо "
"``REPEATABLE READ`` (по умолчанию), иначе ``get_or_create`` может вызывать :"
"exc:`~django.db.IntegrityError`, но объект не будет возвращен последующим "
"вызовом :meth:`~django.db.models.query.QuerySet.get`."

# 5ac92a346afa45b5b51f2c59c4dd87e3
#: ../../ref/models/querysets.txt:1461
#, fuzzy
msgid ""
"Finally, a word on using ``get_or_create()`` in Django views: please make "
"sure to use it only in ``POST`` requests unless you have a good reason not "
"to ``GET`` requests shouldn't have any effect on data; use ``POST`` whenever "
"a request to a page has a side effect on your data. For more, see `Safe "
"methods`_ in the HTTP spec."
msgstr ""
"Наконец, несколько слов об использовании``get_or_create()`` в представлениях "
"Django. Но если вам нужно использовать ``get_or_create()`` в представлении, "
"пожалуйста используйте его только для ``POST`` запросов, если только у вас "
"нет основательных причин не делать этого. Запросы ``GET`` не должны влиять "
"на данные; используйте запрос ``POST`` для изменения данных. Подробнее "
"смотрите раздел о `безопасных методах <http://www.w3.org/Protocols/rfc2616/"
"rfc2616-sec9.html#sec9.1.1>`_ в спецификации HTTP."

# cf17f1902a8b46578d58abff9d2123b3
#: ../../ref/models/querysets.txt:1471
msgid ""
"You can use ``get_or_create()`` through :class:`~django.db.models."
"ManyToManyField` attributes and reverse relations. In that case you will "
"restrict the queries inside the context of that relation. That could lead "
"you to some integrity problems if you don't use it consistently."
msgstr ""

# 248e3fa46c6d4b0f803835cc5e32b274
#: ../../ref/models/querysets.txt:1476
msgid "Being the following models::"
msgstr ""

# fdb17d71ad3d44aeb828244c68209094
#: ../../ref/models/querysets.txt:1485
msgid ""
"You can use ``get_or_create()`` through Book's chapters field, but it only "
"fetches inside the context of that book::"
msgstr ""

# 5de2c7490a5d4732a056b55bb17ef048
#: ../../ref/models/querysets.txt:1498
msgid ""
"This is happening because it's trying to get or create \"Chapter 1\" through "
"the book \"Ulysses\", but it can't do any of them: the relation can't fetch "
"that chapter because it isn't related to that book, but it can't create it "
"either because ``title`` field should be unique."
msgstr ""

# d429abc1e645455c940147c50ab985cd
#: ../../ref/models/querysets.txt:1505
msgid "bulk_create"
msgstr "bulk_create"

# f38d91295c744ec9b91676653ab7f82c
#: ../../ref/models/querysets.txt:1509
msgid ""
"This method inserts the provided list of objects into the database in an "
"efficient manner (generally only 1 query, no matter how many objects there "
"are)::"
msgstr ""
"Этот метод позволяет сохранить в базе данных множество объектов одним "
"запросом::"

# e38565913b9b42f8944e3422063eb7e6
#: ../../ref/models/querysets.txt:1519
msgid "This has a number of caveats though:"
msgstr "Следует упомянуть ряд оговорок:"

# 76a81c0ef9c947488487d43a52de6cc3
#: ../../ref/models/querysets.txt:1521
msgid ""
"The model's ``save()`` method will not be called, and the ``pre_save`` and "
"``post_save`` signals will not be sent."
msgstr ""
"Метод модели ``save()`` не будет вызван, и сигналы ``pre_save`` и "
"``post_save`` не будут вызваны."

# 6924420c93264545b050302f9f9ecf4e
#: ../../ref/models/querysets.txt:1523
msgid ""
"It does not work with child models in a multi-table inheritance scenario."
msgstr "Не работает с дочерними моделями при multi-table наследовании."

# 3727e407fafa4d8da290c49ca51ba764
#: ../../ref/models/querysets.txt:1524
msgid ""
"If the model's primary key is an :class:`~django.db.models.AutoField` it "
"does not retrieve and set the primary key attribute, as ``save()`` does."
msgstr ""
"Если первичный ключ модели это :class:`~django.db.models.AutoField`, его "
"значение не будет получено и атрибут первичного ключа не будет установлен "
"как это делает метод ``save()`` ."

# f65561fbfeb84c8a9d7f34247b36b679
#: ../../ref/models/querysets.txt:1527
msgid ""
"The ``batch_size`` parameter controls how many objects are created in single "
"query. The default is to create all objects in one batch, except for SQLite "
"where the default is such that at maximum 999 variables per query is used."
msgstr ""
"Параметр ``batch_size`` указывает количество объектов, которые будут созданы "
"за один запрос. По умолчанию все объекты создаются одним запросом, кроме "
"SQLite, где есть ограничение на количество переменных в запросе равное 999."

# c7683f03673446c6ab62a0b58ab6ef2d
#: ../../ref/models/querysets.txt:1536
msgid "count"
msgstr "count"

# 17a96d7d87224a1a9905cafe37f0f8cb
#: ../../ref/models/querysets.txt:1540
msgid ""
"Returns an integer representing the number of objects in the database "
"matching the ``QuerySet``. The ``count()`` method never raises exceptions."
msgstr ""
"Возвращает количество записей в базе данных отвечающем запросу ``QuerySet``. "
"Метод ``count()`` никогда не вызывает исключение."

# b15795049d074d11a35c29d720e38b37
#: ../../ref/models/querysets.txt:1551
msgid ""
"A ``count()`` call performs a ``SELECT COUNT(*)`` behind the scenes, so you "
"should always use ``count()`` rather than loading all of the record into "
"Python objects and calling ``len()`` on the result (unless you need to load "
"the objects into memory anyway, in which case ``len()`` will be faster)."
msgstr ""
"Метод ``count()`` использует ``SELECT COUNT(*)``, так что всегда используйте "
"метод ``count()`` вместо загрузки всех записей в объекты Python и вызов ``len"
"()`` над результатом (если вам кончено в любом случае не понадобится "
"загружать их далее, в таком случае ``len()`` будет быстрее)."

# df807c3d6a114491b303f2ce04458f9a
#: ../../ref/models/querysets.txt:1556
msgid ""
"Depending on which database you're using (e.g. PostgreSQL vs. MySQL), ``count"
"()`` may return a long integer instead of a normal Python integer. This is "
"an underlying implementation quirk that shouldn't pose any real-world "
"problems."
msgstr ""
"В зависимости от типа базы данных (например, PostgreSQL vs. MySQL), ``count()"
"`` может вернуть long integer вместо обычно целого Python. Это особенности "
"реализации, которые не должны создавать проблем."

# b86d2ab4185543909ae12e93061bb1cf
#: ../../ref/models/querysets.txt:1562
msgid "in_bulk"
msgstr "in_bulk"

# 6edb6624b7a342d08938636439c7f192
#: ../../ref/models/querysets.txt:1566
msgid ""
"Takes a list of primary-key values and returns a dictionary mapping each "
"primary-key value to an instance of the object with the given ID."
msgstr ""
"Получает список первичных ключей и возвращает словарь, ассоциирующий объекты "
"с передаными ID."

# 86a3793113f4425ca7ebd768234eca7b
#: ../../ref/models/querysets.txt:1578
msgid ""
"If you pass ``in_bulk()`` an empty list, you'll get an empty dictionary."
msgstr ""
"При передаче в ``in_bulk()`` пустого списка будет получен пустой словарь."

# acc6068123c54c2f849ad58f62cbb6ad
#: ../../ref/models/querysets.txt:1581
msgid "iterator"
msgstr "iterator"

# 73dba9f3e0154b9aa03243a0476e444f
#: ../../ref/models/querysets.txt:1585
msgid ""
"Evaluates the ``QuerySet`` (by performing the query) and returns an iterator "
"(see :pep:`234`) over the results. A ``QuerySet`` typically caches its "
"results internally so that repeated evaluations do not result in additional "
"queries. In contrast, ``iterator()`` will read results directly, without "
"doing any caching at the ``QuerySet`` level (internally, the default "
"iterator calls ``iterator()`` and caches the return value). For a "
"``QuerySet`` which returns a large number of objects that you only need to "
"access once, this can result in better performance and a significant "
"reduction in memory."
msgstr ""
"Вычисляет ``QuerySet`` (выполняя запрос) и возвращает итератор (смотрите :"
"pep:`234`) по результату. ``QuerySet`` обычно кэширует результат и повторное "
"обращение не вызывает повторное выполнение запросов. Метод ``iterator()`` "
"читает результаты непосредственно из базы данных, без кэширования на уровне "
"``QuerySet`` (итератор по-умолчанию вызывает ``iterator()`` и кэширует "
"возвращенное значение). Для ``QuerySet``, который возвращает большое "
"количество объектов и который будет использован всего лишь один раз, "
"использование этого метода может увеличить производительность и немного "
"уменьшить потребление памяти."

# 6ddbfbdde0b0433fb919283bab10857c
#: ../../ref/models/querysets.txt:1594
msgid ""
"Note that using ``iterator()`` on a ``QuerySet`` which has already been "
"evaluated will force it to evaluate again, repeating the query."
msgstr ""
"Заметим, что использование ``iterator()`` для ``QuerySet``, который уже был "
"вычислен, приведет к повторному вычислению и выполнению запроса к базе "
"данных."

# b35756d3cd9a4ee49466a724284c48c4
#: ../../ref/models/querysets.txt:1597
msgid ""
"Also, use of ``iterator()`` causes previous ``prefetch_related()`` calls to "
"be ignored since these two optimizations do not make sense together."
msgstr ""
"Заметим, если вы используете ``iterator()`` для выполнения запроса, вызов "
"``prefetch_related()`` будет проигнорирован т.к. использование этих двух "
"оптимизаций вместе не имеет смысла."

# ae3893892f9949d3adebed149ff9d3ff
#: ../../ref/models/querysets.txt:1602
msgid ""
"Some Python database drivers like ``psycopg2`` perform caching if using "
"client side cursors (instantiated with ``connection.cursor()`` and what "
"Django's ORM uses). Using ``iterator()`` does not affect caching at the "
"database driver level. To disable this caching, look at `server side "
"cursors`_."
msgstr ""
"Некоторые драйвера базы данных на Python, например ``psycopg2``, используют "
"кеширование для client side курсора (созданный через ``connection.cursor()"
"``, такой используется в Django ORM). Использование ``iterator()`` не влияет "
"на кеширование на уровне драйвера базы данных. Что бы избежать кеширования "
"используйте `server side cursors`_."

# 208b177164b04f64889b2348092a7a6a
#: ../../ref/models/querysets.txt:1611
msgid "latest"
msgstr "latest"

# a59d25c8101d4318aa291b3de3ce78cc
#: ../../ref/models/querysets.txt:1615
msgid ""
"Returns the latest object in the table, by date, using the ``field_name`` "
"provided as the date field."
msgstr ""
"Возвращает последний объект, используя значение из поля даты указанного "
"параметром ``field_name``."

# 92c95fe7b6414491820ddf5d34908e1c
#: ../../ref/models/querysets.txt:1618
msgid ""
"This example returns the latest ``Entry`` in the table, according to the "
"``pub_date`` field::"
msgstr ""
"Этот пример возвращает последний объект ``Entry`` в таблице по полю "
"``pub_date``::"

# 46e53a048abe4842ab1948a410ac7ea9
#: ../../ref/models/querysets.txt:1623
#, fuzzy
msgid ""
"If your model's :ref:`Meta <meta-options>` specifies :attr:`~django.db."
"models.Options.get_latest_by`, you can leave off the ``field_name`` argument "
"to ``earliest()`` or ``latest()``. Django will use the field specified in :"
"attr:`~django.db.models.Options.get_latest_by` by default."
msgstr ""
"Если в :ref:`Meta <meta-options>` модели определен :attr:`~django.db.models."
"Options.get_latest_by`, вы можете не указывать аргумент ``field_name`` при "
"вызове ``latest()``. Django будет использовать поле указанное в :attr:"
"`~django.db.models.Options.get_latest_by` как значение по-умолчанию."

# 12ca2adda00e4890a443adaeb6769fb1
#: ../../ref/models/querysets.txt:1628
#, fuzzy
msgid ""
"Like :meth:`get()`, ``earliest()`` and ``latest()`` raise :exc:`~django.core."
"exceptions.DoesNotExist` if there is no object with the given parameters."
msgstr ""
"Как и :meth:`get()`, ``latest()`` вызывает исключение :exc:`~django.core."
"exceptions.DoesNotExist`, если объект не найден."

# 4b363776d5f14c71ab312253808eb6c2
#: ../../ref/models/querysets.txt:1632
#, fuzzy
msgid ""
"Note that ``earliest()`` and ``latest()`` exist purely for convenience and "
"readability."
msgstr ""
"Заметим что ``latest()`` существует исключительно для удобства и читаемости."

# d762ed34648e4f7280d68c4885bc76f4
#: ../../ref/models/querysets.txt:1636
msgid "earliest"
msgstr ""

# 766675a64d734956a37b1a3a2f939a0e
#: ../../ref/models/querysets.txt:1642
msgid ""
"Works otherwise like :meth:`~django.db.models.query.QuerySet.latest` except "
"the direction is changed."
msgstr ""

# 45e7628d4bd04f3b90916551b1a0390c
#: ../../ref/models/querysets.txt:1646
msgid "first"
msgstr ""

# 73fad5b23e0642e29eeaed90d74523ac
#: ../../ref/models/querysets.txt:1651
msgid ""
"Returns the first object matched by the queryset, or ``None`` if there is no "
"matching object. If the ``QuerySet`` has no ordering defined, then the "
"queryset is automatically ordered by the primary key."
msgstr ""

# b8f3a309033b420c9d374bbfcd3c4e36
#: ../../ref/models/querysets.txt:1659
msgid ""
"Note that ``first()`` is a convenience method, the following code sample is "
"equivalent to the above example::"
msgstr ""

# 359c284c59554f579b28b6356a4888bb
#: ../../ref/models/querysets.txt:1668
msgid "last"
msgstr ""

# d28a559f789f422cb279a02c8e6047e6
#: ../../ref/models/querysets.txt:1673
msgid ""
"Works like  :meth:`first()`, but returns the last object in the queryset."
msgstr ""

# bfeeeab3484b4fcc918460675ff3ef05
#: ../../ref/models/querysets.txt:1676
msgid "aggregate"
msgstr "aggregate"

# d55f4538662444eba46ec70f6ff639f3
#: ../../ref/models/querysets.txt:1680
msgid ""
"Returns a dictionary of aggregate values (averages, sums, etc) calculated "
"over the ``QuerySet``. Each argument to ``aggregate()`` specifies a value "
"that will be included in the dictionary that is returned."
msgstr ""
"Возвращает словарь агрегированных значений (среднее значение, сума и др.) "
"вычисленных для ``QuerySet``. Каждый аргумент ``aggregate()`` определяет "
"значение, которые будет включено в возвращаемый словарь."

# c51b80cd24bd4d82a249065668c34bdd
#: ../../ref/models/querysets.txt:1687
msgid ""
"Aggregates specified using keyword arguments will use the keyword as the "
"name for the annotation. Anonymous arguments will have a name generated for "
"them based upon the name of the aggregate function and the model field that "
"is being aggregated."
msgstr ""
"Агрегация, указанная с помощью именованного аргумента, использует имя "
"аргумента как название ключа в возвращаемом словаре. Для анонимных "
"аргументов названия ключей будут созданы из названия функции агрегации и "
"названия поля модели используемого в агрегации данных. "

# 1913362ad43347b2a98db63df08b4bff
#: ../../ref/models/querysets.txt:1692
msgid ""
"For example, when you are working with blog entries, you may want to know "
"the number of authors that have contributed blog entries::"
msgstr ""
"Например, работая с записями блога, вы возможно захотите узнать сколько "
"записей в выбранных через ``QuerySet`` блогах::"

# b61aba939cdb4885a8631a6545bbadb7
#: ../../ref/models/querysets.txt:1699
msgid ""
"By using a keyword argument to specify the aggregate function, you can "
"control the name of the aggregation value that is returned::"
msgstr ""
"Используя именованный аргумент для определения функции агрегации, вы можете "
"указать название возвращаемого значения::"

# 21912a482abc4405ba8a73d2c249d1f5
#: ../../ref/models/querysets.txt:1709
msgid "exists"
msgstr "exists"

# 3ad285524a3845abb360c97c1282895a
#: ../../ref/models/querysets.txt:1713
msgid ""
"Returns ``True`` if the :class:`.QuerySet` contains any results, and "
"``False`` if not. This tries to perform the query in the simplest and "
"fastest way possible, but it *does* execute nearly the same query as a "
"normal :class:`.QuerySet` query."
msgstr ""
"Возвращает ``True`` если :class:`.QuerySet` содержит какой-либо результат, "
"иначе - ``False``. Выполняет на столько простой и быстрый запрос, на сколько "
"это возможно, почти идентичный обычному запросу :class:`.QuerySet`."

# 437dcb476eac4f15adf69bc23744e8e1
#: ../../ref/models/querysets.txt:1718
msgid ""
":meth:`~.QuerySet.exists` is useful for searches relating to both object "
"membership in a :class:`.QuerySet` and to the existence of any objects in a :"
"class:`.QuerySet`, particularly in the context of a large :class:`.QuerySet`."
msgstr ""
":meth:`~.QuerySet.exists` полезен для определения нахождения объекта в :"
"class:`.QuerySet` и наличия какого-либо объекта в :class:`.QuerySet`, "
"особенно для больших :class:`.QuerySet`."

# 01eec27a41dd4a268277947f41b655e2
#: ../../ref/models/querysets.txt:1722
msgid ""
"The most efficient method of finding whether a model with a unique field (e."
"g. ``primary_key``) is a member of a :class:`.QuerySet` is::"
msgstr ""
"Самый эффективный способ определить принадлежит ли объект с уникальным полем "
"(например, ``primary_key``) какому-либо :class:`.QuerySet`::"

# c29c5015b9e8455d8a2dee56df6e1da2
#: ../../ref/models/querysets.txt:1729
msgid ""
"Which will be faster than the following which requires evaluating and "
"iterating through the entire queryset::"
msgstr ""
"Что будет на много быстрее, чем получение и итерация по всему результату::"

# 20b63c866c9f4ebda7664ecb46d64f61
#: ../../ref/models/querysets.txt:1735
msgid "And to find whether a queryset contains any items::"
msgstr "И для определения есть ли какой-либо объект в результате::"

# c0eb7a77829747719027f3a30a7a0420
#: ../../ref/models/querysets.txt:1740
msgid "Which will be faster than::"
msgstr "Это будет быстрее чем::"

# b016e9f883734062aba44f6fad62f527
#: ../../ref/models/querysets.txt:1745
msgid ""
"... but not by a large degree (hence needing a large queryset for efficiency "
"gains)."
msgstr ""
"... но не на много(разве что результат содержит большое количество записей)."

# 3f644a7cf9d44244b98391c7769cf49f
#: ../../ref/models/querysets.txt:1748
#, fuzzy
msgid ""
"Additionally, if a ``some_queryset`` has not yet been evaluated, but you "
"know that it will be at some point, then using ``some_queryset.exists()`` "
"will do more overall work (one query for the existence check plus an extra "
"one to later retrieve the results) than simply using ``bool(some_queryset)"
"``, which retrieves the results and then checks if any were returned."
msgstr ""
"Если ``some_query_set`` не был еще вычислен, но вы точно знаете что будет "
"вычислен в любом случае, тогда вызов ``some_query_set.exists()`` выполнит "
"больше работы (один запрос для проверки наличия данных и один для получения "
"данных) чем просто ``bool(some_query_set)``, который получит результат и "
"проверит не пустой ли он."

# 2572fda74ca44d289833cc0cba802033
#: ../../ref/models/querysets.txt:1755
msgid "update"
msgstr "update"

# a4c91155b1dd41c88ec0db1a173a3b46
#: ../../ref/models/querysets.txt:1759
msgid ""
"Performs an SQL update query for the specified fields, and returns the "
"number of rows matched (which may not be equal to the number of rows updated "
"if some rows already have the new value)."
msgstr ""
"Выполняет SQL запрос обновляющий данные указанных полей и возвращает "
"количество измененных записей(которое может быть не равно количеству "
"обновленных записей, если некоторые из них уже содержали новое значение)."

# 7e03b96273aa49a58c2db0cb2894a390
#: ../../ref/models/querysets.txt:1763
msgid ""
"For example, to turn comments off for all blog entries published in 2010, "
"you could do this::"
msgstr ""
"Например, что бы отключить комментарии для всех записей опубликованных в "
"2010 годы, нужно выполнить такой запрос::"

# 22cf494cf25d42b0929e99b30ec9f3e9
#: ../../ref/models/querysets.txt:1768
msgid ""
"(This assumes your ``Entry`` model has fields ``pub_date`` and "
"``comments_on``.)"
msgstr ""
"(Пример подразумевает что модель ``Entry`` содержит поля ``pub_date`` и "
"``comments_on``.)"

# faf468726ffc4ef5a6b9160a2a9b0a9c
#: ../../ref/models/querysets.txt:1770
msgid ""
"You can update multiple fields — there's no limit on how many. For example, "
"here we update the ``comments_on`` and ``headline`` fields::"
msgstr ""
"Вы можете изменить несколько полей — нет ограничения на количество полей. "
"Например, изменим поля ``comments_on`` и ``headline``::"

# d5effcc09c334221bc79a2fc6dc3569a
#: ../../ref/models/querysets.txt:1775
msgid ""
"The ``update()`` method is applied instantly, and the only restriction on "
"the :class:`.QuerySet` that is updated is that it can only update columns in "
"the model's main table, not on related models. You can't do this, for "
"example::"
msgstr ""
"Метод ``update()`` выполняет запрос сразу после вызова метода. Единственное "
"ограничение для :class:`.QuerySet` это то, что могут быть изменены поля "
"только главной модели, а не связанной. Вы не можете сделать такое::"

# 3a55314724fb4f5d8a6c460c9898300b
#: ../../ref/models/querysets.txt:1781
msgid "Filtering based on related fields is still possible, though::"
msgstr "Однако вы можете использовать фильтры по полям связанной модели::"

# 30e646114e6c458fb47e302c6b7911df
#: ../../ref/models/querysets.txt:1785
msgid ""
"You cannot call ``update()`` on a :class:`.QuerySet` that has had a slice "
"taken or can otherwise no longer be filtered."
msgstr ""
"Метод ``update()`` не может быть вызван для :class:`.QuerySet` с примененным "
"срезом или который не может быть отфильтрован по какой-либо другой причине."

# c685709233f040009860bd95b74cc47c
#: ../../ref/models/querysets.txt:1788
msgid "The ``update()`` method returns the number of affected rows::"
msgstr "Метод ``update()`` возвращает количество измененных записей::"

# 13882289825d4bdd8a6e8498e59f6c97
#: ../../ref/models/querysets.txt:1799
msgid ""
"If you're just updating a record and don't need to do anything with the "
"model object, the most efficient approach is to call ``update()``, rather "
"than loading the model object into memory. For example, instead of doing "
"this::"
msgstr ""
"Если вам нужно всего лишь изменить запись и не нужно ничего делать с "
"объектом модели, более эффективно использовать метод ``update()``, чем "
"загружать объект в память. Например, вместо этого::"

# dd5ce4a1ef454fba9c4043eb63f68545
#: ../../ref/models/querysets.txt:1807
msgid "...do this::"
msgstr "...делайте так::"

# ca0d678b2a9e4e418c2b1aa668532a32
#: ../../ref/models/querysets.txt:1811
msgid ""
"Using ``update()`` also prevents a race condition wherein something might "
"change in your database in the short period of time between loading the "
"object and calling ``save()``."
msgstr ""
"Использование ``update()`` так же предотвращает ситуации, когда что-то может "
"быть изменено в базе данных в тот короткий период времени между загрузкой "
"данных и вызовом ``save()``."

# e0ebad2b134c44c79b449bc990b41f33
#: ../../ref/models/querysets.txt:1815
msgid ""
"Finally, realize that ``update()`` does an update at the SQL level and, "
"thus, does not call any ``save()`` methods on your models, nor does it emit "
"the :attr:`~django.db.models.signals.pre_save` or :attr:`~django.db.models."
"signals.post_save` signals (which are a consequence of calling :meth:`Model."
"save() <django.db.models.Model.save>`). If you want to update a bunch of "
"records for a model that has a custom :meth:`~django.db.models.Model.save()` "
"method, loop over them and call :meth:`~django.db.models.Model.save()`, like "
"this::"
msgstr ""
"Учтите, что метод ``update()`` использует непосредственно SQL запрос. Метод "
"``save()`` модели не будет вызван, сигналы :attr:`~django.db.models.signals."
"pre_save` или :attr:`~django.db.models.signals.post_save` не будут вызваны "
"(которые являются следствием вызова :meth:`Model.save() <django.db.models."
"Model.save>`). Если вы хотите обновить объекты модели с переопределенным "
"методом :meth:`~django.db.models.Model.save()`, пройдитесь по каждому и "
"вызовите метод :meth:`~django.db.models.Model.save()`, например::"

# 4b8f43a4018a42c0a1a66605ecbb75e3
#: ../../ref/models/querysets.txt:1829
msgid "delete"
msgstr "delete"

# 53f0a6c8591d4972bdf8ba341367186e
#: ../../ref/models/querysets.txt:1833
msgid ""
"Performs an SQL delete query on all rows in the :class:`.QuerySet`. The "
"``delete()`` is applied instantly. You cannot call ``delete()`` on a :class:"
"`.QuerySet` that has had a slice taken or can otherwise no longer be "
"filtered."
msgstr ""
"Выполняет SQL запрос для удаления записей в :class:`.QuerySet`. Метод "
"``delete()`` выполняют запрос сразу после вызова метода. Метод ``delete()`` "
"не может быть выполнен для :class:`.QuerySet`, к которому был применен срез "
"или который не может быть отфильтрован по любой другой причине."

# c625ae58e6e74f64ae4700d54defa837
#: ../../ref/models/querysets.txt:1838
msgid "For example, to delete all the entries in a particular blog::"
msgstr "Например, удалим все записи для определенного блога::"

# 8846a1b9b7c34df0b9d4d3395ce93ab6
#: ../../ref/models/querysets.txt:1845
msgid ""
"By default, Django's :class:`~django.db.models.ForeignKey` emulates the SQL "
"constraint ``ON DELETE CASCADE`` — in other words, any objects with foreign "
"keys pointing at the objects to be deleted will be deleted along with them. "
"For example::"
msgstr ""
"По-умолчанию, Django для :class:`~django.db.models.ForeignKey` эмулирует "
"поведение ``ON DELETE CASCADE`` в SQL — другими словами, объекты, имеющие "
"внешние ключи на удаляемый объект, будут так же удалены. Например::"

# bf469a4f57424409857e959dc7d3912d
#: ../../ref/models/querysets.txt:1854
msgid ""
"This cascade behavior is customizable via the :attr:`~django.db.models."
"ForeignKey.on_delete` argument to the :class:`~django.db.models.ForeignKey`."
msgstr ""
"Такое каскадное поведение можно настроить используя аргумент :attr:`~django."
"db.models.ForeignKey.on_delete` для поля :class:`~django.db.models."
"ForeignKey`."

# 84906fc72d9a421d9671ed99afe8aafb
#: ../../ref/models/querysets.txt:1858
msgid ""
"The ``delete()`` method does a bulk delete and does not call any ``delete()"
"`` methods on your models. It does, however, emit the :data:`~django.db."
"models.signals.pre_delete` and :data:`~django.db.models.signals.post_delete` "
"signals for all deleted objects (including cascaded deletions)."
msgstr ""
"Метод ``delete()`` выполняет массовое удаление и не вызывает метод ``delete()"
"`` модели. Однако, будут вызваны сигналы :data:`~django.db.models.signals."
"pre_delete` и :data:`~django.db.models.signals.post_delete` для всех "
"удаленных объектов (включая объекты удаленные каскадным удалением)."

# 7f89c058ecec4ce9a26da380e2f3747a
#: ../../ref/models/querysets.txt:1868
msgid ""
"Django needs to fetch objects into memory to send signals and handle "
"cascades. However, if there are no cascades and no signals, then Django may "
"take a fast-path and delete objects without fetching into memory. For large "
"deletes this can result in significantly reduced memory usage. The amount of "
"executed queries can be reduced, too."
msgstr ""
"Django необходимо загрузить все объекты в память и послать сигнал для "
"каскадной обработки. Однако, если нет необходимости в посылании сигнала для "
"каскадного поведения, Django может удалить объекты без загрузки в память. "
"При удалении большого количества объектов, можно значительно сократить "
"количество используемой памяти. Также сократится количество запросов."

# d1fdf64b1c9344908c5be2a25a0fdec0
#: ../../ref/models/querysets.txt:1874
msgid ""
"ForeignKeys which are set to :attr:`~django.db.models.ForeignKey.on_delete` "
"DO_NOTHING do not prevent taking the fast-path in deletion."
msgstr ""
"Внешние ключи со значением :attr:`~django.db.models.ForeignKey.on_delete` "
"DO_NOTHING не мешают быстрому удалению."

# 8dcfa05df51b4108ac3173385f3f448d
#: ../../ref/models/querysets.txt:1877
msgid ""
"Note that the queries generated in object deletion is an implementation "
"detail subject to change."
msgstr ""
"Заметим, что запросы созданные при удалении объектов не обсуждаются т.к. "
"являются деталями реализаци Django."

# 6f7c8ae944d44149a7f4ff47bcd9d252
#: ../../ref/models/querysets.txt:1883
msgid "Field lookups"
msgstr "Операторы фильтрации"

# 51a52e84582f4171938ee8b0bfc913cf
#: ../../ref/models/querysets.txt:1885
msgid ""
"Field lookups are how you specify the meat of an SQL ``WHERE`` clause. "
"They're specified as keyword arguments to the ``QuerySet`` methods :meth:"
"`filter()`, :meth:`exclude()` and :meth:`get()`."
msgstr ""
"Операторы фильтрации используются для создания оператора ``WHERE`` в SQL. "
"Они используются как именованные аргументы для методов ``QuerySet``: :meth:"
"`filter()`, :meth:`exclude()` и :meth:`get()`."

# ae6ddfe541a64124b34b96b3977286e6
#: ../../ref/models/querysets.txt:1889
msgid ""
"For an introduction, see :ref:`models and database queries documentation "
"<field-lookups-intro>`."
msgstr ""
"Введение смотрите в разделе о :ref:`моделях и выполнении запросов к базе "
"данных <field-lookups-intro>`."

# bca209d42092487e9964c7652b9a211b
#: ../../ref/models/querysets.txt:1895
msgid "exact"
msgstr "exact"

# a9234d56d6b84edbbf3b8d8794028b17
#: ../../ref/models/querysets.txt:1897
msgid ""
"Exact match. If the value provided for comparison is ``None``, it will be "
"interpreted as an SQL ``NULL`` (see :lookup:`isnull` for more details)."
msgstr ""
"Точное совпадение. Если передано значение ``None``, оно будет "
"интерпретировано как SQL ``NULL`` (смотрите подробности в описании :lookup:"
"`isnull`)."

# d332fc1c658a4492ae9b562a479dfdab
# 24d5295c790c46f9a975fcd88f1e3ba7
# 86bd9402d19f48fe82b1bf3e6b1ee382
#: ../../ref/models/querysets.txt:1905 ../../ref/models/querysets.txt:2408
#: ../../ref/models/querysets.txt:2432
msgid "SQL equivalents::"
msgstr "Аналог SQL::"

# 56ead27abcc8461283aa4cf1d6797f50
#: ../../ref/models/querysets.txt:1912
msgid ""
"In MySQL, a database table's \"collation\" setting determines whether "
"``exact`` comparisons are case-sensitive. This is a database setting, *not* "
"a Django setting. It's possible to configure your MySQL tables to use case-"
"sensitive comparisons, but some trade-offs are involved. For more "
"information about this, see the :ref:`collation section <mysql-collation>` "
"in the :doc:`databases </ref/databases>` documentation."
msgstr ""
"В MySQL, настройка \"collation\" таблицы базы данных определяет будет ли "
"использовано регистро-зависимое сравнение для ``exact``. Это настройка базы "
"данных, *не* Django. Можно настроить регистро-зависимое сравнение для таблиц "
"MySQL. Подробности смотрите в :ref:`разделе о сравнении <mysql-collation>` "
"документации о :doc:`базах данных </ref/databases>`."

# ecfdd7bed2094711a71275393092098b
#: ../../ref/models/querysets.txt:1922
msgid "iexact"
msgstr "iexact"

# c790d016148f48d9bbcf0b0cf507598b
#: ../../ref/models/querysets.txt:1924
msgid "Case-insensitive exact match."
msgstr "Регистро-независимое точное совпадение."

# 46ea26d2a9f244268a100e9407d40d85
# 92ad5423ba9541819e942c734c6e7666
# 03305512d68f48819d082dcdf473db96
# 5c74e2dcd6d444c9a19dc3c73f649aa4
# 5aa8d6e8618c48c3be94d5c26a271fc5
# 48d1b44753ff4301be6c7f0f193e237d
# 905fc69346a2456babd76b663155d0c2
# 049c7c7798ce4d2a9b2f4e073e1dba4a
# 09afe94e5a654a16bfc456dc68636596
# 4a393b64d51d47eea9b79c0d803d4108
# 17e3207b845540da8abb27b21bdff0d4
# d64f76ce7139449695a255ca3fd0764d
# 7951d6720d58440a904b19337aac5c5c
# 8379281c0c194dfe8d56ed8b7c2dd56f
# c28ee383e69e4fc2bf54dfbf03ea8dcb
#: ../../ref/models/querysets.txt:1930 ../../ref/models/querysets.txt:1955
#: ../../ref/models/querysets.txt:1980 ../../ref/models/querysets.txt:2001
#: ../../ref/models/querysets.txt:2058 ../../ref/models/querysets.txt:2094
#: ../../ref/models/querysets.txt:2112 ../../ref/models/querysets.txt:2133
#: ../../ref/models/querysets.txt:2154 ../../ref/models/querysets.txt:2178
#: ../../ref/models/querysets.txt:2207 ../../ref/models/querysets.txt:2228
#: ../../ref/models/querysets.txt:2249 ../../ref/models/querysets.txt:2300
#: ../../ref/models/querysets.txt:2322 ../../ref/models/querysets.txt:2344
#: ../../ref/models/querysets.txt:2365 ../../ref/models/querysets.txt:2381
msgid "SQL equivalent::"
msgstr "Аналог SQL::"

# 24fc5adf9f7c4fafab99fa1468e29d2b
#: ../../ref/models/querysets.txt:1934
msgid ""
"Note this will match ``'Beatles Blog'``, ``'beatles blog'``, ``'BeAtLes "
"BLoG'``, etc."
msgstr ""
"Заметим что будет найден ``'Beatles Blog'``, ``'beatles blog'``, ``'BeAtLes "
"BLoG'`` и тд."

# 31922d4f9efd46af950059bc8e326b70
#: ../../ref/models/querysets.txt:1939
msgid ""
"When using the SQLite backend and Unicode (non-ASCII) strings, bear in mind "
"the :ref:`database note <sqlite-string-matching>` about string comparisons. "
"SQLite does not do case-insensitive matching for Unicode strings."
msgstr ""
"Используя SQLite и Unicode (не-ASCII) строки, помните :ref:`замечание о "
"сравнении строк в SQLite <sqlite-string-matching>`. SQLite не выполняет "
"регистро-независимое сравнение Unicode строк."

# dbbc4737795e4a4885885819f055ddb6
#: ../../ref/models/querysets.txt:1947
msgid "contains"
msgstr "contains"

# 67343a542c2b4215be9327d0e4f1f55b
#: ../../ref/models/querysets.txt:1949
msgid "Case-sensitive containment test."
msgstr "Регистро-зависимая проверка на вхождение."

# e5d327a989cb4a898992968cc8489424
#: ../../ref/models/querysets.txt:1959
msgid ""
"Note this will match the headline ``'Lennon honored today'`` but not "
"``'lennon honored today'``."
msgstr ""
"Заметим, что будет найдена строка ``'Lennon honored today'``, но не "
"``'lennon honored today'``."

# d7808b395aa945fa9d064e4b5430a13c
#: ../../ref/models/querysets.txt:1964
msgid ""
"SQLite doesn't support case-sensitive ``LIKE`` statements; ``contains`` acts "
"like ``icontains`` for SQLite. See the :ref:`database note <sqlite-string-"
"matching>` for more information."
msgstr ""
"SQLite не поддерживает регистро-зависимый оператор ``LIKE``; ``contains`` "
"работает так же как и ``icontains`` для SQLite. Смотрите :ref:`замечание о "
"сравнении строк в SQLite <sqlite-string-matching>`."

# 3fd1c8a55daf4573977c0a7222291e88
#: ../../ref/models/querysets.txt:1972
msgid "icontains"
msgstr "icontains"

# 77b1dc9d5c064180abdc64a1ca07f124
#: ../../ref/models/querysets.txt:1974
msgid "Case-insensitive containment test."
msgstr "Регистро-независимая проверка на вхождение."

# 3a8bf3be9bb64a409e14445f8ec03060
# e63d0675b70646bd88a85572c3fafc4e
# 19daad0c85bd4d89953acee3b9f59a77
#: ../../ref/models/querysets.txt:1986 ../../ref/models/querysets.txt:2118
#: ../../ref/models/querysets.txt:2160
msgid ""
"When using the SQLite backend and Unicode (non-ASCII) strings, bear in mind "
"the :ref:`database note <sqlite-string-matching>` about string comparisons."
msgstr ""
"Используя SQLite и Unicode (не-ASCII) строки, помните :ref:`замечание о "
"сравнении строк в SQLite <sqlite-string-matching>`."

# fcb2730a5a3e4b8597ae9319634d8f27
#: ../../ref/models/querysets.txt:1993
msgid "in"
msgstr "in"

# 87ea959d64274072873bb0c8167796b4
#: ../../ref/models/querysets.txt:1995
msgid "In a given list."
msgstr "Проверяет на вхождение в список значений."

# 060a14ce774b4558bbe7f4a1d5be3445
#: ../../ref/models/querysets.txt:2005
msgid ""
"You can also use a queryset to dynamically evaluate the list of values "
"instead of providing a list of literal values::"
msgstr "Вы можете так же передать ``QuerySet`` для получения списка значений::"

# 09549617c55b4da0be0d7c80bd940757
#: ../../ref/models/querysets.txt:2011
msgid "This queryset will be evaluated as subselect statement::"
msgstr "Он будет использован как подзапрос::"

# 4a105d294b9e4eefa408d733720bc6a7
#: ../../ref/models/querysets.txt:2015
msgid ""
"If you pass in a ``ValuesQuerySet`` or ``ValuesListQuerySet`` (the result of "
"calling ``values()`` or ``values_list()`` on a queryset) as the value to an "
"``__in`` lookup, you need to ensure you are only extracting one field in the "
"result. For example, this will work (filtering on the blog names)::"
msgstr ""
"Передавая ``ValuesQuerySet`` или ``ValuesListQuerySet`` (результат вызова "
"``values()`` или ``values_list()``) как аргумент для фильтра ``__in``, вы "
"должны быть уверенным, что результат содержит данные только одного поля. "
"Например, этот код будет работать (фильтр по названиям блога)::"

# 6e61d91c22c44361af2c75b994c0cdc2
#: ../../ref/models/querysets.txt:2023
msgid ""
"This example will raise an exception, since the inner query is trying to "
"extract two field values, where only one is expected::"
msgstr ""
"Этот пример вызовет исключение т.к. подзапрос выбирает два поля в то время, "
"как ожидается одно::"

# 1894acc1d7c04b8da51f2a490e298bef
#: ../../ref/models/querysets.txt:2032
msgid ""
"Be cautious about using nested queries and understand your database server's "
"performance characteristics (if in doubt, benchmark!). Some database "
"backends, most notably MySQL, don't optimize nested queries very well. It is "
"more efficient, in those cases, to extract a list of values and then pass "
"that into the second query. That is, execute two queries instead of one::"
msgstr ""
"Будьте осторожны при использовании вложенных запросов и учитывайте "
"производительность вышей базы данных (если сомневаетесь, протестируйте "
"его!). Некоторые типы баз данных, особенно MySQL, не очень хорошо "
"оптимизируют вложенные запросы. В таком случае более эффективно получить "
"список значений первым запросом и передать в другой::"

# 3dffaf2d368b41228ba28d3674580965
#: ../../ref/models/querysets.txt:2043
msgid ""
"Note the ``list()`` call around the Blog ``QuerySet`` to force execution of "
"the first query. Without it, a nested query would be executed, because :ref:"
"`querysets-are-lazy`."
msgstr ""
"Отметим использование ``list()`` с первым ``QuerySet`` что бы спровоцировать "
"выполнение запроса. Без этого, он будет использован как подзапрос т.к. :ref:"
"`querysets-are-lazy`."

# efdcfa281a21404fb26fcb8bb34bdef5
#: ../../ref/models/querysets.txt:2050
msgid "gt"
msgstr "gt"

# 298b78972f8445dcb2ac8f0f189e6096
#: ../../ref/models/querysets.txt:2052
msgid "Greater than."
msgstr "Больше чем."

# 93226a1d19bc4775a46b54ad66c3a196
#: ../../ref/models/querysets.txt:2065
msgid "gte"
msgstr "gte"

# 700d1b4529a247b08eb6d54ec431bc0d
#: ../../ref/models/querysets.txt:2067
msgid "Greater than or equal to."
msgstr "Больше чем или равно."

# 2c2ab2f71bb84b9fa62774f8804dd5b1
#: ../../ref/models/querysets.txt:2072
msgid "lt"
msgstr "lt"

# 5f12fe0149774a9b86f7c8c583d35b65
#: ../../ref/models/querysets.txt:2074
msgid "Less than."
msgstr "Меньше чем."

# 634baf15353246e7a3262c1daa6772ba
#: ../../ref/models/querysets.txt:2079
msgid "lte"
msgstr "lte"

# e99ffbafead64b74b48a32b9d67edc85
#: ../../ref/models/querysets.txt:2081
msgid "Less than or equal to."
msgstr "Меньше чем или равно."

# 7ff40223fac34ad18eba45a83140a83b
#: ../../ref/models/querysets.txt:2086
msgid "startswith"
msgstr "startswith"

# 88cbfd11577c4dd183bf087d0899bef9
#: ../../ref/models/querysets.txt:2088
msgid "Case-sensitive starts-with."
msgstr "Регистро-зависимая проверка начинается ли поле с указанного значения."

# 92612c5066fb4c5ca34d09c691000470
#: ../../ref/models/querysets.txt:2098
msgid ""
"SQLite doesn't support case-sensitive ``LIKE`` statements; ``startswith`` "
"acts like ``istartswith`` for SQLite."
msgstr ""
"SQLite не поддерживает регистро-зависимый оператор ``LIKE``; ``startswith`` "
"работает так же как и ``istartswith`` для SQLite."

# 111d6588245743338bc6865cffd6b528
#: ../../ref/models/querysets.txt:2104
msgid "istartswith"
msgstr "istartswith"

# ff564778fbed4940ad6ca9079a6afb00
#: ../../ref/models/querysets.txt:2106
msgid "Case-insensitive starts-with."
msgstr ""
"Регистро-независимая проверка начинается ли поле с указанного значения."

# 4c98a20fb2914c2c86251bb55eb9e77c
#: ../../ref/models/querysets.txt:2125
msgid "endswith"
msgstr "endswith"

# a000eade0e104eeb869237a1a2221e86
#: ../../ref/models/querysets.txt:2127
msgid "Case-sensitive ends-with."
msgstr ""
"Регистро-зависимая проверка оканчивается ли поле с указанного значения."

# ed826e4d9d2e44c9bf4517ef099b194f
#: ../../ref/models/querysets.txt:2139
msgid ""
"SQLite doesn't support case-sensitive ``LIKE`` statements; ``endswith`` acts "
"like ``iendswith`` for SQLite. Refer to the :ref:`database note <sqlite-"
"string-matching>` documentation for more."
msgstr ""
"SQLite не поддерживает регистро-зависимый оператор ``LIKE``; ``endswith`` "
"работает так же как и ``iendswith`` для SQLite. Смотрите :ref:`замечание о "
"сравнении строк в SQLite <sqlite-string-matching>`."

# 1922221732f14962b994fd2ea4ba7f0d
#: ../../ref/models/querysets.txt:2146
msgid "iendswith"
msgstr "iendswith"

# 071c72167d2043aca090635e4060f292
#: ../../ref/models/querysets.txt:2148
msgid "Case-insensitive ends-with."
msgstr ""
"Регистро-независимая проверка оканчивается ли поле с указанного значения."

# 9ed5736e60ef43b8a31f2631034d5f8c
#: ../../ref/models/querysets.txt:2167
msgid "range"
msgstr "range"

# d4da44bd202649b08723993ca9536afc
#: ../../ref/models/querysets.txt:2169
msgid "Range test (inclusive)."
msgstr "Проверка на вхождение в диапазон (включающий)."

# 5b0e615a17dc44aa88d03060f4da36fa
#: ../../ref/models/querysets.txt:2182
msgid ""
"You can use ``range`` anywhere you can use ``BETWEEN`` in SQL — for dates, "
"numbers and even characters."
msgstr ""
"Вы можете использовать ``range`` там же, где можно использовать ``BETWEEN`` "
"в SQL — для дат, чисел и даже строк."

# cbc6051bce8b47f483abef9bbbf52dd1
#: ../../ref/models/querysets.txt:2187
msgid ""
"Filtering a ``DateTimeField`` with dates won't include items on the last "
"day, because the bounds are interpreted as \"0am on the given date\". If "
"``pub_date`` was a ``DateTimeField``, the above expression would be turned "
"into this SQL::"
msgstr ""
"Фильтрация ``DateTimeField`` по датам не включит записи последнего дня, так "
"как граници интерпретируются как \"00:00 указанного дня\". Если ``pub_date`` "
"было ``DateTimeField``, мы бы получили следующий SQL запрос::"

# 5c754e62cf0f45c29f94439364df0eaf
#: ../../ref/models/querysets.txt:2194
msgid "Generally speaking, you can't mix dates and datetimes."
msgstr "В общем вы не можете использовать date и datetime вместе."

# f4d814190b4344149dbc839518920ac4
#: ../../ref/models/querysets.txt:2199
msgid "year"
msgstr "year"

# fd13d794f2a2494689122c5fc066e0cd
#: ../../ref/models/querysets.txt:2201
#, fuzzy
msgid ""
"For date and datetime fields, an exact year match. Takes an integer year."
msgstr ""
"Проверка года для полей date/datetime. Принимает значение года из 4-х цифр."

# 29083d0d847d4a7e8bff552fb33ec6c8
# 56fee1cc131943e1922b92d0ce10e52e
# 8c63272bae8e4af4b3187a69dae74c62
#: ../../ref/models/querysets.txt:2211 ../../ref/models/querysets.txt:2232
#: ../../ref/models/querysets.txt:2253 ../../ref/models/querysets.txt:2304
#: ../../ref/models/querysets.txt:2326 ../../ref/models/querysets.txt:2348
msgid "(The exact SQL syntax varies for each database engine.)"
msgstr "(Точный синтаксис SQL зависит от базы данных.)"

# ca86f547fe3e4d25ae9bcceddbea4f06
#: ../../ref/models/querysets.txt:2213
msgid ""
"When :setting:`USE_TZ` is ``True``, datetime fields are converted to the "
"current time zone before filtering."
msgstr ""

# 003f2b547be24a74b2a8ffcb2f3a0d8a
#: ../../ref/models/querysets.txt:2219
msgid "month"
msgstr "month"

# 8ab04c7938334d4cb1b2571c04614547
#: ../../ref/models/querysets.txt:2221
msgid ""
"For date and datetime fields, an exact month match. Takes an integer 1 "
"(January) through 12 (December)."
msgstr ""
"Проверка месяца для полей date/datetime. Принимает целое число от 1(январь) "
"до 12(декабрь)."

# d7ac25bd166447f6a18f68c10dcead4d
# 1657530897cb450aaf3a77912c1aed93
# e65ec0b30af046eead5d5a0a254828c0
#: ../../ref/models/querysets.txt:2234 ../../ref/models/querysets.txt:2258
#: ../../ref/models/querysets.txt:2283
msgid ""
"When :setting:`USE_TZ` is ``True``, datetime fields are converted to the "
"current time zone before filtering. This requires :ref:`time zone "
"definitions in the database <database-time-zone-definitions>`."
msgstr ""

# 3a7fa46732934635ba5767f67a5aaa83
#: ../../ref/models/querysets.txt:2241
msgid "day"
msgstr "day"

# 774d8c63fc154b85a91ae9aba6b60abd
#: ../../ref/models/querysets.txt:2243
#, fuzzy
msgid "For date and datetime fields, an exact day match. Takes an integer day."
msgstr "Проверка дня месяца для полей date/datetime."

# 86d6c940d9aa427d822aae2f525b374c
#: ../../ref/models/querysets.txt:2255
msgid ""
"Note this will match any record with a pub_date on the third day of the "
"month, such as January 3, July 3, etc."
msgstr ""
"Заметим, что будут найдены записи, у которых значение ``pub_date`` это дата "
"3-го числа любого месяца, такие как 3-го января, 3-го июля и тд."

# 431be0498e904a54ad9c34278ca3bbb4
#: ../../ref/models/querysets.txt:2265
msgid "week_day"
msgstr "week_day"

# 92392f5c054441589284b93eadbeef2e
#: ../../ref/models/querysets.txt:2267
msgid "For date and datetime fields, a 'day of the week' match."
msgstr "Проверка дня недели для полей date/datetime."

# 3b6f9608043a48feb7b8fedd160c34c3
#: ../../ref/models/querysets.txt:2269
msgid ""
"Takes an integer value representing the day of week from 1 (Sunday) to 7 "
"(Saturday)."
msgstr "Принимает номер дня недели от 1 (воскресение) до 7 (суббота)."

# 9c3d1a50ec6e4c268855f16ee1bf6b13
#: ../../ref/models/querysets.txt:2276
msgid ""
"(No equivalent SQL code fragment is included for this lookup because "
"implementation of the relevant query varies among different database "
"engines.)"
msgstr ""
"(Аналог SQL не представлен т.к. реализация отличается для различных баз "
"данных.)"

# 567c6d131a684d7a8d1019ac60c9749f
#: ../../ref/models/querysets.txt:2279
msgid ""
"Note this will match any record with a ``pub_date`` that falls on a Monday "
"(day 2 of the week), regardless of the month or year in which it occurs. "
"Week days are indexed with day 1 being Sunday and day 7 being Saturday."
msgstr ""
"Будут найдены записи, у которых дата в ``pub_date`` -- понедельник (второй "
"день недели), независимо от месяца и года. Дни недели пронумерованы от 1"
"(воскресение) до 7(суббота)."

# 2c265bf22e7546199e257c59162de6b3
#: ../../ref/models/querysets.txt:2290
msgid "hour"
msgstr ""

# fd13d794f2a2494689122c5fc066e0cd
#: ../../ref/models/querysets.txt:2294
#, fuzzy
msgid ""
"For datetime fields, an exact hour match. Takes an integer between 0 and 23."
msgstr ""
"Проверка года для полей date/datetime. Принимает значение года из 4-х цифр."

# ecf5440bd93740eeb2573c7040cf13a1
# 6dafa4cefdb942d59883f89e03fe2ede
# 07eee6920e6948afbe05d413239c5fa9
#: ../../ref/models/querysets.txt:2306 ../../ref/models/querysets.txt:2328
#: ../../ref/models/querysets.txt:2350
msgid ""
"When :setting:`USE_TZ` is ``True``, values are converted to the current time "
"zone before filtering."
msgstr ""

# 923004e7068d457e8cd0b2a01c193ba6
#: ../../ref/models/querysets.txt:2312
msgid "minute"
msgstr ""

# 8ab04c7938334d4cb1b2571c04614547
#: ../../ref/models/querysets.txt:2316
#, fuzzy
msgid ""
"For datetime fields, an exact minute match. Takes an integer between 0 and "
"59."
msgstr ""
"Проверка месяца для полей date/datetime. Принимает целое число от 1(январь) "
"до 12(декабрь)."

# d4a6e72b8d13474bb43911547f92f1c6
#: ../../ref/models/querysets.txt:2334
msgid "second"
msgstr ""

# 8ab04c7938334d4cb1b2571c04614547
#: ../../ref/models/querysets.txt:2338
#, fuzzy
msgid ""
"For datetime fields, an exact second match. Takes an integer between 0 and "
"59."
msgstr ""
"Проверка месяца для полей date/datetime. Принимает целое число от 1(январь) "
"до 12(декабрь)."

# 0f8c1aba3b344712a47b748a97f71791
#: ../../ref/models/querysets.txt:2356
msgid "isnull"
msgstr "isnull"

# b960054304bd41fb8c7ecfedc385b26b
#: ../../ref/models/querysets.txt:2358
msgid ""
"Takes either ``True`` or ``False``, which correspond to SQL queries of ``IS "
"NULL`` and ``IS NOT NULL``, respectively."
msgstr ""
"Принимает ``True`` или ``False``, что соответствует SQL запросу ``IS NULL`` "
"и ``IS NOT NULL``, соответственно."

# db6edd7fde1c4b9486c42146373b906c
#: ../../ref/models/querysets.txt:2372
msgid "search"
msgstr "search"

# 4a83426ab742406da796b34e4fd38ca5
#: ../../ref/models/querysets.txt:2374
msgid ""
"A boolean full-text search, taking advantage of full-text indexing. This is "
"like :lookup:`contains` but is significantly faster due to full-text "
"indexing."
msgstr ""
"Полнотекстовый поиск, который использует преимущества полнотекстового "
"индекса. Работает как и :lookup:`contains` но значительно быстрее благодаря "
"полнотекстовому индексу."

# 0332f758885746daa36ec358647475b5
#: ../../ref/models/querysets.txt:2385
msgid ""
"Note this is only available in MySQL and requires direct manipulation of the "
"database to add the full-text index. By default Django uses BOOLEAN MODE for "
"full text searches. See the `MySQL documentation`_ for additional details."
msgstr ""
"Работает только в MySQL и требует самостоятельного добавления "
"полнотекстового индекса. По-умолчанию Django использует BOOLEAN MODE для "
"полнотекстового поиска. Подробности в `документации MySQL <http://dev.mysql."
"com/doc/refman/5.1/en/fulltext-boolean.html>`_."

# 6e9ccec583714105bfd48647f2903e39
#: ../../ref/models/querysets.txt:2395
msgid "regex"
msgstr "regex"

# 227495836b474b5986622a6c1950ac2b
#: ../../ref/models/querysets.txt:2397
msgid "Case-sensitive regular expression match."
msgstr "Регистро-зависимая проверка регулярным выражением."

# 740fd2774c72493b9c8e212ef912da36
#: ../../ref/models/querysets.txt:2399
msgid ""
"The regular expression syntax is that of the database backend in use. In the "
"case of SQLite, which has no built in regular expression support, this "
"feature is provided by a (Python) user-defined REGEXP function, and the "
"regular expression syntax is therefore that of Python's ``re`` module."
msgstr ""
"Синтаксис регулярных выражений зависит от базы данных. Для SQLite, который "
"не поддерживает регулярные выражения, эта функция обеспечена на уровне "
"Python, по-этому используется синтаксис модуля Python ``re``."

# 9b3fc2d9a56548c3ba11e0247a34b673
#: ../../ref/models/querysets.txt:2418
msgid ""
"Using raw strings (e.g., ``r'foo'`` instead of ``'foo'``) for passing in the "
"regular expression syntax is recommended."
msgstr ""
"Рекомендуется использовать \"raw\" строки (например, ``r'foo'`` вместо "
"``'foo'``) для регулярных выражений."

# 2d839032a9214965a439641605172826
#: ../../ref/models/querysets.txt:2424
msgid "iregex"
msgstr "iregex"

# 05e579fa80194fe0a677ec04c254126a
#: ../../ref/models/querysets.txt:2426
msgid "Case-insensitive regular expression match."
msgstr "Регистро-независимая проверка регулярным выражением."

# 729b14fd249648b9b31bb0ef98f94119
#: ../../ref/models/querysets.txt:2445
msgid "Aggregation functions"
msgstr "Функции агрегации"

# 0db7cc5369fc410abe92d4b71fce6968
#: ../../ref/models/querysets.txt:2449
msgid ""
"Django provides the following aggregation functions in the ``django.db."
"models`` module. For details on how to use these aggregate functions, see :"
"doc:`the topic guide on aggregation </topics/db/aggregation>`."
msgstr ""
"Django предоставляет ряд функций агрегации в модуле ``django.db.models``. "
"Подробности, как использовать функции агрегации, смотрите в :doc:`разделе об "
"агрегации </topics/db/aggregation>`."

# 1684120b1d984f14b5bec205b7448f67
#: ../../ref/models/querysets.txt:2456
msgid ""
"SQLite can't handle aggregation on date/time fields out of the box. This is "
"because there are no native date/time fields in SQLite and Django currently "
"emulates these features using a text field. Attempts to use aggregation on "
"date/time fields in SQLite will raise ``NotImplementedError``."
msgstr ""

# b62b96d46a654d3491ba4da2641de110
#: ../../ref/models/querysets.txt:2463
msgid "Avg"
msgstr "Avg"

# 4f087bf53f1846879bddb58150ef6abd
#: ../../ref/models/querysets.txt:2467
msgid "Returns the mean value of the given field, which must be numeric."
msgstr ""
"Возвращает среднее значение указанного поля, которое должно быть численным."

# 6690fc6440444e229991c12a0bad51d7
#: ../../ref/models/querysets.txt:2469
msgid "Default alias: ``<field>__avg``"
msgstr "Псевдоним по-умолчанию: ``<field>__avg``"

# e9374dd835b64a0796f49cafb63d2793
# dc35896edcc54a28b706b32c314569ec
# 8af88572fb7043c295515783d6a8f2bf
#: ../../ref/models/querysets.txt:2470 ../../ref/models/querysets.txt:2518
#: ../../ref/models/querysets.txt:2552
msgid "Return type: ``float``"
msgstr "Тип возвращаемого значения: ``float``"

# 0c409d1475354def93edde29830f7ac4
#: ../../ref/models/querysets.txt:2473
msgid "Count"
msgstr "Count"

# 7620ea9ffc0648bf96b86af00b52b4f3
#: ../../ref/models/querysets.txt:2477
msgid ""
"Returns the number of objects that are related through the provided field."
msgstr "Возвращает количество объектов связанных через указанное поле.."

# ebcbab5dfc8948ac9da204f618439c2b
#: ../../ref/models/querysets.txt:2479
msgid "Default alias: ``<field>__count``"
msgstr "Псевдоним по-умолчанию: ``<field>__count``"

# 8f27a0c018b8479f89cb3436efa6200e
#: ../../ref/models/querysets.txt:2480
msgid "Return type: ``int``"
msgstr "Тип возвращаемого значения: ``int``"

# 7b78afaeef4f4c68a747e09ad5aa3808
# 965c986ae74645b68ccd5fd615dc7890
# 79693bc662c34ffab94db87939cbf07a
#: ../../ref/models/querysets.txt:2482 ../../ref/models/querysets.txt:2520
#: ../../ref/models/querysets.txt:2554
msgid "Has one optional argument:"
msgstr "Принимает один не обязательный параметр:"

# 475af4945fa7432ea3c6ccb205836fd7
#: ../../ref/models/querysets.txt:2486
msgid ""
"If ``distinct=True``, the count will only include unique instances. This is "
"the SQL equivalent of ``COUNT(DISTINCT <field>)``. The default value is "
"``False``."
msgstr ""
"При ``distinct=True``, будут подсчитаны только уникальные объекты. SQL "
"эквивалент -- ``COUNT(DISTINCT <field>)``. Значение по-умолчанию ``False``."

# ada47e189ee6457db1dfe81a771f62ba
#: ../../ref/models/querysets.txt:2491
msgid "Max"
msgstr "Max"

# c39eab0e29cc4c9e8f5c4906ffd2e0bd
#: ../../ref/models/querysets.txt:2495
msgid "Returns the maximum value of the given field."
msgstr "Возвращает максимальное значение указанного поля."

# ced5a09597d44654940ee0335d460243
#: ../../ref/models/querysets.txt:2497
msgid "Default alias: ``<field>__max``"
msgstr "Псевдоним по-умолчанию: ``<field>__max``"

# 3697fdcfb61d47f48026e21adf8a69dc
# 731b2c19d6d74c118da15e41828e0958
# f11f6e6ff69a493e8ea9e58573a648c5
#: ../../ref/models/querysets.txt:2498 ../../ref/models/querysets.txt:2508
#: ../../ref/models/querysets.txt:2542
msgid "Return type: same as input field"
msgstr "Тип возвращаемого значения: тип указанного поля."

# 005622d3bbfa4271956016793ade610f
#: ../../ref/models/querysets.txt:2501
msgid "Min"
msgstr "Min"

# 961c01be2a224222b5d329b06bee39e3
#: ../../ref/models/querysets.txt:2505
msgid "Returns the minimum value of the given field."
msgstr "Возвращает минимальное значение указанного поля."

# e32617a3373d412782bdfc2d70347a5e
#: ../../ref/models/querysets.txt:2507
msgid "Default alias: ``<field>__min``"
msgstr "Псевдоним по-умолчанию: ``<field>__min``"

# 6a9353ad6067426e9973c9e219303ad3
#: ../../ref/models/querysets.txt:2511
msgid "StdDev"
msgstr "StdDev"

# 0c05bca7d1314a0c967070c0b345f71d
#: ../../ref/models/querysets.txt:2515
msgid "Returns the standard deviation of the data in the provided field."
msgstr "Возвращает стандартное отклонение для данных указанного поля."

# b52735b21eac46eb9a5d41d9ff8489cd
#: ../../ref/models/querysets.txt:2517
msgid "Default alias: ``<field>__stddev``"
msgstr "Псевдоним по-умолчанию: ``<field>__stddev``"

# 24195ce6426e45c38ee7918f58c49587
#: ../../ref/models/querysets.txt:2524
msgid ""
"By default, ``StdDev`` returns the population standard deviation. However, "
"if ``sample=True``, the return value will be the sample standard deviation."
msgstr ""
"По-умолчанию, ``StdDev`` возвращает \"population\" стандартное отклонение. "
"Однако, если использовать аргумент ``sample=True``, возвращаемое значение "
"будет \"sample\" стандартное отклонение."

# 3e965735e1444d8885183edd5981400c
#: ../../ref/models/querysets.txt:2529
msgid ""
"SQLite doesn't provide ``StdDev`` out of the box. An implementation is "
"available as an extension module for SQLite. Consult the `SQlite "
"documentation`_ for instructions on obtaining and installing this extension."
msgstr ""
"SQLite не поддерживает ``StdDev`` из коробки. Реализация доступна в качестве "
"модуля расширения для SQLite. Смотрите инструкцию по установке в "
"`документации SQlite <http://www.sqlite.org/contrib>`_."

# c15dfc1c05a14212bb0fc4be6550fc31
#: ../../ref/models/querysets.txt:2535
msgid "Sum"
msgstr "Sum"

# 3d3652bb66364c77a828d2e0197165ac
#: ../../ref/models/querysets.txt:2539
msgid "Computes the sum of all values of the given field."
msgstr "Возвращает сумму всех значений указанного поля."

# 28ecdfc98f5e42a5a0bc42c286d93393
#: ../../ref/models/querysets.txt:2541
msgid "Default alias: ``<field>__sum``"
msgstr "Псевдоним по-умолчанию: ``<field>__sum``"

# 3a32fc4286914984813cde2c218131c2
#: ../../ref/models/querysets.txt:2545
msgid "Variance"
msgstr "Variance"

# 783e403140ed4b3bbbec4334b291bc5f
#: ../../ref/models/querysets.txt:2549
msgid "Returns the variance of the data in the provided field."
msgstr "Возвращает дисперсию значений в указанном поле."

# 36da04f912d944988d28bedf8f989068
#: ../../ref/models/querysets.txt:2551
msgid "Default alias: ``<field>__variance``"
msgstr "Псевдоним по-умолчанию: ``<field>__variance``"

# 10d003b4052e43a0ba85413ce4eae0b5
#: ../../ref/models/querysets.txt:2558
msgid ""
"By default, ``Variance`` returns the population variance. However, if "
"``sample=True``, the return value will be the sample variance."
msgstr ""
"По-умолчанию, ``Variance`` возвращает \"population\" дисперсию. Однако, если "
"использовать аргумент ``sample=True``, возвращаемое значение будет \"sample"
"\" дисперсия."

# 7bab55b99e094dd299f28af98b427972
#: ../../ref/models/querysets.txt:2563
msgid ""
"SQLite doesn't provide ``Variance`` out of the box. An implementation is "
"available as an extension module for SQLite. Consult the `SQlite "
"documentation`_ for instructions on obtaining and installing this extension."
msgstr ""
"SQLite не поддерживает ``Variance`` из коробки. Реализация доступна в "
"качестве модуля расширения для SQLite. Смотрите инструкцию по установке в "
"`документации SQlite <http://www.sqlite.org/contrib>`_."

# 2c62b3d966954c679352032d48778072
#~ msgid ""
#~ "As of Django 1.4, you can pass positional arguments (``*fields``) in "
#~ "order to specify the names of fields to which the ``DISTINCT`` should "
#~ "apply. This translates to a ``SELECT DISTINCT ON`` SQL query."
#~ msgstr ""
#~ "С Django 1.4, можно передать позиционные аргументы (``*fields``), "
#~ "указывая какие поля должны использоваться с ``DISTINCT``. Все это будет "
#~ "преобразовано в ``SELECT DISTINCT ON`` SQL запрос."

# a39ab3008bfc4a6b8235716f206b45cd
#~ msgid "This ability to specify field names is only available in PostgreSQL."
#~ msgstr "Возможность указывать поля доступна только в PostgreSQL."

# 39c9d32ce13e4247960fb10a992f4943
#~ msgid ""
#~ "Returns a ``DateQuerySet`` — a ``QuerySet`` that evaluates to a list of "
#~ "``datetime.datetime`` objects representing all available dates of a "
#~ "particular kind within the contents of the ``QuerySet``."
#~ msgstr ""
#~ "Возвращает ``DateQuerySet`` — ``QuerySet`` возвращающий список объектов "
#~ "``datetime.datetime`` отображающих возможные даты в контексте "
#~ "``QuerySet``."

# 4c676dfb14b54e969e866cc4eb76811d
#~ msgid ""
#~ "``field`` should be the name of a ``DateField`` or ``DateTimeField`` of "
#~ "your model."
#~ msgstr ""
#~ "``field`` -- название поля модели типа ``DateField`` или "
#~ "``DateTimeField``."

# 83a5dbf9c43e4918b590f89ffd646df3
#~ msgid ""
#~ "When :doc:`time zone support </topics/i18n/timezones>` is enabled, Django "
#~ "uses UTC in the database connection, which means the aggregation is "
#~ "performed in UTC. This is a known limitation of the current "
#~ "implementation."
#~ msgstr ""
#~ "Если включена :doc:`поддержка временных зон </topics/i18n/timezones>`, "
#~ "Django будет использовать UTC при подключении к базе данных, то есть "
#~ "агрегация выполняется в UTC. Это ограничение текущей реализации."

# 671567eab87f48ef92ef488392402340
#~ msgid ""
#~ "Returns an ``EmptyQuerySet`` — a ``QuerySet`` subclass that always "
#~ "evaluates to an empty list. This can be used in cases where you know that "
#~ "you should return an empty result set and your caller is expecting a "
#~ "``QuerySet`` object (instead of returning an empty list, for example.)"
#~ msgstr ""
#~ "Возвращает ``EmptyQuerySet`` — подкласс ``QuerySet`` который всегда "
#~ "возвращает пустой список. Полезен, если необходимо вернуть пустой "
#~ "результат, но код ожидает объект ``QuerySet`` (вместо того, что бы "
#~ "возвращать пустой список, например.)"

# 679b9e44b8f3487ba32aa4f4ba9a4f3c
#~ msgid ""
#~ "Some fields in a model won't be deferred, even if you ask for them. You "
#~ "can never defer the loading of the primary key. If you are using :meth:"
#~ "`select_related()` to retrieve related models, you shouldn't defer the "
#~ "loading of the field that connects from the primary model to the related "
#~ "one, doing so will result in an error."
#~ msgstr ""
#~ "Некоторые поля всегда будут выбираться из базы данных, даже если вы их "
#~ "добавите в вызов ``defer()``. Всегда выбирается первичный ключ. "
#~ "Используя :meth:`select_related()` для получения связанных моделей, не "
#~ "\"откладывайте\" загрузку связывающего поля иначе получите ошибку."

# 9792df60230541faab024b6366fe7928
#~ msgid ""
#~ "Note that using ``select_for_update()`` will cause the current "
#~ "transaction to be considered dirty, if under transaction management. This "
#~ "is to ensure that Django issues a ``COMMIT`` or ``ROLLBACK``, releasing "
#~ "any locks held by the ``SELECT FOR UPDATE``."
#~ msgstr ""
#~ "Следует отметить, что использование ``select_for_update()`` приводит к "
#~ "тому, что текущая транзакция считается \"грязной\" (если используется "
#~ "управление транзакциями). Это происходит, потому что Django блокирует "
#~ "указанные записи в БД и держит их до выполнения фиксации(``COMMIT``) или "
#~ "отката(``ROLLBACK``) произведённых изменений, освобождая поставленные "
#~ "ранее блокировки в базе данных."

# 2c9d52cc99be446aacd1620c56e67d2b
#~ msgid ""
#~ "When :doc:`time zone support </topics/i18n/timezones>` is enabled, Django "
#~ "uses UTC in the database connection, which means the ``year``, ``month``, "
#~ "``day`` and ``week_day`` lookups are performed in UTC. This is a known "
#~ "limitation of the current implementation."
#~ msgstr ""
#~ "Если используются :doc:`временные зоны </topics/i18n/timezones>` , Django "
#~ "использует UTC при подключении к базе данных, это означает что фильтры "
#~ "``year``, ``month``, ``day`` и ``week_day`` будут выполнены в UTC. Это "
#~ "ограничение текущей реализации."

# e8c07900458743418c31612eda81153e
#~ msgid ""
#~ "It is permissible to specify a multi-valued field to order the results by "
#~ "(for example, a :class:`~django.db.models.ManyToManyField` field). "
#~ "Normally this won't be a sensible thing to do and it's really an advanced "
#~ "usage feature. However, if you know that your queryset's filtering or "
#~ "available data implies that there will only be one ordering piece of data "
#~ "for each of the main items you are selecting, the ordering may well be "
#~ "exactly what you want to do. Use ordering on multi-valued fields with "
#~ "care and make sure the results are what you expect."
#~ msgstr ""
#~ "Для сортировки можно указать поле с множеством значений (например, :class:"
#~ "`~django.db.models.ManyToManyField` field). Как правильно, это не очень "
#~ "разумно и является функционалом для продвинутых пользователей. Однако, "
#~ "если вы уверены что фильтры \"queryset\" или существующие данные "
#~ "подразумеваю, что для каждого объекта существует только одно значение, "
#~ "используемое для сортировки -- вполне вероятно что в результате вы "
#~ "получите то, что и ожидали получить. Используйте такую сортировку с "
#~ "осторожность и убедитесь что результат отвечает вашим требованиям."

# 89f80a351e3e47c7a308985aa0797fbb
#~ msgid ""
#~ "The problem with this code is that it will run a query on the Toppings "
#~ "table for **every** item in the Pizza ``QuerySet``.  Using "
#~ "``prefetch_related``, this can be reduced to two:"
#~ msgstr ""
#~ "Проблема в том, что будет выполнен запрос к таблице ``Toppings`` для "
#~ "**каждого** объекта ``Pizza`` в ``QuerySet``. Используя "
#~ "``prefetch_related``, количество запросов можно сократить до двух:"

# 76e875e80bfd48e7b2cde3ab9b8111ef
#~ msgid ""
#~ "The additional queries are executed after the QuerySet has begun to be "
#~ "evaluated and the primary query has been executed. Note that the result "
#~ "cache of the primary QuerySet and all specified related objects will then "
#~ "be fully loaded into memory, which is often avoided in other cases - even "
#~ "after a query has been executed in the database, QuerySet normally tries "
#~ "to make uses of chunking between the database to avoid loading all "
#~ "objects into memory before you need them."
#~ msgstr ""
#~ "Дополнительные запросы будут выполнены при вычислении QuerySet и "
#~ "выполнении основного запроса. Заметим, результат выполнения QuerySet "
#~ "будет \"закэширован\" и все связанные объекты будет загружены в память, "
#~ "что обычно избегается в других случаях - даже после того, как запрос в "
#~ "базу данных был выполнен, QuerySet старается не загружать все данные в "
#~ "память пока они вам не понадобятся."
