# Russian translations for Django package.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
# Automatically generated <>, 2012.
#
msgid ""
msgstr ""
"Project-Id-Version: Django 1.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2012-03-24 01:58\n"
"PO-Revision-Date: 2012-03-06 19:23+0200\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"

# a4ddc79d3d4240fbaf014357723dd45c
#: ../../ref/models/querysets.txt:3
msgid "QuerySet API reference"
msgstr "QuerySet API"

# 93dca2c82f0c42dc9c97bbfb3a7a319a
#: ../../ref/models/querysets.txt:7
msgid ""
"This document describes the details of the ``QuerySet`` API. It builds on "
"the material presented in the :doc:`model </topics/db/models>` and :doc:"
"`database query </topics/db/queries>` guides, so you'll probably want to "
"read and understand those documents before reading this one."
msgstr ""
"Этот раздел описывает ``QuerySet`` API. Изложенный материал опирается на "
"материал, изложенный в разделах о :doc:`моделях </topics/db/models>` и :doc:"
"`выполнении запросов </topics/db/queries>`, возможно вам следует прочитать "
"их перед прочтением этого раздела."

# f19e85b7e4874b628b1f97996cd04bd3
#: ../../ref/models/querysets.txt:12
msgid ""
"Throughout this reference we'll use the :ref:`example Weblog models "
"<queryset-model-example>` presented in the :doc:`database query guide </"
"topics/db/queries>`."
msgstr ""
"В примерах будут использованы :ref:` примеры моделей web-блога <queryset-"
"model-example>` представленные в разделе о :doc:`выполнении запросов </"
"topics/db/queries>`."

# ae28fbbf5a5c49d1ac0b40f966930aab
#: ../../ref/models/querysets.txt:19
msgid "When QuerySets are evaluated"
msgstr "Когда вычисляется QuerySets"

# 5dd5377703a945e4bcde2e5797e707bf
#: ../../ref/models/querysets.txt:21
msgid ""
"Internally, a ``QuerySet`` can be constructed, filtered, sliced, and "
"generally passed around without actually hitting the database. No database "
"activity actually occurs until you do something to evaluate the queryset."
msgstr ""
"``QuerySet`` может быть создан, отфильтрован, ограничен и использован "
"фактически без выполнения запросов к базе данных. База данных не будет "
"затронута, пока вы не спровоцируете выполнение QuerySet."

# ef3c207e9e724decb242d6fab6847a5c
#: ../../ref/models/querysets.txt:25
msgid "You can evaluate a ``QuerySet`` in the following ways:"
msgstr "``QuerySet`` будет вычислен при таких действиях:"

# e9bffa6ccc09496581d31d19a0e48c7c
#: ../../ref/models/querysets.txt:27
msgid ""
"**Iteration.** A ``QuerySet`` is iterable, and it executes its database "
"query the first time you iterate over it. For example, this will print the "
"headline of all entries in the database::"
msgstr ""
"**Итерация.** ``QuerySet`` -- это итератор, и при первом выполнении итерации "
"будет произведен запрос к базе данных. Например, этот код выводи заголовки "
"статей из базы данных::"

# ea019d80409d44c082b23bd353e993ae
#: ../../ref/models/querysets.txt:34
msgid ""
"**Slicing.** As explained in :ref:`limiting-querysets`, a ``QuerySet`` can "
"be sliced, using Python's array-slicing syntax. Slicing an unevaluated "
"``QuerySet`` usually returns another unevaluated ``QuerySet``, but Django "
"will execute the database query if you use the \"step\" parameter of slice "
"syntax, and will return a list. Slicing a ``QuerySet`` that has been "
"evaluated (partially or fully) also returns a list."
msgstr ""
"**Ограничение выборки.** Как описано в :ref:`limiting-querysets`, выборка "
"``QuerySet`` может быть ограничена, используя синтаксис срезов в Python. "
"Срез не вычисленного ``QuerySet`` обычно возвращает новый не вычисленный "
"``QuerySet``, но Django выполнит запрос, если будет указан шаг среза и "
"вернет список. Срез ``QuerySet``, который был вычислен(частично или "
"полностью), так же вернет список. "

# 99a34d84d70f4617ae3ff5339d628e09
#: ../../ref/models/querysets.txt:41
msgid ""
"**Pickling/Caching.** See the following section for details of what is "
"involved when `pickling QuerySets`_. The important thing for the purposes of "
"this section is that the results are read from the database."
msgstr ""
"**Pickling/кэширование.** Смотрите соответствующий раздел о `pickling "
"QuerySets`_. Основное замечание это то, что при этих операциях будет "
"выполнен запрос к базе данных."

# 872279b13af94aec98b1ca373cc0e01b
#: ../../ref/models/querysets.txt:45
msgid ""
"**repr().** A ``QuerySet`` is evaluated when you call ``repr()`` on it. This "
"is for convenience in the Python interactive interpreter, so you can "
"immediately see your results when using the API interactively."
msgstr ""
"**repr().** ``QuerySet`` будет вычислен при вызове ``repr()``. Это сделано "
"для удобства использования в консоли Python, вы можете сразу увидеть "
"результат работая с ``QuerySet`` в консоли."

# e36ca60edd4a42f8a1ae96714efea75f
#: ../../ref/models/querysets.txt:49
msgid ""
"**len().** A ``QuerySet`` is evaluated when you call ``len()`` on it. This, "
"as you might expect, returns the length of the result list."
msgstr ""
"**len().** ``QuerySet`` будет вычислен при выполнении ``len()`` над ним. Как "
"вы и ожидаете будет возвращено количество объектов в результате выборки."

# 4e7152e7b8a54da19602177972d20d79
#: ../../ref/models/querysets.txt:52
msgid ""
"Note: *Don't* use ``len()`` on ``QuerySet``\\s if all you want to do is "
"determine the number of records in the set. It's much more efficient to "
"handle a count at the database level, using SQL's ``SELECT COUNT(*)``, and "
"Django provides a ``count()`` method for precisely this reason. See ``count()"
"`` below."
msgstr ""
"Заметка: *Не используйте* ``len()`` с ``QuerySet`` если вам нужно узнать "
"только количество записей в выборке. Эффективнее использовать подсчет на "
"уровне базы данных, используя оператор SQL ``SELECT COUNT(*)``, и Django "
"предоставляет метод ``count()`` для этого. Смотрите ``count()`` ниже."

# f2ee6259dad84d99beaf8af8932b6442
#: ../../ref/models/querysets.txt:58
msgid ""
"**list().** Force evaluation of a ``QuerySet`` by calling ``list()`` on it. "
"For example::"
msgstr ""
"**list().** ``QuerySet`` будет вычислен при использовании ``list()`` над "
"ним. Например::"

# 0528f3a870d4462abb105f30ba474788
#: ../../ref/models/querysets.txt:63
msgid ""
"Be warned, though, that this could have a large memory overhead, because "
"Django will load each element of the list into memory. In contrast, "
"iterating over a ``QuerySet`` will take advantage of your database to load "
"data and instantiate objects only as you need them."
msgstr ""
"Будьте осторожны, так как при этом может быть использовано большое "
"количество памяти, т.к. Django загрузит каждый элемент списка в память. В "
"отличии от итерации по ``QuerySet``, при которой будут получены данные из "
"базы данных, но объекты будут созданы только при обращении к ним."

# 3e3a9035098f45a3a55134c68417686e
#: ../../ref/models/querysets.txt:68
msgid ""
"**bool().** Testing a ``QuerySet`` in a boolean context, such as using ``bool"
"()``, ``or``, ``and`` or an ``if`` statement, will cause the query to be "
"executed. If there is at least one result, the ``QuerySet`` is ``True``, "
"otherwise ``False``. For example::"
msgstr ""
"**bool().** При вычислении булевого значения ``QuerySet``, например "
"выполнении ``bool()``,  использовании с ``or``, ``and`` или ``if``. Если "
"``QuerySet`` содержит хотя бы один элемент, результат будет ``True``, иначе "
"-- ``False``. Например::"

# 64e106da47db49398858e730d80ca97e
#: ../../ref/models/querysets.txt:76
msgid ""
"Note: *Don't* use this if all you want to do is determine if at least one "
"result exists, and don't need the actual objects. It's more efficient to "
"use :meth:`exists() <QuerySet.exists>` (see below)."
msgstr ""
"Заметка: *не используйте* такой подходи, если необходимо всего лишь узнать "
"содержит ли результат запроса хотя бы один объект, и вам не нужен сам "
"результат. Эффективнее использовать метод :meth:`exists() <QuerySet.exists>` "
"(смотрите ниже)."

# 5b6bb2dcb2784b5cb020f75b74b30426
#: ../../ref/models/querysets.txt:83
msgid "Pickling QuerySets"
msgstr "Сериализация QuerySets"

# 0eed6a4a90c14a68ae30b17236be7a56
#: ../../ref/models/querysets.txt:85
msgid ""
"If you :mod:`pickle` a ``QuerySet``, this will force all the results to be "
"loaded into memory prior to pickling. Pickling is usually used as a "
"precursor to caching and when the cached queryset is reloaded, you want the "
"results to already be present and ready for use (reading from the database "
"can take some time, defeating the purpose of caching). This means that when "
"you unpickle a ``QuerySet``, it contains the results at the moment it was "
"pickled, rather than the results that are currently in the database."
msgstr ""
"Используя :mod:`pickle` для ``QuerySet``, будет выполнен запрос к базе "
"данных что бы загрузить данные в память для сериализации. Сериализация "
"обычно используется перед кешированием ``QuerySet`` или загрузкой из кеша, "
"необходимо что бы результат был доступен для использования сразу после "
"загрузки (чтение с базы данных занимает некоторое время, что свело бы всю "
"пользу кеширования к нулю). Это означает что после востановления "
"сериализованного ``QuerySet``, он будет содержать результат на момент "
"сериализации, а не тот, который хранится в базе данных на текущий момент."

# b306d47b2f0c4e4a89b8cc7e5977f198
#: ../../ref/models/querysets.txt:93
msgid ""
"If you only want to pickle the necessary information to recreate the "
"``QuerySet`` from the database at a later time, pickle the ``query`` "
"attribute of the ``QuerySet``. You can then recreate the original "
"``QuerySet`` (without any results loaded) using some code like this::"
msgstr ""
"Если вам необходимо сохранить запрос выполняемый ``QuerySet``, что бы "
"получить данные позже, сериализируйте атрибут ``query`` ``QuerySet``. Позже "
"вы можете воссоздать первоначальный ``QuerySet`` (без загрузки результата) "
"используя такой код::"

# a2e2110a529c4eaab208a5965f96bd47
#: ../../ref/models/querysets.txt:103
msgid ""
"The ``query`` attribute is an opaque object. It represents the internals of "
"the query construction and is not part of the public API. However, it is "
"safe (and fully supported) to pickle and unpickle the attribute's contents "
"as described here."
msgstr ""
"Атрибут ``query`` не является частью публичного API, и является частью "
"внутреннего механизма создания запросов. Однако, поддерживает использование "
"``pickle`` и ``unpickle`` как показано в примере выше."

# 5138d41bc219471096f24197c2187b31
#: ../../ref/models/querysets.txt:110
msgid ""
"Pickles of QuerySets are only valid for the version of Django that was used "
"to generate them. If you generate a pickle using Django version N, there is "
"no guarantee that pickle will be readable with Django version N+1. Pickles "
"should not be used as part of a long-term archival strategy."
msgstr ""
"Сериализация QuerySets возможна только для версии Django, которая была "
"использована при сохранении объекта. При сериализации объекта в версии "
"Django N, нет гарантии что, его можно будет восстановить в версии Django N"
"+1. Сериализация не должна быть использована для долговременного хранения "
"данных."

# 8908ae5fd52d421ca02f08f6bd313113
#: ../../ref/models/querysets.txt:119
msgid "QuerySet API"
msgstr "QuerySet API"

# e5857f02298d4e58bcdf7f6a439ff2c6
#: ../../ref/models/querysets.txt:121
msgid ""
"Though you usually won't create one manually — you'll go through a :class:"
"`~django.db.models.Manager` — here's the formal declaration of a "
"``QuerySet``:"
msgstr ""
"Хоть вам и не нужно создавать экземпляр ``QuerySet`` самостоятельно — он "
"создается через :class:`~django.db.models.Manager` — вот как это происходит:"

# 53e27b9c3de54a2fbd32c666d6c04e4d
#: ../../ref/models/querysets.txt:127
msgid ""
"Usually when you'll interact with a ``QuerySet`` you'll use it by :ref:"
"`chaining filters <chaining-filters>`. To make this work, most ``QuerySet`` "
"methods return new querysets. These methods are covered in detail later in "
"this section."
msgstr ""
"Обычно работа с ``QuerySet`` состоит в использовании :ref:`цепочек фильтров "
"<chaining-filters>`. Для этого большинство методов ``QuerySet`` возвращает "
"новый \"queryset\". Эти методы описаны далее."

# 018b3bc308034a708b2a93706cdd4981
#: ../../ref/models/querysets.txt:132
msgid ""
"The ``QuerySet`` class has two public attributes you can use for "
"introspection:"
msgstr "Класс ``QuerySet`` имеет два публичных атрибута:"

# 1158362f2a7041c090f146c7b5ce2225
#: ../../ref/models/querysets.txt:137
msgid ""
"``True`` if the ``QuerySet`` is ordered — i.e. has an :meth:`order_by()` "
"clause or a default ordering on the model. ``False`` otherwise."
msgstr ""
"``True`` если ``QuerySet`` использует сортировку — то есть использован "
"метод :meth:`order_by()` или модель содержит сортировку по-умолчанию. Иначе "
"``False``."

# d6fda43d8834411c9ce1bc9945085409
#: ../../ref/models/querysets.txt:143
msgid "The database that will be used if this query is executed now."
msgstr "База данных, которая будет использована для выполнения запроса."

# 8395b9df63654ec483d35040b7b08ab0
#: ../../ref/models/querysets.txt:147
msgid ""
"The ``query`` parameter to :class:`QuerySet` exists so that specialized "
"query subclasses such as :class:`~django.contrib.gis.db.models.GeoQuerySet` "
"can reconstruct internal query state. The value of the parameter is an "
"opaque representation of that query state and is not part of a public API. "
"To put it simply: if you need to ask, you don't need to use it."
msgstr ""
"Так же присутствует атрибут ``query`` класса :class:`QuerySet`. Подклассы :"
"class:`QuerySet`, такие как :class:`~django.contrib.gis.db.models."
"GeoQuerySet` могут переопределить структуру запроса используя этот аргумент. "
"Значение атрибута является скрытым представлением состояния запроса и не "
"является частью публичного API. Проще говоря, если вам нужно рассказывать о "
"нем, значит вам не стоит его использовать."

# cc754084a78646b4aed2e7a7dac0209e
#: ../../ref/models/querysets.txt:157
msgid "Methods that return new QuerySets"
msgstr "Методы, которые возвращают новый QuerySets"

# 8da92a93adba4090a21bda07d305cf9e
#: ../../ref/models/querysets.txt:159
msgid ""
"Django provides a range of ``QuerySet`` refinement methods that modify "
"either the types of results returned by the ``QuerySet`` or the way its SQL "
"query is executed."
msgstr ""
"Django предоставляет набор методов ``QuerySet``, которые изменяют "
"возвращаемый результат или выполнение SQL запроса."

# 19a92a74d013406e9d778a85e53da6a8
#: ../../ref/models/querysets.txt:164
msgid "filter"
msgstr "filter"

# 19caf98180104d82850aba702557d77d
#: ../../ref/models/querysets.txt:168
msgid ""
"Returns a new ``QuerySet`` containing objects that match the given lookup "
"parameters."
msgstr ""
"Возвращает новый ``QuerySet`` содержащий объекты отвечающие параметрам "
"фильтрации."

# 3c339c8df1204cfb9765ef08fa9589d9
#: ../../ref/models/querysets.txt:171
msgid ""
"The lookup parameters (``**kwargs``) should be in the format described in "
"`Field lookups`_ below. Multiple parameters are joined via ``AND`` in the "
"underlying SQL statement."
msgstr ""
"Параметры фильтрации (``**kwargs``) должны отвечать формату описанному в :"
"ref:`соответствующем разделе <field-lookups>`. Несколько параметров "
"объединяются оператором SQL ``AND``."

# 28aa203a3e1a435c96eb81c24c2e689c
#: ../../ref/models/querysets.txt:176
msgid "exclude"
msgstr "exclude"

# 5f4da46a6bdc421a8b7e893cd9da1d9b
#: ../../ref/models/querysets.txt:180
msgid ""
"Returns a new ``QuerySet`` containing objects that do *not* match the given "
"lookup parameters."
msgstr ""
"Возвращает новый ``QuerySet`` содержащий объекты *не* отвечающие параметрам "
"фильтрации."

# 6b1617a52446469eac978adbd18f4ead
#: ../../ref/models/querysets.txt:183
msgid ""
"The lookup parameters (``**kwargs``) should be in the format described in "
"`Field lookups`_ below. Multiple parameters are joined via ``AND`` in the "
"underlying SQL statement, and the whole thing is enclosed in a ``NOT()``."
msgstr ""
"Параметры фильтрации (``**kwargs``) должны отвечать формату описанному в :"
"ref:`соответствующем разделе <field-lookups>`. Несколько параметров "
"объединяются оператором SQL ``AND`` и все это замыкается оператором ``NOT()"
"``."

# 4cd38f0d4a4e4ed99da118a46297684f
#: ../../ref/models/querysets.txt:187
msgid ""
"This example excludes all entries whose ``pub_date`` is later than 2005-1-3 "
"AND whose ``headline`` is \"Hello\"::"
msgstr ""
"Этот пример исключает все записи с ``pub_date`` раньше 3.01.2005 И с "
"``headline`` равным \"Hello\"::"

# 89b7076d784e406bb11a99a9952fe728
# 0ad334998d0a41a7bb92d33376bc41eb
#: ../../ref/models/querysets.txt:192 ../../ref/models/querysets.txt:202
msgid "In SQL terms, that evaluates to::"
msgstr "Это эквивалентно запросу SQL::"

# 48b1915862b34bb89734a35d07fc6dc9
#: ../../ref/models/querysets.txt:197
msgid ""
"This example excludes all entries whose ``pub_date`` is later than 2005-1-3 "
"OR whose headline is \"Hello\"::"
msgstr ""
"Этот пример исключает все записи с ``pub_date``  раньше 3.01.2005 ИЛИ с "
"``headline`` равным \"Hello\"::"

# fef8b484158d43c09d30be0e0d5c42dd
#: ../../ref/models/querysets.txt:208
msgid "Note the second example is more restrictive."
msgstr ""
"Обратите внимание на второй пример, который больше ограничивает выборку."

# a2293c04f4024a0a9cb06fd346095b62
#: ../../ref/models/querysets.txt:211
msgid "annotate"
msgstr "annotate"

# 864b816187e342588c274fee7e4b1a21
#: ../../ref/models/querysets.txt:215
msgid ""
"Annotates each object in the ``QuerySet`` with the provided list of "
"aggregate values (averages, sums, etc) that have been computed over the "
"objects that are related to the objects in the ``QuerySet``. Each argument "
"to ``annotate()`` is an annotation that will be added to each object in the "
"``QuerySet`` that is returned."
msgstr ""
"\"Аннотирует\" каждый объект в ``QuerySet`` агрегированным значением "
"(среднее, суииа и др.), которое будет вычислено из данных связанных "
"объектов, которые связанны с объектами из``QuerySet``. Аргументы ``annotate()"
"`` это \"аннотация\", которая будет добавлена для каждого объекта "
"возвращаемого ``QuerySet``."

# 26a461f5b7274dc4a735bbb9fce4ba5a
# 4fe4f86b68b6440db1d38c51360ca1b7
#: ../../ref/models/querysets.txt:221 ../../ref/models/querysets.txt:1487
msgid ""
"The aggregation functions that are provided by Django are described in "
"`Aggregation Functions`_ below."
msgstr ""
"Функции агрегации описаны в :ref:`соответствующем разделе <aggregation-"
"functions>` ниже."

# 1294149d7e0f4999b399e546ea71cba2
#: ../../ref/models/querysets.txt:224
msgid ""
"Annotations specified using keyword arguments will use the keyword as the "
"alias for the annotation. Anonymous arguments will have an alias generated "
"for them based upon the name of the aggregate function and the model field "
"that is being aggregated."
msgstr ""
"Аннотация определенная именованными аргументами будет использовать имя "
"аргумента как название аннотации. Для позиционного аргумента будет "
"использовано имя созданное с названия функции агрегации и используемого поля "
"модели."

# bc4c877ba3e64badbbd94b6f46f45600
#: ../../ref/models/querysets.txt:229
msgid ""
"For example, if you were manipulating a list of blogs, you may want to "
"determine how many entries have been made in each blog::"
msgstr ""
"Например, получая список блогов, вы захотите получить так же и количество "
"записей в каждом блоге::"

# ccaaae1b195c44628f3315859b9bb718
#: ../../ref/models/querysets.txt:240
msgid ""
"The ``Blog`` model doesn't define an ``entry__count`` attribute by itself, "
"but by using a keyword argument to specify the aggregate function, you can "
"control the name of the annotation::"
msgstr ""
"Модель ``Blog`` не определяет атрибут ``entry__count``, используя "
"именованный аргументы вы можете переопределить название этого атрибута::"

# 06fa46ba1eb442a985458a09dd622220
# ab78c4ab8814417ba4e5cfdfb7472acc
#: ../../ref/models/querysets.txt:249 ../../ref/models/querysets.txt:1507
msgid ""
"For an in-depth discussion of aggregation, see :doc:`the topic guide on "
"Aggregation </topics/db/aggregation>`."
msgstr ""
"Для углубленного изучения агрегации смотрите :doc:`раздел про агрегацию </"
"topics/db/aggregation>`."

# 8389c0aa80de40d7823b3188341d69d1
#: ../../ref/models/querysets.txt:253
msgid "order_by"
msgstr "order_by"

# 4ce6382747e147e6b4c2c894014e9fdd
#: ../../ref/models/querysets.txt:257
msgid ""
"By default, results returned by a ``QuerySet`` are ordered by the ordering "
"tuple given by the ``ordering`` option in the model's ``Meta``. You can "
"override this on a per-``QuerySet`` basis by using the ``order_by`` method."
msgstr ""
"По-умолчанию, результат возвращаемый ``QuerySet``, отсортирован по полям "
"указанным в аргументе ``ordering`` класса ``Meta`` модели. Вы можете "
"переопределить сортировку используя метод ``order_by``."

# 9d69c8c34bb94cfb9f72158f427d9875
# 281b9774fa0d46529ee6c3c477956ff0
# bd3e7a153bd546bfa12e3e064720c459
# 7485308321904c3e86cc39e8910894cf
# a8749cbfd9144937b06db38a2f4ddbc1
# 4e7d2c4f218141e08e5318b264b7539d
# b66cc768e92f4b00854574e0f7a09126
# f684b5f11b1e4ce297dd1cbb0f927d5b
# 5216d8bec88c49baa9125fff2593910c
# 86cd4ddefdec4f10abdd2b4c12921b5c
# 90a5adbaedd94557b72e697a0a3902f7
# acc746828da84a32aec741c47c86164f
# 283c07c48d2b4ce4b00f12b3c1f0efd4
# eea33b1aeada471fbe719406b859dbb6
# 826d3125f3e54acebbcc86e452cdbe87
# cef75640dadb4cdab7865b789b2aed99
# 023748dbdf60440bac260fd3f787fe80
# 138ad121b8974c83997cf5ec1f4adadc
# 0382f09a65854e21892f5b81d95a1a53
# 6ae4ead3d03541bda278d48c33a12fdd
# cad7f2ad2c194100be061b225b5520ab
# 8436a2d96dbb4cf9a815ec6e24c1f0ba
# 5c2e58ba392c495cb905b93975f4f58f
# b2988e279ef34f8a8639ab324df8bc0e
# e033341134a04405a431b26b35ed31c1
#: ../../ref/models/querysets.txt:261 ../../ref/models/querysets.txt:449
#: ../../ref/models/querysets.txt:900 ../../ref/models/querysets.txt:969
#: ../../ref/models/querysets.txt:1027 ../../ref/models/querysets.txt:1397
#: ../../ref/models/querysets.txt:1423 ../../ref/models/querysets.txt:1683
#: ../../ref/models/querysets.txt:1708 ../../ref/models/querysets.txt:1733
#: ../../ref/models/querysets.txt:1754 ../../ref/models/querysets.txt:1827
#: ../../ref/models/querysets.txt:1863 ../../ref/models/querysets.txt:1881
#: ../../ref/models/querysets.txt:1902 ../../ref/models/querysets.txt:1923
#: ../../ref/models/querysets.txt:1944 ../../ref/models/querysets.txt:1964
#: ../../ref/models/querysets.txt:1982 ../../ref/models/querysets.txt:1999
#: ../../ref/models/querysets.txt:2022 ../../ref/models/querysets.txt:2048
#: ../../ref/models/querysets.txt:2064 ../../ref/models/querysets.txt:2091
#: ../../ref/models/querysets.txt:2115
msgid "Example::"
msgstr "Например::"

# 388c881a8f9746d4ae76faba940c86d3
#: ../../ref/models/querysets.txt:265
msgid ""
"The result above will be ordered by ``pub_date`` descending, then by "
"``headline`` ascending. The negative sign in front of ``\"-pub_date\"`` "
"indicates *descending* order. Ascending order is implied. To order randomly, "
"use ``\"?\"``, like so::"
msgstr ""
"Результат выше будет отсортирован в обратном порядке по полю ``pub_date``, "
"далее по полю ``headline``. Знак \"минус\" в ``\"-pub_date\"`` указывает на "
"\"нисходящую\" сортировку. Сортировка по возрастанию подразумевается по-"
"умолчанию. Что бы отсортировать случайно используйте ``\"?\"``, например::"

# c941f625bb1945f18e21bfb4770ddf97
#: ../../ref/models/querysets.txt:272
msgid ""
"Note: ``order_by('?')`` queries may be expensive and slow, depending on the "
"database backend you're using."
msgstr ""
"Заметка: запрос с ``order_by('?')`` может быть медленным и сильно нагружать "
"базу данных, зависит от типа базы данных, которую вы используете."

# 0feb041843864550815406170d7b62c2
#: ../../ref/models/querysets.txt:275
msgid ""
"To order by a field in a different model, use the same syntax as when you "
"are querying across model relations. That is, the name of the field, "
"followed by a double underscore (``__``), followed by the name of the field "
"in the new model, and so on for as many models as you want to join. For "
"example::"
msgstr ""
"Для сортировки по полю из другой модели, используйте синтаксис аналогичный "
"тому, который используется при фильтрации по полям связанной модели. То "
"есть, название поля, далее два нижних подчеркивания (``__``), и имя поля в "
"новой модели, и так далее. Например::"

# ca5d43c386634e059a7d177dc4a37ca4
#: ../../ref/models/querysets.txt:282
msgid ""
"If you try to order by a field that is a relation to another model, Django "
"will use the default ordering on the related model (or order by the related "
"model's primary key if there is no :attr:`Meta.ordering <django.db.models."
"Options.ordering>` specified. For example::"
msgstr ""
"Если вы пытаетесь отсортировать по полю, которое является связью на другую "
"модель, Django будет использовать сортировку по-умолчанию связанной модели "
"(или же сортировку по первичному ключу связанной модели если :attr:`Meta."
"ordering <django.db.models.Options.ordering>` не указан). Например::"

# 1e58dbcf06c84eeba4053165e5509788
#: ../../ref/models/querysets.txt:289
msgid "...is identical to::"
msgstr "...идентично::"

# de174d006189426bb977b1724a79c2b4
#: ../../ref/models/querysets.txt:293
msgid "...since the ``Blog`` model has no default ordering specified."
msgstr "...т.к. модель ``Blog`` не содержит сортировки по-умолчанию."

# 0b0c59c51c0841ac9e6768b430ecd9ee
#: ../../ref/models/querysets.txt:295
msgid ""
"Be cautious when ordering by fields in related models if you are also using :"
"meth:`distinct()`. See the note in :meth:`distinct` for an explanation of "
"how related model ordering can change the expected results."
msgstr ""
"Будьте осторожны используя по полю из связанной модели и метод :meth:"
"`distinct()`. Смотрите описание метода :meth:`distinct` для информации как "
"сортировка по связанной модели может повлиять на ожидаемый результат."

# e8c07900458743418c31612eda81153e
#: ../../ref/models/querysets.txt:299
msgid ""
"It is permissible to specify a multi-valued field to order the results by "
"(for example, a :class:`~django.db.models.ManyToManyField` field). Normally "
"this won't be a sensible thing to do and it's really an advanced usage "
"feature. However, if you know that your queryset's filtering or available "
"data implies that there will only be one ordering piece of data for each of "
"the main items you are selecting, the ordering may well be exactly what you "
"want to do. Use ordering on multi-valued fields with care and make sure the "
"results are what you expect."
msgstr ""
"Для сортировки можно указать поле с множеством значений (например, :class:"
"`~django.db.models.ManyToManyField` field). Как правильно, это не очень "
"разумно и является функционалом для продвинутых пользователей. Однако, если "
"вы уверены что фильтры \"queryset\" или существующие данные подразумеваю, "
"что для каждого объекта существует только одно значение, используемое для "
"сортировки -- вполне вероятно что в результате вы получите то, что и ожидали "
"получить. Используйте такую сортировку с осторожность и убедитесь что "
"результат отвечает вашим требованиям."

# dcef496eed3240d8b7da2df94461eddb
#: ../../ref/models/querysets.txt:308
msgid ""
"There's no way to specify whether ordering should be case sensitive. With "
"respect to case-sensitivity, Django will order results however your database "
"backend normally orders them."
msgstr ""
"Нет способа указать должна ли сортировка учитывать регистр. По этому Django "
"возвращает результат в таком порядке, в каком его вернула используемая база "
"данных."

# d072c96416f2478aa9c3ef185dc17d86
#: ../../ref/models/querysets.txt:312
msgid ""
"If you don't want any ordering to be applied to a query, not even the "
"default ordering, call :meth:`order_by()` with no parameters."
msgstr ""
"Если вы не хотите использовать сортировку, даже указанную по-умолчанию, "
"выполните метод :meth:`order_by()` без аргументов."

# 4272697bbb1f4191ac30eb51e396b2b1
#: ../../ref/models/querysets.txt:315
msgid ""
"You can tell if a query is ordered or not by checking the :attr:`.QuerySet."
"ordered` attribute, which will be ``True`` if the ``QuerySet`` has been "
"ordered in any way."
msgstr ""
"Вы можете определить используется сортировка или нет проверив атрибут :attr:"
"`.QuerySet.ordered`, который будет равен ``True``, если сортировка была "
"применена для ``QuerySet`` каким-либо образом."

# 7d4492b3420a46a3ba839688362008f5
#: ../../ref/models/querysets.txt:320
msgid "reverse"
msgstr "reverse"

# db69345ef8f94265988237ef355b596c
#: ../../ref/models/querysets.txt:324
msgid ""
"Use the ``reverse()`` method to reverse the order in which a queryset's "
"elements are returned. Calling ``reverse()`` a second time restores the "
"ordering back to the normal direction."
msgstr ""
"Используйте метод ``reverse()`` что бы изменить порядок сортировки на "
"обратный. Вызов ``reverse()`` повторно восстановит изначальную сортировку."

# 62d776aa895846de9f16c2f531915fe5
#: ../../ref/models/querysets.txt:328
msgid "To retrieve the ''last'' five items in a queryset, you could do this::"
msgstr "Что бы получить \"последние\" пять объектов выполните::"

# 55474eae90b641b8937651614d331aa1
#: ../../ref/models/querysets.txt:332
msgid ""
"Note that this is not quite the same as slicing from the end of a sequence "
"in Python. The above example will return the last item first, then the "
"penultimate item and so on. If we had a Python sequence and looked at ``seq"
"[-5:]``, we would see the fifth-last item first. Django doesn't support that "
"mode of access (slicing from the end), because it's not possible to do it "
"efficiently in SQL."
msgstr ""
"Обратите внимание, что это не совсем аналог среза Python с конца. Этот "
"пример вернет сначала последний элемент, потом предпоследний и так далее. "
"Используя список Python и сделав срез ``seq[-5:]``, мы увидим пятый элемент "
"с конца первым. Django не поддерживает подобное (срез с конца), т.к. нет "
"способа интерпретировать это в эфективный SQL."

# 1a84791f3be9472b8ccb5dbf8582be18
#: ../../ref/models/querysets.txt:339
msgid ""
"Also, note that ``reverse()`` should generally only be called on a "
"``QuerySet`` which has a defined ordering (e.g., when querying against a "
"model which defines a default ordering, or when using :meth:`order_by()`). "
"If no such ordering is defined for a given ``QuerySet``, calling ``reverse()"
"`` on it has no real effect (the ordering was undefined prior to calling "
"``reverse()``, and will remain undefined afterward)."
msgstr ""
"Метод ``reverse()`` должен быть вызван для ``QuerySet`` с определенной "
"сортировкой (например, при запросе модели с сортировкой по-умолчанию или "
"после использования метода :meth:`order_by()`). Если сортировка не "
"определена , вызов ``reverse()`` не будет иметь никакого эффекта."

# 57e6d48e5bd743858191f3211a9d3569
#: ../../ref/models/querysets.txt:347
msgid "distinct"
msgstr "distinct"

# f780c96158b04c1080f955a673f86a88
#: ../../ref/models/querysets.txt:351
msgid ""
"Returns a new ``QuerySet`` that uses ``SELECT DISTINCT`` in its SQL query. "
"This eliminates duplicate rows from the query results."
msgstr ""
"Возвращает ``QuerySet`` с добавленным ``SELECT DISTINCT`` в SQL запрос.  "
"Повторяющиеся записи будут исключены из результатов запроса."

# 72d0db17e03a42fcae1ab2c942ccd8d7
#: ../../ref/models/querysets.txt:354
msgid ""
"By default, a ``QuerySet`` will not eliminate duplicate rows. In practice, "
"this is rarely a problem, because simple queries such as ``Blog.objects.all()"
"`` don't introduce the possibility of duplicate result rows. However, if "
"your query spans multiple tables, it's possible to get duplicate results "
"when a ``QuerySet`` is evaluated. That's when you'd use ``distinct()``."
msgstr ""
"По-умолчанию, ``QuerySet`` не исключает повторяющиеся записи. На практике, "
"это редко является проблемой, простые запросы вроде ``Blog.objects.all()`` "
"не создают повторяющиеся записи. Однако, если запрос использует несколько "
"таблиц, возможно что ``QuerySet`` вернет повторяющиеся записи. И здесь вам "
"пригодится ``distinct()``."

# 85c89befa0194d3a905a5addc20971b9
#: ../../ref/models/querysets.txt:361
msgid ""
"Any fields used in an :meth:`order_by` call are included in the SQL "
"``SELECT`` columns. This can sometimes lead to unexpected results when used "
"in conjunction with ``distinct()``. If you order by fields from a related "
"model, those fields will be added to the selected columns and they may make "
"otherwise duplicate rows appear to be distinct. Since the extra columns "
"don't appear in the returned results (they are only there to support "
"ordering), it sometimes looks like non-distinct results are being returned."
msgstr ""
"Любое поле используемое в :meth:`order_by` будет добавлено в список "
"выбираемых колонок в части ``SELECT`` SQL запроса. Это может привести к "
"непредвиденным результатам если вы используете ``distinct()``. При "
"сортировке по колонке из связанной таблицы, эти колонки будет включены в "
"список выбираемых колонок, что может сделать одинаковые строки результата "
"уникальными. Т.к. эти дополнительные колонки не будет включены в результат"
"(они используются только для определения сортировки), будет выглядеть так, "
"вроде бы ``distinct()`` возвращает не уникальные элементы результатов."

# 27904ac42d8f4813ba4c11520f61cf48
#: ../../ref/models/querysets.txt:369
msgid ""
"Similarly, if you use a :meth:`values()` query to restrict the columns "
"selected, the columns used in any :meth:`order_by()` (or default model "
"ordering) will still be involved and may affect uniqueness of the results."
msgstr ""
"Так же, если вы используете метод :meth:`values()` что бы ограничить "
"выбираемые поля, поля из :meth:`order_by()` (или сортировки по-умолчанию "
"модели) так же будут включены и могут повлиять на уникальность результатов."

# b6960fd26547439c90f298d3376f6055
#: ../../ref/models/querysets.txt:373
msgid ""
"The moral here is that if you are using ``distinct()`` be careful about "
"ordering by related models. Similarly, when using ``distinct()`` and :meth:"
"`values()` together, be careful when ordering by fields not in the :meth:"
"`values()` call."
msgstr ""
"Мораль всего этого -- будьте осторожны при использовании ``distinct()`` и "
"сортировки по полям из связанных моделей. Так же, при использовании "
"``distinct()`` и :meth:`values()` вместе, будьте осторожны сортируя по полям "
"не включенным в :meth:`values()`."

# 2c62b3d966954c679352032d48778072
#: ../../ref/models/querysets.txt:380
msgid ""
"As of Django 1.4, you can pass positional arguments (``*fields``) in order "
"to specify the names of fields to which the ``DISTINCT`` should apply. This "
"translates to a ``SELECT DISTINCT ON`` SQL query."
msgstr ""
"С Django 1.4, можно передать позиционные аргументы (``*fields``), указывая "
"какие поля должны использоваться с ``DISTINCT``. Все это будет преобразовано "
"в ``SELECT DISTINCT ON`` SQL запрос."

# 34765e81d5274c3f8b717f2d80f1ffbb
#: ../../ref/models/querysets.txt:384
msgid ""
"Here's the difference. For a normal ``distinct()`` call, the database "
"compares *each* field in each row when determining which rows are distinct. "
"For a ``distinct()`` call with specified field names, the database will only "
"compare the specified field names."
msgstr ""
"Вот в чем разница. При обычном вызове ``distinct()``, база данных сравнивает "
"*каждое* поле каждой строки для определения уникальности записи. При "
"передаче полей в ``distinct()``, база данных будет сравнивать только "
"указанные поля."

# a39ab3008bfc4a6b8235716f206b45cd
#: ../../ref/models/querysets.txt:390
msgid "This ability to specify field names is only available in PostgreSQL."
msgstr "Возможность указывать поля доступна только в PostgreSQL."

# 9eb9408232844162b66ce5cef3025bc0
#: ../../ref/models/querysets.txt:393
msgid ""
"When you specify field names, you *must* provide an ``order_by()`` in the "
"QuerySet, and the fields in ``order_by()`` must start with the fields in "
"``distinct()``, in the same order."
msgstr ""
"Если вы указываете поля, вы *должны* определить так же и ``order_by()``, и "
"поля в ``order_by()`` должны начинаться с полей указанных в ``distinct()``, "
"в том же порядке."

# 468448fbce544d7c9d8fbea48c3d1025
#: ../../ref/models/querysets.txt:397
msgid ""
"For example, ``SELECT DISTINCT ON (a)`` gives you the first row for each "
"value in column ``a``. If you don't specify an order, you'll get some "
"arbitrary row."
msgstr ""
"Например, ``SELECT DISTINCT ON (a)`` возвращает вам первую запись для "
"каждого уникального значения колонки ``a``. Если вы не определите "
"сортировку, будут возвращены случайные записи для каждого уникального "
"значения."

# 12ffb7971cd54ddb86243f6be88eba97
# a1594fb3f3764aa29bb1251fe9792b80
# 23387ea901374de5b1c31ae9b2f22556
# b327b9678e274966b4d91cac79c5d6e1
#: ../../ref/models/querysets.txt:401 ../../ref/models/querysets.txt:580
#: ../../ref/models/querysets.txt:609 ../../ref/models/querysets.txt:1657
msgid "Examples::"
msgstr "Например::"

# af5851511053417684d907a9326d9023
#: ../../ref/models/querysets.txt:422
msgid "values"
msgstr "values"

# 49fb7386a28047a38968129991eba91f
#: ../../ref/models/querysets.txt:426
msgid ""
"Returns a ``ValuesQuerySet`` — a ``QuerySet`` subclass that returns "
"dictionaries when used as an iterable, rather than model-instance objects."
msgstr ""
"Возвращает ``ValuesQuerySet`` — подкласс ``QuerySet``, который возвращает "
"словари с результатом вместо объектов моделей."

# cb5947d3cddb4e288c8bcaf10bd28e35
#: ../../ref/models/querysets.txt:429
msgid ""
"Each of those dictionaries represents an object, with the keys corresponding "
"to the attribute names of model objects."
msgstr ""
"Каждый словарь представляет объект, ключи которого соответствуют полям "
"модели."

# ac94864efe7e413881125d12d960d3f1
#: ../../ref/models/querysets.txt:432
msgid ""
"This example compares the dictionaries of ``values()`` with the normal model "
"objects::"
msgstr ""
"Этот пример показывает разницу между результатом возвращаемым ``values()`` и "
"объектами модели::"

# 6a895173a763438790f5974f0d8306a9
#: ../../ref/models/querysets.txt:443
msgid ""
"The ``values()`` method takes optional positional arguments, ``*fields``, "
"which specify field names to which the ``SELECT`` should be limited. If you "
"specify the fields, each dictionary will contain only the field keys/values "
"for the fields you specify. If you don't specify the fields, each dictionary "
"will contain a key and value for every field in the database table."
msgstr ""
"Метод ``values()`` принимает дополнительные позиционные аргументы, "
"``*fields``, которые определяют какие поля будут получены через ``SELECT``. "
"Каждый словарь будет содержать только указанные поля. Если поля не указаны, "
"каждый словарь будет содержать все данные из таблицы в базе данных."

# e78f74bf322a45fbb3d7aadac36bf87a
#: ../../ref/models/querysets.txt:456
msgid "A few subtleties that are worth mentioning:"
msgstr "Следует упомянуть несколько тонкостей:"

# e4db51fd4b5e405383e764d1d9ea1047
#: ../../ref/models/querysets.txt:458
msgid ""
"If you have a field called ``foo`` that is a :class:`~django.db.models."
"ForeignKey`, the default ``values()`` call will return a dictionary key "
"called ``foo_id``, since this is the name of the hidden model attribute that "
"stores the actual value (the ``foo`` attribute refers to the related model). "
"When you are calling ``values()`` and passing in field names, you can pass "
"in either ``foo`` or ``foo_id`` and you will get back the same thing (the "
"dictionary key will match the field name you passed in)."
msgstr ""
"Если модель содержит поле ``foo`` типа :class:`~django.db.models."
"ForeignKey`, по-умолчанию ``values()`` вернет словарь с ключом ``foo_id``, т."
"к. это названия скрытого поля, которое на самом деле хранит значение "
"(атрибут ``foo`` отображает связанную модель). Вызывая ``values()`` вы "
"можете передать ``foo`` или ``foo_id`` и получите тот же результат (ключ "
"словаря будет равен переданному значению)."

# 3103ac6bd6f34454baf5fc60b4160233
# c5738a85fd984c2fa84d5a69a91a2452
# d9dec8adfce64fdcb8581558ebfde631
# c1089638b0ad4386bd46c32864e5fcac
#: ../../ref/models/querysets.txt:467 ../../ref/models/querysets.txt:1008
#: ../../ref/models/querysets.txt:1166 ../../ref/models/querysets.txt:1184
msgid "For example::"
msgstr "Например::"

# 51b23e8160934f9c82dda9f6b81f91a3
#: ../../ref/models/querysets.txt:478
msgid ""
"When using ``values()`` together with :meth:`distinct()`, be aware that "
"ordering can affect the results. See the note in :meth:`distinct` for "
"details."
msgstr ""
"Используя ``values()`` с :meth:`distinct()`, обратите внимание, что "
"сортировка может повлиять на результат. Подробности в описании метода :meth:"
"`distinct`."

# 1708b68a0b5d4d5b870cc5907d019f08
#: ../../ref/models/querysets.txt:482
msgid ""
"If you use a ``values()`` clause after an :meth:`extra()` call, any fields "
"defined by a ``select`` argument in the :meth:`extra()` must be explicitly "
"included in the ``values()`` call. Any :meth:`extra()` call made after a "
"``values()`` call will have its extra selected fields ignored."
msgstr ""
"Используя ``values()`` после вызова :meth:`extra()`, добавьте в ``values()`` "
"все поля указанные в аргументе ``select`` использованном при вызове :meth:"
"`extra()`. При вызове :meth:`extra()` после ``values()`` все указанные "
"дополнительные поля будут проигнорированы."

# 1015bea283fc4547a2248e39469a320e
#: ../../ref/models/querysets.txt:488
msgid ""
"A ``ValuesQuerySet`` is useful when you know you're only going to need "
"values from a small number of the available fields and you won't need the "
"functionality of a model instance object. It's more efficient to select only "
"the fields you need to use."
msgstr ""
"``ValuesQuerySet`` полезен, если вам нужны только данные некоторых полей и "
"не нужен функционал объектов моделей. Более эффективно получить только "
"необходимые данные."

# e0be586998f34c22a49475475a9f6309
#: ../../ref/models/querysets.txt:493
msgid ""
"Finally, note a ``ValuesQuerySet`` is a subclass of ``QuerySet``, so it has "
"all methods of ``QuerySet``. You can call ``filter()`` on it, or ``order_by()"
"``, or whatever. Yes, that means these two calls are identical::"
msgstr ""
"Заметим, что ``ValuesQuerySet`` подкласс ``QuerySet``, и содержит все методы "
"``QuerySet``. Вы можете вызвать ``filter()`` или ``order_by()``, или любой "
"другой метод. Это означает, что эти два куска кода идентичны::"

# d65a646eb811447a9b6958db3e21d60b
#: ../../ref/models/querysets.txt:500
msgid ""
"The people who made Django prefer to put all the SQL-affecting methods "
"first, followed (optionally) by any output-affecting methods (such as "
"``values()``), but it doesn't really matter. This is your chance to really "
"flaunt your individualism."
msgstr ""
"Разработчики Django предпочитают использовать в первую очередь методы "
"влияющие на SQL-запрос, далее методы влияющие на вывод данных (такие как "
"``values()``), хотя это и не имеет значения. Это ваш шанс проявить "
"индивидуальность."

# 5ea1881a0c8f40babf116cb2396a30ee
#: ../../ref/models/querysets.txt:507
msgid ""
"The ``values()`` method previously did not return anything for :class:"
"`~django.db.models.ManyToManyField` attributes and would raise an error if "
"you tried to pass this type of field to it."
msgstr ""
"В предыдущих версиях Django метод ``values()`` не возвращал ничего для :"
"class:`~django.db.models.ManyToManyField` и вызывал исключение при попытке "
"указать такое поле в аргументах ``values()``."

# f5eb1490873243d494cb93a58ebf85e9
#: ../../ref/models/querysets.txt:511
msgid ""
"This restriction has been lifted, and you can now also refer to fields on "
"related models with reverse relations through ``OneToOneField``, "
"``ForeignKey`` and ``ManyToManyField`` attributes::"
msgstr ""
"Это ограничение было убрано, и теперь вы можете обратиться к обратно "
"связанным моделям через поля ``OneToOneField``, ``ForeignKey`` и "
"``ManyToManyField``::"

# 7557f8612db24cc198d2c6484189d537
#: ../../ref/models/querysets.txt:521
msgid ""
"Because :class:`~django.db.models.ManyToManyField` attributes and reverse "
"relations can have multiple related rows, including these can have a "
"multiplier effect on the size of your result set. This will be especially "
"pronounced if you include multiple such fields in your ``values()`` query, "
"in which case all possible combinations will be returned."
msgstr ""
"Так как :class:`~django.db.models.ManyToManyField` и обратная связь может "
"содержать множество связанных записей, выбор этих данных может многократно "
"увеличить размер возвращаемых данных. Это будет особенно заметно, если вы "
"включите несколько таких полей в ``values()``, в таком случае будут "
"возвращены все возможные комбинации значений."

# 579aab5752cb438d80b3c2f226e36cb8
#: ../../ref/models/querysets.txt:528
msgid "values_list"
msgstr "values_list"

# 97303ab27631499da3fc7e3e9328ecf6
#: ../../ref/models/querysets.txt:532
msgid ""
"This is similar to ``values()`` except that instead of returning "
"dictionaries, it returns tuples when iterated over. Each tuple contains the "
"value from the respective field passed into the ``values_list()`` call — so "
"the first item is the first field, etc. For example::"
msgstr ""
"Аналогичен ``values()``, но вместо словаря возвращает кортеж. Каждый кортеж "
"содержит значения полей указанных при вызове ``values_list()`` в том же "
"порядке — первый элемент значение первого поля и т.д. Например::"

# ccb1350a9f4141cfa5cad5c849fdb5d5
#: ../../ref/models/querysets.txt:540
msgid ""
"If you only pass in a single field, you can also pass in the ``flat`` "
"parameter. If ``True``, this will mean the returned results are single "
"values, rather than one-tuples. An example should make the difference "
"clearer::"
msgstr ""
"Если вы указали одно поле, можете указать аргумент ``flat``. При ``True``, "
"каждая запись будет возвращена как отдельное значение, а не одноэлементный "
"кортеж. Например::"

# 0b0afc3c5ba6418da21a36cf1b7de005
#: ../../ref/models/querysets.txt:550
msgid "It is an error to pass in ``flat`` when there is more than one field."
msgstr ""
"Если вы указали больше одного поля, использование ``flat`` будет ошибкой."

# a90ae6bd840642f39a79a2a6b105be21
#: ../../ref/models/querysets.txt:552
msgid ""
"If you don't pass any values to ``values_list()``, it will return all the "
"fields in the model, in the order they were declared."
msgstr ""
"Если поля не будут указаны при вызове ``values_list()``, будут возвращены "
"все поля модели в порядке, в котором они были объявлены."

# 357b1daa9bcd4dea9ec83499a76f89d3
#: ../../ref/models/querysets.txt:556
msgid "dates"
msgstr "dates"

# 39c9d32ce13e4247960fb10a992f4943
#: ../../ref/models/querysets.txt:560
msgid ""
"Returns a ``DateQuerySet`` — a ``QuerySet`` that evaluates to a list of "
"``datetime.datetime`` objects representing all available dates of a "
"particular kind within the contents of the ``QuerySet``."
msgstr ""
"Возвращает ``DateQuerySet`` — ``QuerySet`` возвращающий список объектов "
"``datetime.datetime`` отображающих возможные даты в контексте ``QuerySet``."

# 4c676dfb14b54e969e866cc4eb76811d
#: ../../ref/models/querysets.txt:564
msgid ""
"``field`` should be the name of a ``DateField`` or ``DateTimeField`` of your "
"model."
msgstr ""
"``field`` -- название поля модели типа ``DateField`` или ``DateTimeField``."

# 7a8b45479ff14c29a5adbde580e97125
#: ../../ref/models/querysets.txt:567
msgid ""
"``kind`` should be either ``\"year\"``, ``\"month\"`` or ``\"day\"``. Each "
"``datetime.datetime`` object in the result list is \"truncated\" to the "
"given ``type``."
msgstr ""
"``kind`` должен быть ``\"year\"``, ``\"month\"`` или ``\"day\"``. Каждый "
"объект ``datetime.datetime`` результат \"урезания\" данных в соответствии с "
"указанным ``kind``."

# af481c348edd403dbe26e806860a8cc2
#: ../../ref/models/querysets.txt:571
msgid "``\"year\"`` returns a list of all distinct year values for the field."
msgstr ""
"``\"year\"`` возвращает список уникальных значений года из всех дат "
"указанного поля."

# 4045d630ba0d47af887dd450631e3549
#: ../../ref/models/querysets.txt:572
msgid ""
"``\"month\"`` returns a list of all distinct year/month values for the field."
msgstr ""
"``\"month\"`` возвращает список уникальных значений года/месяца из всех дат "
"указанного поля."

# b3c5624dc54c4b8fa4ba0682ea138ef7
#: ../../ref/models/querysets.txt:574
msgid ""
"``\"day\"`` returns a list of all distinct year/month/day values for the "
"field."
msgstr ""
"``\"day\"`` возвращает список уникальных значений года/месяца/дня из всех "
"дат указанного поля."

# 500c765dc01140819e5dd68e8ac42e59
#: ../../ref/models/querysets.txt:577
msgid ""
"``order``, which defaults to ``'ASC'``, should be either ``'ASC'`` or "
"``'DESC'``. This specifies how to order the results."
msgstr ""
"``order`` -- сортировка значений. По-умолчанию``'ASC'``, должна быть  "
"``'ASC'`` или ``'DESC'``."

# 83a5dbf9c43e4918b590f89ffd646df3
#: ../../ref/models/querysets.txt:595
msgid ""
"When :doc:`time zone support </topics/i18n/timezones>` is enabled, Django "
"uses UTC in the database connection, which means the aggregation is "
"performed in UTC. This is a known limitation of the current implementation."
msgstr ""
"Если включена :doc:`поддержка временных зон </topics/i18n/timezones>`, "
"Django будет использовать UTC при подключении к базе данных, то есть "
"агрегация выполняется в UTC. Это ограничение текущей реализации."

# 11d5eb8529f54db2a837985ac116e865
#: ../../ref/models/querysets.txt:600
msgid "none"
msgstr "none"

# 671567eab87f48ef92ef488392402340
#: ../../ref/models/querysets.txt:604
msgid ""
"Returns an ``EmptyQuerySet`` — a ``QuerySet`` subclass that always evaluates "
"to an empty list. This can be used in cases where you know that you should "
"return an empty result set and your caller is expecting a ``QuerySet`` "
"object (instead of returning an empty list, for example.)"
msgstr ""
"Возвращает ``EmptyQuerySet`` — подкласс ``QuerySet`` который всегда "
"возвращает пустой список. Полезен, если необходимо вернуть пустой результат, "
"но код ожидает объект ``QuerySet`` (вместо того, что бы возвращать пустой "
"список, например.)"

# a2890d41c32d43eb9432fc98eb1227b8
#: ../../ref/models/querysets.txt:615
msgid "all"
msgstr "all"

# 572293992d5a4f12b4507aaa97e801e3
#: ../../ref/models/querysets.txt:619
msgid ""
"Returns a *copy* of the current ``QuerySet`` (or ``QuerySet`` subclass).  "
"This can be useful in situations where you might want to pass in either a "
"model manager or a ``QuerySet`` and do further filtering on the result. "
"After calling ``all()`` on either object, you'll definitely have a "
"``QuerySet`` to work with."
msgstr ""
"Возвращает *копию* текущего ``QuerySet`` (или подкласса ``QuerySet``).  Это "
"может быть полезно, если вам нужно передать в функцию менеджер модели или "
"``QuerySet`` и выполнить дальнейшую фильтрацию результата. После вызова ``all"
"()`` вы получите копию ``QuerySet``, которую можно передать в функцию не "
"боясь, что она изменит текущий ``QuerySet``."

# c49b527e87f04a66adda31c1a3327a74
#: ../../ref/models/querysets.txt:625
msgid "select_related"
msgstr "select_related"

# 2dbb0260148b4133baccddfbf37f18eb
#: ../../ref/models/querysets.txt:629
msgid ""
"Returns a ``QuerySet`` that will automatically \"follow\" foreign-key "
"relationships, selecting that additional related-object data when it "
"executes its query. This is a performance booster which results in "
"(sometimes much) larger queries but means later use of foreign-key "
"relationships won't require database queries."
msgstr ""
"Возвращает ``QuerySet`` который автоматически включает в выборку данные "
"связанных объектов при выполнении запроса. Повышает производительность, но "
"увеличивает(иногда значительно) объем получаемых данных, в результате, при "
"доступе к связанным объектам через модель, не потребуются дополнительные "
"запросы в базу данных."

# f4caa3922bd7491d99841d4199f56b42
#: ../../ref/models/querysets.txt:635
msgid ""
"The following examples illustrate the difference between plain lookups and "
"``select_related()`` lookups. Here's standard lookup::"
msgstr ""
"Этот пример отображает разницу между обычной выборкой и с ``select_related()"
"``. Обычная выборка::"

# b563008653c34aee865d8f3f69ed0969
#: ../../ref/models/querysets.txt:644
msgid "And here's ``select_related`` lookup::"
msgstr "И с ``select_related``::"

# e3f6354104e0493a9a828ef9334fdeea
#: ../../ref/models/querysets.txt:653
msgid ""
"``select_related()`` follows foreign keys as far as possible. If you have "
"the following models::"
msgstr ""
"``select_related()`` выбирает связанные объекты максимально доступной "
"вложенности. Например, у нас есть такие модели::"

# 26ababe5af374ddab78c493810a3d259
#: ../../ref/models/querysets.txt:668
msgid ""
"...then a call to ``Book.objects.select_related().get(id=4)`` will cache the "
"related ``Person`` *and* the related ``City``::"
msgstr ""
"...тогда вызов ``Book.objects.select_related().get(id=4)`` получит данные "
"связанных ``Person`` *и* связанных ``City``::"

# c42207566e5848fea57f695f19c1ce3c
#: ../../ref/models/querysets.txt:679
msgid ""
"Note that, by default, ``select_related()`` does not follow foreign keys "
"that have ``null=True``."
msgstr ""
"Заметим, по-умолчанию ``select_related()`` не учитывает внешние ключи с "
"``null=True``."

# 1f46130a9ade4bb688f2110f4ee5aa5c
#: ../../ref/models/querysets.txt:682
msgid ""
"Usually, using ``select_related()`` can vastly improve performance because "
"your app can avoid many database calls. However, in situations with deeply "
"nested sets of relationships ``select_related()`` can sometimes end up "
"following \"too many\" relations, and can generate queries so large that "
"they end up being slow."
msgstr ""
"Обычно, использование ``select_related()`` может значительно увеличить "
"производительность т.к. ваше приложение не будет выполнять дополнительные "
"запросы при доступе к связанным объектам. Однако, в случае глубокой "
"вложенности связанных объектов, ``select_related()`` может привести к "
"\"обработке\" слишком большого количества связей, и создаст в конечном итоге "
"сложный и значительно медленный запрос."

# 7a34ea2b05974bf9be483f2e7478a54c
#: ../../ref/models/querysets.txt:687
msgid ""
"In these situations, you can use the ``depth`` argument to ``select_related()"
"`` to control how many \"levels\" of relations ``select_related()`` will "
"actually follow::"
msgstr ""
"В таком случае можно использовать аргумент ``depth`` при вызове "
"``select_related()`` контролируя глубину вложенности получения связанных "
"объектов::"

# 79ff5ffc434c4030ab8a94299c91e338
#: ../../ref/models/querysets.txt:695
msgid ""
"Sometimes you only want to access specific models that are related to your "
"root model, not all of the related models. In these cases, you can pass the "
"related field names to ``select_related()`` and it will only follow those "
"relations. You can even do this for models that are more than one relation "
"away by separating the field names with double underscores, just as for "
"filters. For example, if you have this model::"
msgstr ""
"Иногда вам понадобятся только определенные связанные модели. В таком случае, "
"вы можете указать имена внешних ключей при вызове ``select_related()``, "
"только они будут учитываться при выборке связанных объектов. Вы можете "
"определять связанные модели любой вложенности, разделяя имена внешних ключей "
"двойным нижним подчеркиванием. Например, у вас есть модель::"

# ec74245305334c98ab756c026129189b
#: ../../ref/models/querysets.txt:712
msgid ""
"...and you only needed to work with the ``room`` and ``subject`` attributes, "
"you could write this::"
msgstr "...и вам нужны только  ``room`` и ``subject``::"

# 6e7d6366f5524863bcfd865a431a0256
#: ../../ref/models/querysets.txt:717
msgid "This is also valid::"
msgstr "Так же можно::"

# 840699198ee1475c9ffdf250ab771ac7
#: ../../ref/models/querysets.txt:721
msgid "...and would also pull in the ``building`` relation."
msgstr "...в результате будет так же использована связь ``building``."

# 62befa03faea415d880cf52741f205fe
#: ../../ref/models/querysets.txt:723
msgid ""
"You can refer to any :class:`~django.db.models.ForeignKey` or :class:"
"`~django.db.models.OneToOneField` relation in the list of fields passed to "
"``select_related()``. This includes foreign keys that have ``null=True`` "
"(which are omitted in a no-parameter ``select_related()`` call). It's an "
"error to use both a list of fields and the ``depth`` parameter in the same "
"``select_related()`` call; they are conflicting options."
msgstr ""
"Можно указать любые :class:`~django.db.models.ForeignKey` или :class:"
"`~django.db.models.OneToOneField` связи при вызове ``select_related()``. "
"Принимаются только внешние ключи с ``null=True`` (которые будет использова "
"ны при вызове ``select_related()`` без аргументов). Нельзя использовать "
"аргумент ``depth`` и список полей вместе, эти параметры несовместимы."

# f0695e8976554521ad36bd94ee905e2b
#: ../../ref/models/querysets.txt:732
msgid ""
"You can also refer to the reverse direction of a :class:`~django.db.models."
"OneToOneField` in the list of fields passed to ``select_related`` — that is, "
"you can traverse a :class:`~django.db.models.OneToOneField` back to the "
"object on which the field is defined. Instead of specifying the field name, "
"use the :attr:`related_name <django.db.models.ForeignKey.related_name>` for "
"the field on the related object."
msgstr ""
"Вы можете указать обратную связь для :class:`~django.db.models."
"OneToOneField` в списке полей — то есть, вы можете получить объект в котором "
"определено поле :class:`~django.db.models.OneToOneField`. Вместо названия "
"поля используйте значение параметра :attr:`related_name <django.db.models."
"ForeignKey.related_name>`."

# 0cd784213a2c4dafad8091eada5a4bc7
#: ../../ref/models/querysets.txt:739
msgid ""
"A :class:`~django.db.models.OneToOneField` is not traversed in the reverse "
"direction if you are performing a depth-based ``select_related()`` call."
msgstr ""
"Обратная связь для :class:`~django.db.models.OneToOneField` не учитывается "
"при вызове ``select_related()``, если она явно не указана в аргументах."

# c88e911f60014854a17560028894701a
#: ../../ref/models/querysets.txt:743
msgid "prefetch_related"
msgstr "prefetch_related"

# 549d0360b83f45e5b22af301ab7d707c
#: ../../ref/models/querysets.txt:749
msgid ""
"Returns a ``QuerySet`` that will automatically retrieve, in a single batch, "
"related objects for each of the specified lookups."
msgstr ""
"Возвращает ``QuerySet``, который получает \"за один подход\" связанные "
"объекты для каждого из указанных параметра поиска."

# 9f0ccc75a72444f0afeb9cd747791de4
#: ../../ref/models/querysets.txt:752
msgid ""
"This has a similar purpose to ``select_related``, in that both are designed "
"to stop the deluge of database queries that is caused by accessing related "
"objects, but the strategy is quite different."
msgstr ""
"Смысл такой же как и у ``select_related``, избежать нарастающего количества "
"запросов при обращении к связанным объектам, но смысл работы немного другой."

# 9c1bd26fc3c1409caeb9d73b158aec1a
#: ../../ref/models/querysets.txt:756
msgid ""
"``select_related`` works by creating a SQL join and including the fields of "
"the related object in the SELECT statement. For this reason, "
"``select_related`` gets the related objects in the same database query. "
"However, to avoid the much larger result set that would result from joining "
"across a 'many' relationship, ``select_related`` is limited to single-valued "
"relationships - foreign key and one-to-one."
msgstr ""
"``select_related`` создает запрос SQL объединяющий связанные таблицы и "
"включая дополнительные поля в SELECT. По этой причине, ``select_related`` "
"получает связанные объекты в том же запросе. Однако, что бы избежать "
"большого количества возвращаемых данных при обработке \"множественных\" "
"связей, ``select_related`` работает только со связями возвращающими один "
"объект - внешний ключ и связь один-к-одному."

# d3ca3301d5f04a74adc64b849150dec0
#: ../../ref/models/querysets.txt:763
msgid ""
"``prefetch_related``, on the other hand, does a separate lookup for each "
"relationship, and does the 'joining' in Python. This allows it to prefetch "
"many-to-many and many-to-one objects, which cannot be done using "
"``select_related``, in addition to the foreign key and one-to-one "
"relationships that are supported by ``select_related``. It also supports "
"prefetching of :class:`~django.contrib.contenttypes.generic.GenericRelation` "
"and :class:`~django.contrib.contenttypes.generic.GenericForeignKey`."
msgstr ""
"``prefetch_related``, с другой стороны, выбирает данные для каждой связи "
"отдельно, и выполняет \"объединение\" на уровне Python. Благодаря этому "
"могут быть обработаны связи многое-ко-многим и многое-к-одному, которые не "
"обрабатывает ``select_related``, в том числе и внешние ключи и связь один-к-"
"одному поддерживаемые ``select_related``. Так же поддерживается "
"предварительная выборка для :class:`~django.contrib.contenttypes.generic."
"GenericRelation` и :class:`~django.contrib.contenttypes.generic."
"GenericForeignKey`."

# 008a1928e12d487aa0ede700f59f8cb2
#: ../../ref/models/querysets.txt:771
msgid "For example, suppose you have these models::"
msgstr "Например, у вас есть две модели::"

# 35465e7b81454c2e9e1e6418666353d8
#: ../../ref/models/querysets.txt:784
msgid "and run this code::"
msgstr "и выполняется такой код::"

# 89f80a351e3e47c7a308985aa0797fbb
#: ../../ref/models/querysets.txt:789
msgid ""
"The problem with this code is that it will run a query on the Toppings table "
"for **every** item in the Pizza ``QuerySet``.  Using ``prefetch_related``, "
"this can be reduced to two:"
msgstr ""
"Проблема в том, что будет выполнен запрос к таблице ``Toppings`` для "
"**каждого** объекта ``Pizza`` в ``QuerySet``. Используя "
"``prefetch_related``, количество запросов можно сократить до двух:"

# 4d10c7e6aa5f4733bcee31330f527481
#: ../../ref/models/querysets.txt:795
msgid ""
"All the relevant toppings will be fetched in a single query, and used to "
"make ``QuerySets`` that have a pre-filled cache of the relevant results. "
"These ``QuerySets`` are then used in the ``self.toppings.all()`` calls."
msgstr ""
"Все соответствующие начинки(toppings) будут получены одним запросом, что бы "
"создать ``QuerySets``, который имеет предварительно заполненный кэш "
"соответствующих результатов. Этот ``QuerySets`` будет использован при вызове "
"``self.toppings.all()``."

# 76e875e80bfd48e7b2cde3ab9b8111ef
#: ../../ref/models/querysets.txt:799
msgid ""
"The additional queries are executed after the QuerySet has begun to be "
"evaluated and the primary query has been executed. Note that the result "
"cache of the primary QuerySet and all specified related objects will then be "
"fully loaded into memory, which is often avoided in other cases - even after "
"a query has been executed in the database, QuerySet normally tries to make "
"uses of chunking between the database to avoid loading all objects into "
"memory before you need them."
msgstr ""
"Дополнительные запросы будут выполнены при вычислении QuerySet и выполнении "
"основного запроса. Заметим, результат выполнения QuerySet будет \"закэширован"
"\" и все связанные объекты будет загружены в память, что обычно избегается в "
"других случаях - даже после того, как запрос в базу данных был выполнен, "
"QuerySet старается не загружать все данные в память пока они вам не "
"понадобятся."

# 3a4a1d81d12140e09e5217ecdbe41461
#: ../../ref/models/querysets.txt:807
msgid ""
"Also remember that, as always with QuerySets, any subsequent chained methods "
"which imply a different database query will ignore previously cached "
"results, and retrieve data using a fresh database query. So, if you write "
"the following:"
msgstr ""
"Помните, любой последующий метод, который изменяет запрос, проигнорирует "
"ранее загруженный кэш и получит данные выполнив новый запрос. Итак, "
"используя такой код:"

# cc5a38e36ca249b498d95ff562f0a09b
#: ../../ref/models/querysets.txt:814
msgid ""
"...then the fact that ``pizza.toppings.all()`` has been prefetched will not "
"help you - in fact it hurts performance, since you have done a database "
"query that you haven't used. So use this feature with caution!"
msgstr ""
"...тот факт, что ``pizza.toppings.all()`` предварительно загружает данные, "
"не поможет вам - скорее навредит производительности, т.к. будет выполнен "
"дополнительный неиспользованный запрос. Поэтому используйте эту функцию с "
"осторожностью!"

# 30ec294f1d1b45ef9d561c09d8fbebe9
#: ../../ref/models/querysets.txt:818
msgid ""
"You can also use the normal join syntax to do related fields of related "
"fields. Suppose we have an additional model to the example above::"
msgstr ""
"Вы можете использовать стандартный синтаксис для обращения к связанным "
"моделям. Например, добавим еще одну модель в пример выше::"

# aa3de7da48e74729858e02c95fdab3ed
#: ../../ref/models/querysets.txt:825
msgid "The following are all legal:"
msgstr "Можно использовать такой запрос:"

# 0765ed76370c4aac8b32b94a346d58d1
#: ../../ref/models/querysets.txt:829
msgid ""
"This will prefetch all pizzas belonging to restaurants, and all toppings "
"belonging to those pizzas. This will result in a total of 3 database queries "
"- one for the restaurants, one for the pizzas, and one for the toppings."
msgstr ""
"Этот запрос выполнит предварительную загрузку всех пицц(Pizza) для ресторанов"
"(Restaurant) и всех ингредиентов(Topping) для пицц. В результате будет "
"выполнено 3 запроса - один для Restaurant, один для Pizza, и один для "
"Topping."

# 1bc723b8cd1e47a69ebf5503049d2624
#: ../../ref/models/querysets.txt:835
msgid ""
"This will fetch the best pizza and all the toppings for the best pizza for "
"each restaurant. This will be done in 3 database queries - one for the "
"restaurants, one for the 'best pizzas', and one for one for the toppings."
msgstr ""
"Это вернет \"best pizza\" и все \"toppings\" для них для каждого ресторана. "
"Будет выполнено 3 запроса."

# 233b470234a044dea1c1a4dc463043f8
#: ../../ref/models/querysets.txt:839
msgid ""
"Of course, the ``best_pizza`` relationship could also be fetched using "
"``select_related`` to reduce the query count to 2:"
msgstr ""
"Конечно, связь ``best_pizza`` может быть получена через ``select_related`` "
"что бы уменьшить количество запросов до двух:"

# deae4b56bee74a058123faf94d41f183
#: ../../ref/models/querysets.txt:844
msgid ""
"Since the prefetch is executed after the main query (which includes the "
"joins needed by ``select_related``), it is able to detect that the "
"``best_pizza`` objects have already been fetched, and it will skip fetching "
"them again."
msgstr ""
"Так как предварительная загрузка выполняется после основного запроса "
"(который включает все необходимые объединения таблиц для обработки "
"``select_related``), она способна определить что объекты ``best_pizza`` уже "
"получены и не выполнит их загрузку снова."

# 89590e17c2a44ebd8b013ceaf3c4d642
#: ../../ref/models/querysets.txt:848
msgid ""
"Chaining ``prefetch_related`` calls will accumulate the lookups that are "
"prefetched. To clear any ``prefetch_related`` behavior, pass `None` as a "
"parameter::"
msgstr ""
"Использование нескольких вызовов ``prefetch_related`` соберет вместе все "
"предварительно загружаемые поля. Что бы из обнулить вызовите метод "
"``prefetch_related`` с аргументом `None`::"

# 46a774303a8e4a7fa40a14a9936f9a7b
#: ../../ref/models/querysets.txt:854
msgid ""
"One difference to note when using ``prefetch_related`` is that objects "
"created by a query can be shared between the different objects that they are "
"related to i.e. a single Python model instance can appear at more than one "
"point in the tree of objects that are returned. This will normally happen "
"with foreign key relationships. Typically this behavior will not be a "
"problem, and will in fact save both memory and CPU time."
msgstr ""
"Одна особенность вызова ``prefetch_related``, про которую следует упомянуть, "
"объекты созданные в результате выполнения запроса могут быть использованы "
"различными связанными объектами, то есть один экземпляр модели может "
"оказаться более чем в одной точке в дереве возвращенных объектов. Это обычно "
"случается с внешними ключами. Скорее всего это не вызовет никаких проблем, и "
"даже сохранит память и время CPU."

# 0224fa29d695415f9fb9841e6691546c
#: ../../ref/models/querysets.txt:861
msgid ""
"While ``prefetch_related`` supports prefetching ``GenericForeignKey`` "
"relationships, the number of queries will depend on the data. Since a "
"``GenericForeignKey`` can reference data in multiple tables, one query per "
"table referenced is needed, rather than one query for all the items. There "
"could be additional queries on the ``ContentType`` table if the relevant "
"rows have not already been fetched."
msgstr ""
"Так как ``prefetch_related`` поддерживает предварительную загрузку "
"``GenericForeignKey``, количество запросов зависит от данных. Так как "
"``GenericForeignKey`` может ссылаться на данные из разных таблиц, необходим "
"один запрос на одну таблицу, вместо одного запроса для всех данных. Так же "
"может понадобится дополнительный запрос к таблице ``ContentType`` если "
"соответствующие данные еще не загружены."

# 3738fd126f124d05a43e190ffd4e7d1c
#: ../../ref/models/querysets.txt:868
msgid ""
"``prefetch_related`` in most cases will be implemented using a SQL query "
"that uses the 'IN' operator. This means that for a large QuerySet a large "
"'IN' clause could be generated, which, depending on the database, might have "
"performance problems of its own when it comes to parsing or executing the "
"SQL query. Always profile for your use case!"
msgstr ""
"``prefetch_related`` в основном использует оператор `IN` SQL запроса. Это "
"означает, что для больших QuerySet может быть создано сложное условие 'IN', "
"что, в зависимости от базы данных, может привести к проблемам с "
"производительностью при разборе и выполнении SQL запроса. Всегда анализируйте"
"(profile) ваш запрос!"

# fb07b22e96bf4735aab0e4f4ebac9843
#: ../../ref/models/querysets.txt:874
msgid ""
"Note that if you use ``iterator()`` to run the query, ``prefetch_related()`` "
"calls will be ignored since these two optimizations do not make sense "
"together."
msgstr ""
"Заметим, если вы используете ``iterator()`` для выполнения запроса, вызов "
"``prefetch_related()`` будет проигнорирован т.к. использование этих двух "
"оптимизаций вместе не имеет смысла."

# 3de60b9d93e9467288b16597a3aeafd4
#: ../../ref/models/querysets.txt:878
msgid "extra"
msgstr "extra"

# d259661cdd444f0e8c4d38c129301258
#: ../../ref/models/querysets.txt:882
msgid ""
"Sometimes, the Django query syntax by itself can't easily express a complex "
"``WHERE`` clause. For these edge cases, Django provides the ``extra()`` "
"``QuerySet`` modifier — a hook for injecting specific clauses into the SQL "
"generated by a ``QuerySet``."
msgstr ""
"Иногда, стандартных возможностей Django не хватает для создания сложного "
"условия ``WHERE`` запроса. Для таких случаев, Django предоставляет метод "
"``extra()`` ``QuerySet`` — метод позволяющий изменять  SQL сгенерированный "
"``QuerySet``."

# 06b847bf877049b8b0e89f52e3b22595
#: ../../ref/models/querysets.txt:887
msgid ""
"By definition, these extra lookups may not be portable to different database "
"engines (because you're explicitly writing SQL code) and violate the DRY "
"principle, so you should avoid them if possible."
msgstr ""
"По определению, дополнительные параметры поиска определенные в ``extra()`` "
"не переносимы между различными типами данных(потому что вы используете "
"непосредственно SQL) и нарушает принцип DRY, по этому вы должны избегать "
"использование этого метода."

# c4b07a1884d34cadb7a66854fbe8015d
#: ../../ref/models/querysets.txt:891
msgid ""
"Specify one or more of ``params``, ``select``, ``where`` or ``tables``. None "
"of the arguments is required, but you should use at least one of them."
msgstr ""
"Укажите одни или несколько параметров ``params``, ``select``, ``where`` или "
"``tables``. Ни один из аргументов не обязателен, но вы должны указать хотя "
"бы один."

# d477098199c549dea385dbc618304381
#: ../../ref/models/querysets.txt:894
msgid "``select``"
msgstr "``select``"

# e2677340436845e38f1c1eeadc0f6b3f
#: ../../ref/models/querysets.txt:896
msgid ""
"The ``select`` argument lets you put extra fields in the ``SELECT`` clause.  "
"It should be a dictionary mapping attribute names to SQL clauses to use to "
"calculate that attribute."
msgstr ""
"Параметр ``select`` позволяет добавить дополнительные поля в ``SELECT``. Это "
"должен быть словарь отображающий названия атрибутов и выражение SQL для "
"вычисления значения этого атрибута."

# fafc90c64c654582b9d9e27bf6a470e9
#: ../../ref/models/querysets.txt:904
msgid ""
"As a result, each ``Entry`` object will have an extra attribute, "
"``is_recent``, a boolean representing whether the entry's ``pub_date`` is "
"greater than Jan. 1, 2006."
msgstr ""
"В результате, каждый объект ``Entry`` будет содержать дополнительный "
"атрибут, ``is_recent``, булево значение определяющее больше ли значение "
"``pub_date`` чем 1 января 2006."

# f74fe8ea7ff94428a66e466b3fca6b38
#: ../../ref/models/querysets.txt:908
msgid ""
"Django inserts the given SQL snippet directly into the ``SELECT`` statement, "
"so the resulting SQL of the above example would be something like::"
msgstr ""
"Django вставит добавленный кусок SQL непосредственно в оператор ``SELECT``, "
"полученный SQL выглядит таким образом::"

# 311cf9d3932c448a9198013546ec6801
#: ../../ref/models/querysets.txt:916
msgid ""
"The next example is more advanced; it does a subquery to give each resulting "
"``Blog`` object an ``entry_count`` attribute, an integer count of associated "
"``Entry`` objects::"
msgstr ""
"Следующий пример сложнее. Он добавляет подзапрос, что бы добавить каждому "
"объекту ``Blog`` атрибут ``entry_count``, который равен количеству связанных "
"объектов ``Entry``::"

# 963282dfaebf4a4d90d8ffed765150a2
#: ../../ref/models/querysets.txt:926
msgid ""
"In this particular case, we're exploiting the fact that the query will "
"already contain the ``blog_blog`` table in its ``FROM`` clause."
msgstr ""
"В это примере, мы используем тот факт, что запрос уже будет содержать "
"таблицу ``blog_blog`` в операторе ``FROM``."

# dd1c35b12b744f459c6310f3c405b46a
#: ../../ref/models/querysets.txt:929
msgid "The resulting SQL of the above example would be::"
msgstr "Полученный SQL запрос выглядит таким образом::"

# d833e4e577c646539ca26fafe4303729
#: ../../ref/models/querysets.txt:934
msgid ""
"Note that the parentheses required by most database engines around "
"subqueries are not required in Django's ``select`` clauses. Also note that "
"some database backends, such as some MySQL versions, don't support "
"subqueries."
msgstr ""
"Заметим, что скобки вокруг подзапроса, обязательные для некоторых баз "
"данных, не обязательны для параметра ``select`` в Django. Так же заметим, "
"что некоторые типы баз данных, такие как некоторые версии MySQL, не "
"поддерживают подзапросы."

# c8f82a29773e419780c274f05434651e
#: ../../ref/models/querysets.txt:939
msgid ""
"In some rare cases, you might wish to pass parameters to the SQL fragments "
"in ``extra(select=...)``. For this purpose, use the ``select_params`` "
"parameter. Since ``select_params`` is a sequence and the ``select`` "
"attribute is a dictionary, some care is required so that the parameters are "
"matched up correctly with the extra select pieces. In this situation, you "
"should use a :class:`django.utils.datastructures.SortedDict` for the "
"``select`` value, not just a normal Python dictionary."
msgstr ""
"В некоторых редких случаях, вам понадобится передать параметры в фрагмент "
"SQL из ``extra(select=...)``. Для этого, используйте параметр "
"``select_params``. Так как ``select_params`` это последовательность, а "
"атрибут ``select`` словарь, необходима некоторая внимательность, что бы "
"параметры корректно были добавлены в оператор ``SELECT``. В этом случае "
"следует использовать a :class:`django.utils.datastructures.SortedDict` для "
"значения ``select``, вместо обычного словаря Python."

# 1923cc211ba8437b90a6ca5321cef560
#: ../../ref/models/querysets.txt:948
msgid "This will work, for example::"
msgstr "Например::"

# 28a4898245f3431383d4f394c9cbb7bb
#: ../../ref/models/querysets.txt:954
msgid ""
"The only thing to be careful about when using select parameters in ``extra()"
"`` is to avoid using the substring ``\"%%s\"`` (that's *two* percent "
"characters before the ``s``) in the select strings. Django's tracking of "
"parameters looks for ``%s`` and an escaped ``%`` character like this isn't "
"detected. That will lead to incorrect results."
msgstr ""
"Единственное, что нужно помнить используя параметры в ``extra()`` -- "
"избегать использование ``\"%%s\"`` (тут *два* знака процента перед ``s``) в "
"параметре ``select``. Django ищет ``%s`` и экранированный символ ``%`` не "
"будет распознан. Это приведет к неверным результатам."

# c89f9dbedbe2441c8c70b5ba0f33f091
#: ../../ref/models/querysets.txt:960
msgid "``where`` / ``tables``"
msgstr "``where`` / ``tables``"

# 8ff13dbb2f414cd0b147bb464f97f439
#: ../../ref/models/querysets.txt:962
msgid ""
"You can define explicit SQL ``WHERE`` clauses — perhaps to perform non-"
"explicit joins — by using ``where``. You can manually add tables to the SQL "
"``FROM`` clause by using ``tables``."
msgstr ""
"Вы можете добавить оператор SQL ``WHERE`` — возможно для выполнения не "
"явного объединения таблиц — by using ``where``. Используя параметр "
"``tables`` можно добавить таблицы в оператор SQL ``FROM``."

# 15c331c702b043e68d0e634bb76a0727
#: ../../ref/models/querysets.txt:966
msgid ""
"``where`` and ``tables`` both take a list of strings. All ``where`` "
"parameters are \"AND\"ed to any other search criteria."
msgstr ""
"``where`` и ``tables`` принимают список строк. Все параметры ``where`` будут "
"добавлены к остальным критериям через оператор \"AND\" ."

# e1286287c0154eb1b785dcebbcdec4e8
#: ../../ref/models/querysets.txt:973
msgid "...translates (roughly) into the following SQL::"
msgstr "...будет переведено (примерно) в следующий SQL::"

# 713d4dbee21f487bb2fa345c5d1f24b9
#: ../../ref/models/querysets.txt:977
msgid ""
"Be careful when using the ``tables`` parameter if you're specifying tables "
"that are already used in the query. When you add extra tables via the "
"``tables`` parameter, Django assumes you want that table included an extra "
"time, if it is already included. That creates a problem, since the table "
"name will then be given an alias. If a table appears multiple times in an "
"SQL statement, the second and subsequent occurrences must use aliases so the "
"database can tell them apart. If you're referring to the extra table you "
"added in the extra ``where`` parameter this is going to cause errors."
msgstr ""
"Будьте внимательны при добавлении в параметр ``tables`` таблиц, которые уже "
"используются запросом. В таком случае Django предполагает, что вы хотите "
"добавить их повторно. Это создает проблему, т.к. таблица будет добавлена с "
"псевдонимом(an alias). Если таблица несколько раз используется в запросе, "
"второй и последующие вхождения должны использовать псевдонимы, что бы база "
"данных могла различить их. При обращении к добавленной таблице в параметре "
"``where`` вы получите ошибку."

# 842b9a6d4fac4b8d8ab926eefa4f72ac
#: ../../ref/models/querysets.txt:987
msgid ""
"Normally you'll only be adding extra tables that don't already appear in the "
"query. However, if the case outlined above does occur, there are a few "
"solutions. First, see if you can get by without including the extra table "
"and use the one already in the query. If that isn't possible, put your "
"``extra()`` call at the front of the queryset construction so that your "
"table is the first use of that table. Finally, if all else fails, look at "
"the query produced and rewrite your ``where`` addition to use the alias "
"given to your extra table. The alias will be the same each time you "
"construct the queryset in the same way, so you can rely upon the alias name "
"to not change."
msgstr ""
"Скорее всего вы будете использовать дополнительные таблицы, которые еще не "
"добавлены в запрос. Однако, если все таки возникнет описанная выше ситуация, "
"существует несколько способов ее решить. Первый, посмотрите возможно ли "
"использовать уже добавленную в запрос таблицу. Если это не возможно, "
"используйте вызов ``extra()`` в начале конструкции запроса, что бы ваша "
"таблица использовалась первой. В конце концов, если каким-то образом все "
"остальное вам не помогло, посмотрите на созданный запрос и перепишите "
"параметр ``where`` таким образом, что бы использовался псевдоним назначенный "
"дополнительной таблице. При одинаковом способе создать запрос псевдоним "
"будет всегда не измененным."

# 1a5e940cb73b484ca39666c8fa38f4df
#: ../../ref/models/querysets.txt:998
msgid "``order_by``"
msgstr "``order_by``"

# 65361163de7e445db05dc6a18d46b3e5
#: ../../ref/models/querysets.txt:1000
msgid ""
"If you need to order the resulting queryset using some of the new fields or "
"tables you have included via ``extra()`` use the ``order_by`` parameter to "
"``extra()`` and pass in a sequence of strings. These strings should either "
"be model fields (as in the normal :meth:`order_by()` method on querysets), "
"of the form ``table_name.column_name`` or an alias for a column that you "
"specified in the ``select`` parameter to ``extra()``."
msgstr ""
"Если вам необходимо отсортировать полученный ``QuerySet`` используя новые "
"поля или таблицы, которые вы добавили через ``extra()``, используйте "
"параметр ``order_by`` передав последовательность строк. Эти строки должны "
"быть полями модели (как и в обычном методе :meth:`order_by()`), в формате "
"``table_name.column_name`` или псевдонимы колонок которые вы указали в "
"параметре ``select`` при вызове ``extra()``."

# b7ff1c442c394f2182b9b9bd354ac00d
#: ../../ref/models/querysets.txt:1013
msgid ""
"This would sort all the items for which ``is_recent`` is true to the front "
"of the result set (``True`` sorts before ``False`` in a descending ordering)."
msgstr ""
"Это запрос должен отсортировать все записи, у которых ``is_recent`` равен "
"``True``, перед остальными записями (``True`` следует перед ``False`` при "
"ниспадающей сортировке)."

# f03db6ccfc0f4194a54586b94ab8477a
#: ../../ref/models/querysets.txt:1017
msgid ""
"This shows, by the way, that you can make multiple calls to ``extra()`` and "
"it will behave as you expect (adding new constraints each time)."
msgstr ""
"Вы можете заметить, между прочим, что можно выполнить несколько вызовов "
"``extra()`` (добавляя новые параметры каждый раз)."

# 9e193718998d4537860ecf5b0b8cba65
#: ../../ref/models/querysets.txt:1020
msgid "``params``"
msgstr "``params``"

# bb4b27c71c0f4cc2a4146feaa9e1b6be
#: ../../ref/models/querysets.txt:1022
msgid ""
"The ``where`` parameter described above may use standard Python database "
"string placeholders — ``'%s'`` to indicate parameters the database engine "
"should automatically quote. The ``params`` argument is a list of any extra "
"parameters to be substituted."
msgstr ""
"Параметр ``where`` описанный выше может использовать стандартный синтаксис "
"Python подстановки параметров в строку — ``'%s'``, что бы указать какие "
"параметры должны быть экранированы базой данных. Аргумент ``params`` это "
"список дополнительных параметров, которые будут подставлены в условие "
"``where``."

# 7d12b53fac8047c6bb0e88e741a2b18b
#: ../../ref/models/querysets.txt:1031
msgid ""
"Always use ``params`` instead of embedding values directly into ``where`` "
"because ``params`` will ensure values are quoted correctly according to your "
"particular backend. For example, quotes will be escaped correctly."
msgstr ""
"Всегда используйте ``params`` вместо добавления значений непосредственно в "
"``where`` т.к. ``params`` гарантирует, что все значения будут экранированы в "
"соответствиями с синтаксисом используемой базы данных. Например, кавычки "
"будут экранированы правильно."

# 20cd30fc891c435583d2d1a75a857de9
#: ../../ref/models/querysets.txt:1036
msgid "Bad::"
msgstr "Не верно::"

# 2cada5cb69334006baed723e8a319829
#: ../../ref/models/querysets.txt:1040
msgid "Good::"
msgstr "Верно::"

# 3afdacafdbad455b9e1e7a53ec7b6031
#: ../../ref/models/querysets.txt:1045
msgid "defer"
msgstr "defer"

# 5fb61d8241314a7d8629423a425a203d
#: ../../ref/models/querysets.txt:1049
msgid ""
"In some complex data-modeling situations, your models might contain a lot of "
"fields, some of which could contain a lot of data (for example, text "
"fields), or require expensive processing to convert them to Python objects. "
"If you are using the results of a queryset in some situation where you know "
"you don't know if you need those particular fields when you initially fetch "
"the data, you can tell Django not to retrieve them from the database."
msgstr ""
"При сложной структуре данных модели могут содержать большое количество "
"полей, некоторые из которых могут содержать большие объемы данных(например, "
"``TextField``), или использовать ресурсоемкий процесс преобразования данных "
"в объекты Python. Если вы точно знаете, что данные этих полей не будут "
"использоваться при работе с результатами запроса, вы можете указать Django "
"не выбирать эти поля из базы данных."

# 8a7ee38eda6e48f5a857685809cadd15
#: ../../ref/models/querysets.txt:1056
msgid ""
"This is done by passing the names of the fields to not load to ``defer()``::"
msgstr ""
"Это делается передачей названия полей, которые не должны быть загружены, в "
"метод ``defer()``::"

# 5043e37328554995a7a9d3bef5998780
#: ../../ref/models/querysets.txt:1060
msgid ""
"A queryset that has deferred fields will still return model instances. Each "
"deferred field will be retrieved from the database if you access that field "
"(one at a time, not all the deferred fields at once)."
msgstr ""
"Результат все так же будет содержать объекты модели. Каждое не выбранное "
"поле будет получено из базы данных при обращении к нему (одна за раз, не все "
"\"отложенные\" поля сразу)."

# 2414a9daaa19429ea819d61b4dcac085
#: ../../ref/models/querysets.txt:1064
msgid ""
"You can make multiple calls to ``defer()``. Each call adds new fields to the "
"deferred set::"
msgstr ""
"Вы можете выполнить несколько вызовов ``defer()``. Каждый вызов добавит "
"новые поля в список \"отложенных\"::"

# 9b26c911e7364b98a3df1e2144bf0fee
#: ../../ref/models/querysets.txt:1070
msgid ""
"The order in which fields are added to the deferred set does not matter. "
"Calling ``defer()`` with a field name that has already been deferred is "
"harmless (the field will still be deferred)."
msgstr ""
"Порядок добавления полей не имеет значения. Вызов ``defer()`` с полем, "
"которое уже было добавлено в список \"отложенных\", ничего не изменит (поле "
"все так же не будет выбираться из базы данных)."

# e3730cc7e91a4db8947ac048149bbce2
#: ../../ref/models/querysets.txt:1074
msgid ""
"You can defer loading of fields in related models (if the related models are "
"loading via :meth:`select_related()`) by using the standard double-"
"underscore notation to separate related fields::"
msgstr ""
"Вы можете указать поля связанных моделей (если эти модели загружаются через :"
"meth:`select_related()`) используя стандартный синтаксис двух нижних "
"подчеркиваний для разделения полей::"

# 4d3acc1cb7244585844db63a13fa8a8b
#: ../../ref/models/querysets.txt:1080
msgid ""
"If you want to clear the set of deferred fields, pass ``None`` as a "
"parameter to ``defer()``::"
msgstr ""
"Если вы хотите очистить список \"отложенных\" полей, передайте ``None`` как "
"параметр для ``defer()``::"

# 679b9e44b8f3487ba32aa4f4ba9a4f3c
#: ../../ref/models/querysets.txt:1086
msgid ""
"Some fields in a model won't be deferred, even if you ask for them. You can "
"never defer the loading of the primary key. If you are using :meth:"
"`select_related()` to retrieve related models, you shouldn't defer the "
"loading of the field that connects from the primary model to the related one "
"(at the moment, that doesn't raise an error, but it will eventually)."
msgstr ""
"Некоторые поля всегда будут выбираться из базы данных, даже если вы их "
"добавите в вызов ``defer()``. Всегда выбирается первичный ключ. Используя :"
"meth:`select_related()` для получения связанных моделей, не \"откладывайте\" "
"загрузку связывающего поля(на данный момент ошибки не будет, но это может "
"изменится в будущем)."

# 8c60db197c4d46d29ef25f0c8e5ffed7
#: ../../ref/models/querysets.txt:1094
msgid ""
"The ``defer()`` method (and its cousin, :meth:`only()`, below) are only for "
"advanced use-cases. They provide an optimization for when you have analyzed "
"your queries closely and understand *exactly* what information you need and "
"have measured that the difference between returning the fields you need and "
"the full set of fields for the model will be significant."
msgstr ""
"Метод ``defer()`` (и его \"коллега\" :meth:`only()`) предназначены только "
"для опытных пользователей. Они предоставляют возможность оптимизировать "
"запрос. Но для начала вам следует проанализировать его, *точно* определить "
"какие данные вам необходимы и удостовериться, что разница между получением "
"всех полей и получением определенных, будет значительной."

# 86de8b7daf0c424ebf32ea779c4f9355
#: ../../ref/models/querysets.txt:1100
msgid ""
"Even if you think you are in the advanced use-case situation, **only use "
"defer() when you cannot, at queryset load time, determine if you will need "
"the extra fields or not**. If you are frequently loading and using a "
"particular subset of your data, the best choice you can make is to normalize "
"your models and put the non-loaded data into a separate model (and database "
"table). If the columns *must* stay in the one table for some reason, create "
"a model with ``Meta.managed = False`` (see the :attr:`managed attribute "
"<django.db.models.Options.managed>` documentation) containing just the "
"fields you normally need to load and use that where you might otherwise call "
"``defer()``. This makes your code more explicit to the reader, is slightly "
"faster and consumes a little less memory in the Python process."
msgstr ""
"Даже если вы думаете, что у вас сложная ситуация требующая использовать "
"``defer() ``, **используйте его только будучи уверенным, что \"отложенные\" "
"поля не понадобятся далее в коде**. Если вы часто загружаете и используете "
"только часть полей, лучшим решением будет нормализировать модели и вынести "
"не загружаемые поля в отдельную модель(и таблицу базы данных). Если поля "
"*должны* по каким-то причинам находится в одной таблице, создайте модель с "
"``Meta.managed = False`` (смотрите документацию о :attr:`managed attribute "
"<django.db.models.Options.managed>`) содержащую только используемые поля, и "
"используйте ее вместо ``defer()``. Это делает ваш код более читабельным, "
"немного быстрее и экономит немного памяти используемой процессом Python."

# 9f71a64c63c64187aaff40d5dd2b2bf9
#: ../../ref/models/querysets.txt:1115
msgid "only"
msgstr "only"

# 9c86c8cdfbd645e2986802c35fcd31ce
#: ../../ref/models/querysets.txt:1119
msgid ""
"The ``only()`` method is more or less the opposite of :meth:`defer()`. You "
"call it with the fields that should *not* be deferred when retrieving a "
"model.  If you have a model where almost all the fields need to be deferred, "
"using ``only()`` to specify the complementary set of fields can result in "
"simpler code."
msgstr ""
"Метод ``only()``-- противоположность метода :meth:`defer()`. Вызывайте его с "
"полями, получение которых *не* должно быть отложено.  Если у вас есть "
"модель, почти все поля которой не должны выбираться из базы данных, "
"используйте ``only()``. Это сделает ваш код проще."

# 3609e904db4c4df0b4bcfe0dcb3c6e62
#: ../../ref/models/querysets.txt:1125
msgid ""
"Suppose you have a model with fields ``name``, ``age`` and ``biography``. "
"The following two querysets are the same, in terms of deferred fields::"
msgstr ""
"Например, у вас есть модель с полями ``name``, ``age`` и ``biography``. Эти "
"два запроса идентичны в плане полученных полей::"

# 08006732a6df4c2f826a7c5677070617
#: ../../ref/models/querysets.txt:1131
msgid ""
"Whenever you call ``only()`` it *replaces* the set of fields to load "
"immediately. The method's name is mnemonic: **only** those fields are loaded "
"immediately; the remainder are deferred. Thus, successive calls to ``only()"
"`` result in only the final fields being considered::"
msgstr ""
"При вызове ``only()`` будет *заменено* множество загружаемых полей. Название "
"метода говорит само за себя: **только** эти поля должны быть загружены; все "
"остальные -- \"отложены\". Таким образом при последовательном вызове ``only()"
"`` несколько раз, только поля из последнего вызова будут загружены::"

# 289793a330b14607b189dae4cfb8c2f5
#: ../../ref/models/querysets.txt:1139
msgid ""
"Since ``defer()`` acts incrementally (adding fields to the deferred list), "
"you can combine calls to ``only()`` and ``defer()`` and things will behave "
"logically::"
msgstr ""
"Так как ``defer()`` добавляет поля в список \"отложенных\" при множественном "
"вызове, вы можете совмещать вызовы ``only()`` и ``defer()``, что будет "
"работать вполне логично::"

# dee05b337045471ca43bce707de47a2a
#: ../../ref/models/querysets.txt:1150
msgid ""
"All of the cautions in the note for the :meth:`defer` documentation apply to "
"``only()`` as well. Use it cautiously and only after exhausting your other "
"options."
msgstr ""
"Все замечания описанные для метода :meth:`defer` применимы так же и к методу "
"``only()``. Используйте его с осторожностью и только в отсутствии других "
"вариантов."

# be693002305d4620b81f6195a5f605e7
#: ../../ref/models/querysets.txt:1155
msgid "using"
msgstr "using"

# 095673642a8347009402505bb8f4a742
#: ../../ref/models/querysets.txt:1161
msgid ""
"This method is for controlling which database the ``QuerySet`` will be "
"evaluated against if you are using more than one database.  The only "
"argument this method takes is the alias of a database, as defined in :"
"setting:`DATABASES`."
msgstr ""
"Этот метод контролирует какую базу данных будет использовать ``QuerySet`` "
"для запроса, если вы используете несколько баз данных.  Единственный "
"аргумент это псевдоним базы данных указанный в настройке проекта :setting:"
"`DATABASES`."

# a20c8197c2c240d6a5dfa723b62c89b9
#: ../../ref/models/querysets.txt:1175
msgid "select_for_update"
msgstr "select_for_update"

# 0e55c2aba7894748bc2d007c5f1ad3ab
#: ../../ref/models/querysets.txt:1181
msgid ""
"Returns a queryset that will lock rows until the end of the transaction, "
"generating a ``SELECT ... FOR UPDATE`` SQL statement on supported databases."
msgstr ""
"Возвращает ``QuerySet`` блокирующий записи до завершения транзакции, "
"используя оператор SQL ``SELECT ... FOR UPDATE`` используемой базы данных."

# 0792902df92a4a47812cba16662d35a0
#: ../../ref/models/querysets.txt:1188
msgid ""
"All matched entries will be locked until the end of the transaction block, "
"meaning that other transactions will be prevented from changing or acquiring "
"locks on them."
msgstr ""
"Все, удовлетворяющие фильтрам, строки будут заблокированы до завершения "
"транзакции, то есть другие транзакции не смогут изменить или заблокировать "
"это строки."

# 95d7fbe01a0446028ce3ab946096fc9a
#: ../../ref/models/querysets.txt:1192
msgid ""
"Usually, if another transaction has already acquired a lock on one of the "
"selected rows, the query will block until the lock is released. If this is "
"not the behavior you want, call ``select_for_update(nowait=True)``. This "
"will make the call non-blocking. If a conflicting lock is already acquired "
"by another transaction, :exc:`~django.db.DatabaseError` will be raised when "
"the queryset is evaluated."
msgstr ""
"Обычно, если другая транзакция заблокировала одну из выбранных записей, "
"запрос будет заблокирован до снятия блокировки. Если вы не желаете этого, "
"используйте ``select_for_update(nowait=True)``. Вызов будет не "
"блокированным, если записи уже заблокированы, будет вызвано исключение :exc:"
"`~django.db.DatabaseError` при вычислении ``QuerySet``."

# 9792df60230541faab024b6366fe7928
#: ../../ref/models/querysets.txt:1199
msgid ""
"Note that using ``select_for_update()`` will cause the current transaction "
"to be considered dirty, if under transaction management. This is to ensure "
"that Django issues a ``COMMIT`` or ``ROLLBACK``, releasing any locks held by "
"the ``SELECT FOR UPDATE``."
msgstr ""
"Следует отметить, что использование ``select_for_update()`` приводит к тому, "
"что текущая транзакция считается \"грязной\" (если используется управление "
"транзакциями). Это происходит, потому что Django блокирует указанные записи "
"в БД и держит их до выполнения фиксации(``COMMIT``) или отката(``ROLLBACK``) "
"произведённых изменений, освобождая поставленные ранее блокировки в базе "
"данных."

# 8e0acd3a01d64552a267b44d229abd28
#: ../../ref/models/querysets.txt:1204
msgid ""
"Currently, the ``postgresql_psycopg2``, ``oracle``, and ``mysql`` database "
"backends support ``select_for_update()``. However, MySQL has no support for "
"the ``nowait`` argument. Obviously, users of external third-party backends "
"should check with their backend's documentation for specifics in those cases."
msgstr ""
"На данный момент, ``postgresql_psycopg2``, ``oracle``, и ``mysql`` \"бэкэнды"
"\" базы данных поддерживают ``select_for_update()``. Однако, MySQL не "
"поддерживает аргумент ``nowait``. Пользователи других баз данных должны "
"уточнить эту информацию в документации используемой базы данных."

# 07555036d70443c1abefc233b4f6a63e
#: ../../ref/models/querysets.txt:1209
msgid ""
"Passing ``nowait=True`` to ``select_for_update`` using database backends "
"that do not support ``nowait``, such as MySQL, will cause a :exc:`~django.db."
"DatabaseError` to be raised. This is in order to prevent code unexpectedly "
"blocking."
msgstr ""
"Использование ``nowait=True`` в ``select_for_update`` для базы данных, "
"которая не поддерживает ``nowait``, такой как MySQL, вызовет исключение :exc:"
"`~django.db.DatabaseError`. Это делается чтобы предотвратить непредвиденную "
"блокировку кода."

# 468b0dff8e6147dbafa260f11136e211
#: ../../ref/models/querysets.txt:1214
msgid ""
"Using ``select_for_update`` on backends which do not support ``SELECT ... "
"FOR UPDATE`` (such as SQLite) will have no effect."
msgstr ""
"Использование ``select_for_update`` с базой данных, которая не поддерживает "
"``SELECT ... FOR UPDATE`` (например, SQLite) не будет иметь никакого эфекта."

# cf54942aad72476b975aeab0c6d46b05
#: ../../ref/models/querysets.txt:1218
msgid "Methods that do not return QuerySets"
msgstr "Методы, которые не возвращают QuerySets"

# e2cc8170101f4de6a8d642df4f66c0ba
#: ../../ref/models/querysets.txt:1220
msgid ""
"The following ``QuerySet`` methods evaluate the ``QuerySet`` and return "
"something *other than* a ``QuerySet``."
msgstr ""
"Следующие методы выполняют ``QuerySet`` и возвращают *не* ``QuerySet``."

# 5e5113f0ef414577825e47219fb7d53e
#: ../../ref/models/querysets.txt:1223
msgid ""
"These methods do not use a cache (see :ref:`caching-and-querysets`). Rather, "
"they query the database each time they're called."
msgstr ""
"Эти методы не используют кэш (смотрите :ref:`caching-and-querysets`) и "
"выполняют запрос к базе данных при каждом вызове."

# 215fe858f64a4e35b05940589525f55c
#: ../../ref/models/querysets.txt:1227
msgid "get"
msgstr "get"

# a4c76c594925430f9360797d2ed288fd
#: ../../ref/models/querysets.txt:1231
msgid ""
"Returns the object matching the given lookup parameters, which should be in "
"the format described in `Field lookups`_."
msgstr ""
"Возвращает объект соответствующий параметрам поиска, которые должны быть "
"указанны в формате описаном в :ref:`разделе о параметрах поиска <field-"
"lookups>`"

# ceedda62705e4961aa2713b4025293b3
#: ../../ref/models/querysets.txt:1234
msgid ""
"``get()`` raises :exc:`~django.core.exceptions.MultipleObjectsReturned` if "
"more than one object was found. The :exc:`~django.core.excpetions."
"MultipleObjectsReturned` exception is an attribute of the model class."
msgstr ""
"``get()`` вызывает исключение :exc:`~django.core.exceptions."
"MultipleObjectsReturned`, если найдено более одно объекта. :exc:`~django."
"core.excpetions.MultipleObjectsReturned` -- атрибут класса модели."

# 8b9d9fa4a3d84d18af471fd705e7b7fd
#: ../../ref/models/querysets.txt:1239
msgid ""
"``get()`` raises a :exc:`~django.core.exceptions.DoesNotExist` exception if "
"an object wasn't found for the given parameters. This exception is also an "
"attribute of the model class. Example::"
msgstr ""
"``get()`` вызывает исключение :exc:`~django.core.exceptions.DoesNotExist`, "
"ни один объект не был найден. Это исключение так же атрибут класса модели. "
"Например::"

# 1de14e70fc794c9fb9d8de5acbc06d5e
#: ../../ref/models/querysets.txt:1245
msgid ""
"The :exc:`~django.core.exceptions.DoesNotExist` exception inherits from :exc:"
"`django.core.exceptions.ObjectDoesNotExist`, so you can target multiple :exc:"
"`~django.core.exceptions.DoesNotExist` exceptions. Example::"
msgstr ""
"Исключение :exc:`~django.core.exceptions.DoesNotExist` унаследовано от :exc:"
"`django.core.exceptions.ObjectDoesNotExist`,таким образом можно обработать "
"несколько исключений :exc:`~django.core.exceptions.DoesNotExist`. Например::"

# 48c322aa8440460f81b4545e4404fcae
#: ../../ref/models/querysets.txt:1257
msgid "create"
msgstr "create"

# dc1f60acc08941bf90036eec5558cfcc
#: ../../ref/models/querysets.txt:1261
msgid ""
"A convenience method for creating an object and saving it all in one step.  "
"Thus::"
msgstr "Удобный метод создать и сохранить объект. Таким образом::"

# 6e7c183bfa21425aab2a2e428662ae84
#: ../../ref/models/querysets.txt:1265
msgid "and::"
msgstr "и::"

# 76da19f0fec2474ea112e705f5b05126
#: ../../ref/models/querysets.txt:1270
msgid "are equivalent."
msgstr "эквивалентны."

# 1213699156fb41af9b4150ec19cb1b60
#: ../../ref/models/querysets.txt:1272
msgid ""
"The :ref:`force_insert <ref-models-force-insert>` parameter is documented "
"elsewhere, but all it means is that a new object will always be created. "
"Normally you won't need to worry about this. However, if your model contains "
"a manual primary key value that you set and if that value already exists in "
"the database, a call to ``create()`` will fail with an :exc:`~django.db."
"IntegrityError` since primary keys must be unique. Be prepared to handle the "
"exception if you are using manual primary keys."
msgstr ""
"Параметр :ref:`force_insert <ref-models-force-insert>` описан в другом "
"разделе, он означает, что всегда будет  создаваться новый объект. Обычно вам "
"не нужно беспокоиться об этом. Однако, если ваш объект содержит значение "
"первичного ключа и этот ключ уже существует в базе данных, метод ``create()"
"`` вызовет исключение :exc:`~django.db.IntegrityError` т.к. первичный ключ "
"должен быть уникальным. Будьте готовы обработать исключение, если вы "
"самостоятельно указываете первичный ключ."

# 733254dc1264496dbe4cb36d871b2d9b
#: ../../ref/models/querysets.txt:1281
msgid "get_or_create"
msgstr "get_or_create"

# e3c560b3981d4cfcbf09766623b6825e
#: ../../ref/models/querysets.txt:1285
msgid ""
"A convenience method for looking up an object with the given kwargs, "
"creating one if necessary."
msgstr ""
"Удобный метод для поиска объекта по заданным параметрам поиска ``kwargs``, и "
"создания нового при необходимости."

# 0b3c276a1737474fa728a52a3e7d52f1
#: ../../ref/models/querysets.txt:1288
msgid ""
"Returns a tuple of ``(object, created)``, where ``object`` is the retrieved "
"or created object and ``created`` is a boolean specifying whether a new "
"object was created."
msgstr ""
"Возвращает кортеж ``(object, created)``, где ``object`` полученный или "
"созданный объект и ``created`` -- булево значение, указывающее был ли создан "
"объект."

# 10b4d4b11a0f4074ad32685049291aca
#: ../../ref/models/querysets.txt:1292
msgid ""
"This is meant as a shortcut to boilerplatish code and is mostly useful for "
"data-import scripts. For example::"
msgstr "Этот метод удобно использовать для скриптов импорта данных. Например::"

# 69f33df6b87b42b1850c128fb7f06ed9
#: ../../ref/models/querysets.txt:1301
msgid ""
"This pattern gets quite unwieldy as the number of fields in a model goes up. "
"The above example can be rewritten using ``get_or_create()`` like so::"
msgstr ""
"Такой способ становится весьма громоздким при увеличении количества полей "
"модели. Пример выше может быть переписан с использованием метода "
"``get_or_create()``::"

# f45bcfa02f864a63bc20bd2a9c6eac1a
#: ../../ref/models/querysets.txt:1307
msgid ""
"Any keyword arguments passed to ``get_or_create()`` — *except* an optional "
"one called ``defaults`` — will be used in a :meth:`get()` call. If an object "
"is found, ``get_or_create()`` returns a tuple of that object and ``False``. "
"If an object is *not* found, ``get_or_create()`` will instantiate and save a "
"new object, returning a tuple of the new object and ``True``. The new object "
"will be created roughly according to this algorithm::"
msgstr ""
"Все именованные аргументы переданные в ``get_or_create()`` — *кроме* одного "
"не обязательного ``defaults`` — будут использованы при вызове :meth:`get()`. "
"Если объект найден, ``get_or_create()`` вернет этот объект и ``False``. Если "
"объект *не* найден, ``get_or_create()`` создаст и сохранит новый объект, "
"возвращая новый объект и ``True``. Новый объект будет создан примерно за "
"таким алгоритмом::"

# ad18a6924b624c0096c7101f2630df89
#: ../../ref/models/querysets.txt:1320
msgid ""
"In English, that means start with any non-``'defaults'`` keyword argument "
"that doesn't contain a double underscore (which would indicate a non-exact "
"lookup). Then add the contents of ``defaults``, overriding any keys if "
"necessary, and use the result as the keyword arguments to the model class. "
"As hinted at above, this is a simplification of the algorithm that is used, "
"but it contains all the pertinent details. The internal implementation has "
"some more error-checking than this and handles some extra edge-conditions; "
"if you're interested, read the code."
msgstr ""
"Это означает, что будут выбраны именованные аргументы кроме ``'defaults'`` и "
"не содержащие двойное нижнее подчеркивание (которые указывают на не-точный "
"поиск). Затем добавляются значения из ``defaults``, перезаписывая ключи при "
"необходимости, полученные данные используются как аргументы для конструктора "
"класса модели. Как уже указывалось выше, это упрощенный алгоритм, но все "
"важные детали указаны. Внутренняя реализация одержит больше проверок ошибок "
"и различных условий; если вам интересно, можете посмотреть исходный код."

# fc2b1c12110e425ca3dcf375800ef326
#: ../../ref/models/querysets.txt:1329
msgid ""
"If you have a field named ``defaults`` and want to use it as an exact lookup "
"in ``get_or_create()``, just use ``'defaults__exact'``, like so::"
msgstr ""
"Если модель содержит поле ``defaults`` и вы хотите использовать его в "
"параметрах поиска в ``get_or_create()``, просто используйте "
"``'defaults__exact'``::"

# ac3893de8cff4a62aab3cafad3e10525
#: ../../ref/models/querysets.txt:1334
msgid ""
"The ``get_or_create()`` method has similar error behavior to :meth:`create()"
"` when you're using manually specified primary keys. If an object needs to "
"be created and the key already exists in the database, an :exc:`~django.db."
"IntegrityError` will be raised."
msgstr ""
"Метод ``get_or_create()`` использует аналогичное поведение с ошибками что и "
"метод :meth:`create()`, если вы самостоятельно определяете значение "
"первичного ключа. Если объект должен быть создан и значение первичного ключа "
"уже существует в базе данных, будет вызвано исключение :exc:`~django.db."
"IntegrityError`."

# 5ac92a346afa45b5b51f2c59c4dd87e3
#: ../../ref/models/querysets.txt:1339
msgid ""
"Finally, a word on using ``get_or_create()`` in Django views. As mentioned "
"earlier, ``get_or_create()`` is mostly useful in scripts that need to parse "
"data and create new records if existing ones aren't available. But if you "
"need to use ``get_or_create()`` in a view, please make sure to use it only "
"in ``POST`` requests unless you have a good reason not to. ``GET`` requests "
"shouldn't have any effect on data; use ``POST`` whenever a request to a page "
"has a side effect on your data. For more, see `Safe methods`_ in the HTTP "
"spec."
msgstr ""
"Наконец, несколько слов об использовании``get_or_create()`` в представлениях "
"Django. Как упоминалось выше, ``get_or_create()`` полезен в скриптах, "
"которые парсят данные и создают новые объекты при необходимости. Но если вам "
"нужно использовать ``get_or_create()`` в представлении, пожалуйста "
"используйте его только для ``POST`` запросов, если только у вас нет "
"основательных причин не делать этого. Запросы ``GET`` не должны влиять на "
"данные; используйте запрос ``POST`` для изменения данных. Подробнее смотрите "
"раздел о `безопасных методах <http://www.w3.org/Protocols/rfc2616/rfc2616-"
"sec9.html#sec9.1.1>`_ в спецификации HTTP."

# d429abc1e645455c940147c50ab985cd
#: ../../ref/models/querysets.txt:1350
msgid "bulk_create"
msgstr "bulk_create"

# f38d91295c744ec9b91676653ab7f82c
#: ../../ref/models/querysets.txt:1356
msgid ""
"This method inserts the provided list of objects into the database in an "
"efficient manner (generally only 1 query, no matter how many objects there "
"are)::"
msgstr ""
"Этот метод позволяет сохранить в базе данных множество объектов одним "
"запросом::"

# e38565913b9b42f8944e3422063eb7e6
#: ../../ref/models/querysets.txt:1366
msgid "This has a number of caveats though:"
msgstr "Следует упомянуть ряд оговорок:"

# 76a81c0ef9c947488487d43a52de6cc3
#: ../../ref/models/querysets.txt:1368
msgid ""
"The model's ``save()`` method will not be called, and the ``pre_save`` and "
"``post_save`` signals will not be sent."
msgstr ""
"Метод модели ``save()`` не будет вызван, и сигналы ``pre_save`` и "
"``post_save`` не будут вызваны."

# 6924420c93264545b050302f9f9ecf4e
#: ../../ref/models/querysets.txt:1370
msgid ""
"It does not work with child models in a multi-table inheritance scenario."
msgstr "Не работает с дочерними моделями при multi-table наследовании."

# 3727e407fafa4d8da290c49ca51ba764
#: ../../ref/models/querysets.txt:1371
msgid ""
"If the model's primary key is an :class:`~django.db.models.AutoField` it "
"does not retrieve and set the primary key attribute, as ``save()`` does."
msgstr ""
"Если первичный ключ модели это :class:`~django.db.models.AutoField`, его "
"значение не будет получено и атрибут первичного ключа не будет установлен "
"как это делает метод ``save()`` ."

# f66716c9012943b99cd00bd704536d5b
#: ../../ref/models/querysets.txt:1376
msgid ""
"SQLite sets a limit on the number of parameters per SQL statement. The "
"maximum is defined by the SQLITE_MAX_VARIABLE_NUMBER_ compilation option, "
"which defaults to 999. For instance, if your model has 8 fields (including "
"the primary key), you cannot create more than 999 // 8 = 124 instances at a "
"time. If you exceed this limit, you'll get an exception::"
msgstr ""

# 3139ba58ca7b4ccbad8a1bf1f91614ac
#: ../../ref/models/querysets.txt:1384
msgid ""
"If your application's performance requirements exceed SQLite's limits, you "
"should switch to another database engine, such as PostgreSQL."
msgstr ""

# c7683f03673446c6ab62a0b58ab6ef2d
#: ../../ref/models/querysets.txt:1390
msgid "count"
msgstr "count"

# 17a96d7d87224a1a9905cafe37f0f8cb
#: ../../ref/models/querysets.txt:1394
msgid ""
"Returns an integer representing the number of objects in the database "
"matching the ``QuerySet``. The ``count()`` method never raises exceptions."
msgstr ""
"Возвращает количество записей в базе данных отвечающем запросу ``QuerySet``. "
"Метод ``count()`` никогда не вызывает исключение."

# b15795049d074d11a35c29d720e38b37
#: ../../ref/models/querysets.txt:1405
msgid ""
"A ``count()`` call performs a ``SELECT COUNT(*)`` behind the scenes, so you "
"should always use ``count()`` rather than loading all of the record into "
"Python objects and calling ``len()`` on the result (unless you need to load "
"the objects into memory anyway, in which case ``len()`` will be faster)."
msgstr ""
"Метод ``count()`` использует ``SELECT COUNT(*)``, так что всегда используйте "
"метод ``count()`` вместо загрузки всех записей в объекты Python и вызов ``len"
"()`` над результатом (если вам кончено в любом случае не понадобится "
"загружать их далее, в таком случае ``len()`` будет быстрее)."

# df807c3d6a114491b303f2ce04458f9a
#: ../../ref/models/querysets.txt:1410
msgid ""
"Depending on which database you're using (e.g. PostgreSQL vs. MySQL), ``count"
"()`` may return a long integer instead of a normal Python integer. This is "
"an underlying implementation quirk that shouldn't pose any real-world "
"problems."
msgstr ""
"В зависимости от типа базы данных (например, PostgreSQL vs. MySQL), ``count()"
"`` может вернуть long integer вместо обычно целого Python. Это особенности "
"реализации, которые не должны создавать проблем."

# b86d2ab4185543909ae12e93061bb1cf
#: ../../ref/models/querysets.txt:1416
msgid "in_bulk"
msgstr "in_bulk"

# 6edb6624b7a342d08938636439c7f192
#: ../../ref/models/querysets.txt:1420
msgid ""
"Takes a list of primary-key values and returns a dictionary mapping each "
"primary-key value to an instance of the object with the given ID."
msgstr ""
"Получает список первичных ключей и возвращает словарь ассоциирующий объекты "
"с передаными ID."

# 86a3793113f4425ca7ebd768234eca7b
#: ../../ref/models/querysets.txt:1432
msgid ""
"If you pass ``in_bulk()`` an empty list, you'll get an empty dictionary."
msgstr ""
"При передаче в ``in_bulk()`` пустого списка будет получен пустой словарь."

# acc6068123c54c2f849ad58f62cbb6ad
#: ../../ref/models/querysets.txt:1435
msgid "iterator"
msgstr "iterator"

# 73dba9f3e0154b9aa03243a0476e444f
#: ../../ref/models/querysets.txt:1439
msgid ""
"Evaluates the ``QuerySet`` (by performing the query) and returns an iterator "
"(see :pep:`234`) over the results. A ``QuerySet`` typically caches its "
"results internally so that repeated evaluations do not result in additional "
"queries. In contrast, ``iterator()`` will read results directly, without "
"doing any caching at the ``QuerySet`` level (internally, the default "
"iterator calls ``iterator()`` and caches the return value). For a "
"``QuerySet`` which returns a large number of objects that you only need to "
"access once, this can results in better performance and a significant "
"reduction in memory."
msgstr ""
"Вычисляет ``QuerySet`` (выполняя запрос) и возвращает итератор (смотрите :"
"pep:`234`) по результату. ``QuerySet`` обычно кэширует результат и повторное "
"обращение не вызывает повторное выполнение запросов. Метод ``iterator()`` "
"читает результаты непосредственно из базы данных, без кэширования на уровне "
"``QuerySet`` (итератор по-умолчанию вызывает ``iterator()`` и кэширует "
"возвращенное значение). Для ``QuerySet``, который возвращает большое "
"количество объектов и который будет использован всего лишь один раз, "
"использование этого метода может увеличить производительность и значительно "
"уменьшить потребление памяти."

# 6ddbfbdde0b0433fb919283bab10857c
#: ../../ref/models/querysets.txt:1448
msgid ""
"Note that using ``iterator()`` on a ``QuerySet`` which has already been "
"evaluated will force it to evaluate again, repeating the query."
msgstr ""
"Заметим, что использование ``iterator()`` для ``QuerySet``, который уже был "
"вычислен, приведет к повторному вычислению и выполнению запроса к базе "
"данных."

# b35756d3cd9a4ee49466a724284c48c4
#: ../../ref/models/querysets.txt:1451
msgid ""
"Also, use of ``iterator()`` causes previous ``prefetch_related()`` calls to "
"be ignored since these two optimizations do not make sense together."
msgstr ""
"Заметим, если вы используете ``iterator()`` для выполнения запроса, вызов "
"``prefetch_related()`` будет проигнорирован т.к. использование этих двух "
"оптимизаций вместе не имеет смысла."

# 208b177164b04f64889b2348092a7a6a
#: ../../ref/models/querysets.txt:1455
msgid "latest"
msgstr "latest"

# a59d25c8101d4318aa291b3de3ce78cc
#: ../../ref/models/querysets.txt:1459
msgid ""
"Returns the latest object in the table, by date, using the ``field_name`` "
"provided as the date field."
msgstr ""
"Возвращает последний объект, используя значение из поля даты указанного "
"параметром ``field_name``."

# 92c95fe7b6414491820ddf5d34908e1c
#: ../../ref/models/querysets.txt:1462
msgid ""
"This example returns the latest ``Entry`` in the table, according to the "
"``pub_date`` field::"
msgstr ""
"Этот пример возвращает последний объект ``Entry`` в таблице по полю "
"``pub_date``::"

# 46e53a048abe4842ab1948a410ac7ea9
#: ../../ref/models/querysets.txt:1467
msgid ""
"If your model's :ref:`Meta <meta-options>` specifies :attr:`~django.db."
"models.Options.get_latest_by`, you can leave off the ``field_name`` argument "
"to ``latest()``. Django will use the field specified in :attr:`~django.db."
"models.Options.get_latest_by` by default."
msgstr ""
"Если в :ref:`Meta <meta-options>` модели определен :attr:`~django.db.models."
"Options.get_latest_by`, вы можете не указывать параметр ``field_name``. "
"Django будет использовать поле указанное в :attr:`~django.db.models.Options."
"get_latest_by` как значение по-умолчанию."

# 12ca2adda00e4890a443adaeb6769fb1
#: ../../ref/models/querysets.txt:1472
msgid ""
"Like :meth:`get()`, ``latest()`` raises :exc:`~django.core.exceptions."
"DoesNotExist` if there is no object with the given parameters."
msgstr ""
"Как и :meth:`get()`, ``latest()`` вызывает исключение :exc:`~django.core."
"exceptions.DoesNotExist`, если объект не найден."

# 4b363776d5f14c71ab312253808eb6c2
#: ../../ref/models/querysets.txt:1476
msgid "Note ``latest()`` exists purely for convenience and readability."
msgstr ""
"Заметим что ``latest()`` существует исключительно для удобства и читаемости."

# bfeeeab3484b4fcc918460675ff3ef05
#: ../../ref/models/querysets.txt:1479
msgid "aggregate"
msgstr "aggregate"

# d55f4538662444eba46ec70f6ff639f3
#: ../../ref/models/querysets.txt:1483
msgid ""
"Returns a dictionary of aggregate values (averages, sums, etc) calculated "
"over the ``QuerySet``. Each argument to ``aggregate()`` specifies a value "
"that will be included in the dictionary that is returned."
msgstr ""
"Возвращает словарь агрегированных значений (среднее значение, сума и др.) "
"вычисленных для ``QuerySet``. Каждый аргумент ``aggregate()`` определяет "
"значение, которые будет включено в возвращаемый словарь."

# c51b80cd24bd4d82a249065668c34bdd
#: ../../ref/models/querysets.txt:1490
msgid ""
"Aggregates specified using keyword arguments will use the keyword as the "
"name for the annotation. Anonymous arguments will have a name generated for "
"them based upon the name of the aggregate function and the model field that "
"is being aggregated."
msgstr ""
"Агрегация, указанная с помощью именованного аргумента, использует имя "
"аргумента как название ключа в возвращаемом словаре. Для анонимных "
"аргументов названия ключей будут созданы из названия функции агрегации и "
"названия поля модели используемого в агрегации данных. "

# 1913362ad43347b2a98db63df08b4bff
#: ../../ref/models/querysets.txt:1495
msgid ""
"For example, when you are working with blog entries, you may want to know "
"the number of authors that have contributed blog entries::"
msgstr ""
"Например, работая с записями блога, вы возможно захотите узнать сколько "
"записей в выбранных через ``QuerySet`` блогах::"

# b61aba939cdb4885a8631a6545bbadb7
#: ../../ref/models/querysets.txt:1501
msgid ""
"By using a keyword argument to specify the aggregate function, you can "
"control the name of the aggregation value that is returned::"
msgstr ""
"Используя именованный аргумент для определения функции агрегации, вы можете "
"указать название возвращаемого значения::"

# 21912a482abc4405ba8a73d2c249d1f5
#: ../../ref/models/querysets.txt:1511
msgid "exists"
msgstr "exists"

# 3f644a7cf9d44244b98391c7769cf49f
#: ../../ref/models/querysets.txt:1517
msgid ""
"Returns ``True`` if the :class:`.QuerySet` contains any results, and "
"``False`` if not. This tries to perform the query in the simplest and "
"fastest way possible, but it *does* execute nearly the same query. This "
"means that calling :meth:`.QuerySet.exists` is faster than ``bool"
"(some_query_set)``, but not by a large degree. If ``some_query_set`` has not "
"yet been evaluated, but you know that it will be at some point, then using "
"``some_query_set.exists()`` will do more overall work (one query for the "
"existence check plus an extra one to later retrieve the results) than simply "
"using ``bool(some_query_set)``, which retrieves the results and then checks "
"if any were returned."
msgstr ""
"Возвращает ``True`` если :class:`.QuerySet` содержит какой-либо результат, и "
"``False``, если не содержит. Этот метод выполняет на столько простой и "
"быстрый запрос, на сколько это возможно, но запрос будет почти аналогичным "
"запросу, который выбирает данные. Это означает что :meth:`.QuerySet.exists` "
"быстрее чем ``bool(some_query_set)``, но не на много. Если "
"``some_query_set`` не был еще вычислен, но вы точно знаете что будет "
"вычислен в любом случае, тогда вызов ``some_query_set.exists()`` выполнит "
"больше работы (один запрос для проверки наличия данных и один для получения "
"данных) чем просто ``bool(some_query_set)``, который получит результат и "
"проверит не пустой ли он."

# 2572fda74ca44d289833cc0cba802033
#: ../../ref/models/querysets.txt:1528
msgid "update"
msgstr "update"

# a4c91155b1dd41c88ec0db1a173a3b46
#: ../../ref/models/querysets.txt:1532
msgid ""
"Performs an SQL update query for the specified fields, and returns the "
"number of rows affected."
msgstr ""
"Выполняет SQL запрос обновляющий данные указанных полей и возвращает "
"количество измененных записей."

# 7e03b96273aa49a58c2db0cb2894a390
#: ../../ref/models/querysets.txt:1535
msgid ""
"For example, to turn comments off for all blog entries published in 2010, "
"you could do this::"
msgstr ""
"Например, что бы отключить комментарии для всех записей опубликованных в "
"2010 годы, нужно выполнить такой запрос::"

# 22cf494cf25d42b0929e99b30ec9f3e9
#: ../../ref/models/querysets.txt:1540
msgid ""
"(This assumes your ``Entry`` model has fields ``pub_date`` and "
"``comments_on``.)"
msgstr ""
"(Пример подразумевает что модель ``Entry`` содержит поля ``pub_date`` и "
"``comments_on``.)"

# faf468726ffc4ef5a6b9160a2a9b0a9c
#: ../../ref/models/querysets.txt:1542
msgid ""
"You can update multiple fields — there's no limit on how many. For example, "
"here we update the ``comments_on`` and ``headline`` fields::"
msgstr ""
"Вы можете изменить несколько полей — нет ограничения на количество полей. "
"Например, изменим поля ``comments_on`` и ``headline``::"

# d5effcc09c334221bc79a2fc6dc3569a
#: ../../ref/models/querysets.txt:1547
msgid ""
"The ``update()`` method is applied instantly, and the only restriction on "
"the :class:`.QuerySet` that is updated is that it can only update columns in "
"the model's main table, not on related models. You can't do this, for "
"example::"
msgstr ""
"Метод ``update()`` выполняет запрос сразу после вызова метода. Единственное "
"ограничение для :class:`.QuerySet` это то, что могут быть изменены поля "
"только главной модели, а не связанной. Вы не можете сделать такое::"

# 3a55314724fb4f5d8a6c460c9898300b
#: ../../ref/models/querysets.txt:1553
msgid "Filtering based on related fields is still possible, though::"
msgstr "Однако вы можете использовать фильтры по полям связанной модели::"

# 30e646114e6c458fb47e302c6b7911df
#: ../../ref/models/querysets.txt:1557
msgid ""
"You cannot call ``update()`` on a :class:`.QuerySet` that has had a slice "
"taken or can otherwise no longer be filtered."
msgstr ""
"Метод ``update()`` не может быть вызван для :class:`.QuerySet` с примененным "
"срезом или который не может быть отфильтрован по какой-либо другой причине."

# c685709233f040009860bd95b74cc47c
#: ../../ref/models/querysets.txt:1560
msgid "The ``update()`` method returns the number of affected rows::"
msgstr "Метод ``update()`` возвращает количество измененных записей::"

# 13882289825d4bdd8a6e8498e59f6c97
#: ../../ref/models/querysets.txt:1571
msgid ""
"If you're just updating a record and don't need to do anything with the "
"model object, the most efficient approach is to call ``update()``, rather "
"than loading the model object into memory. For example, instead of doing "
"this::"
msgstr ""
"Если вам нужно всего лишь изменить запись и не нужно ничего делать с "
"объектом модели, более эффективно использовать метод ``update()``, чем "
"загружать объект в память. Например, вместо этого::"

# dd5ce4a1ef454fba9c4043eb63f68545
#: ../../ref/models/querysets.txt:1579
msgid "...do this::"
msgstr "...делайте так::"

# ca0d678b2a9e4e418c2b1aa668532a32
#: ../../ref/models/querysets.txt:1583
msgid ""
"Using ``update()`` also prevents a race condition wherein something might "
"change in your database in the short period of time between loading the "
"object and calling ``save()``."
msgstr ""
"Использование ``update()`` так же предотвращает ситуации, когда что-то может "
"быть изменено в базе данных в тот короткий период времени между загрузкой "
"данных и вызовом ``save()``."

# e0ebad2b134c44c79b449bc990b41f33
#: ../../ref/models/querysets.txt:1587
msgid ""
"Finally, realize that ``update()`` does an update at the SQL level and, "
"thus, does not call any ``save()`` methods on your models, nor does it emit "
"the :attr:`~django.db.models.signals.pre_save` or :attr:`~django.db.models."
"signals.post_save` signals (which are a consequence of calling :meth:`Model."
"save() <~django.db.models.Model.save()>`). If you want to update a bunch of "
"records for a model that has a custom :meth:`~django.db.models.Model.save()"
"`` method, loop over them and call :meth:`~django.db.models.Model.save()`, "
"like this::"
msgstr ""
"Учтите, что метод ``update()`` использует непосредственно SQL запрос. Метод "
"``save()`` модели не будет вызван, сигналы :attr:`~django.db.models.signals."
"pre_save` или :attr:`~django.db.models.signals.post_save` не будут вызваны "
"(которые являются следствием вызова :meth:`Model.save() <~django.db.models."
"Model.save()>`). Если вы хотите сохранить каждый объект в ``QuerySet`` и "
"удостовериться что метод ``save()`` вызван для каждого объекта, просто "
"используйте цикл и вызовите метод ``save()``::"

# 4b8f43a4018a42c0a1a66605ecbb75e3
#: ../../ref/models/querysets.txt:1601
msgid "delete"
msgstr "delete"

# 53f0a6c8591d4972bdf8ba341367186e
#: ../../ref/models/querysets.txt:1605
msgid ""
"Performs an SQL delete query on all rows in the :class:`.QuerySet`. The "
"``delete()`` is applied instantly. You cannot call ``delete()`` on a :class:"
"`.QuerySet` that has had a slice taken or can otherwise no longer be "
"filtered."
msgstr ""
"Выполняет SQL запрос для удаления записей в :class:`.QuerySet`. Метод "
"``delete()`` выполняют запрос сразу после вызова метода. Метод ``delete()`` "
"не может быть выполнен для :class:`.QuerySet`, к которому был применен срез "
"или который не может быть отфильтрован по любой другой причине."

# c625ae58e6e74f64ae4700d54defa837
#: ../../ref/models/querysets.txt:1610
msgid "For example, to delete all the entries in a particular blog::"
msgstr "Например, удалим все записи для определенного блога::"

# 8846a1b9b7c34df0b9d4d3395ce93ab6
#: ../../ref/models/querysets.txt:1617
msgid ""
"By default, Django's :class:`~django.db.models.ForeignKey` emulates the SQL "
"constraint ``ON DELETE CASCADE`` — in other words, any objects with foreign "
"keys pointing at the objects to be deleted will be deleted along with them. "
"For example::"
msgstr ""
"По-умолчанию, Django для :class:`~django.db.models.ForeignKey` эмулирует "
"поведение ``ON DELETE CASCADE`` в SQL — другими словами, объекты, имеющие "
"внешние ключи на удаляемый объект, будут так же удалены. Например::"

# 84906fc72d9a421d9671ed99afe8aafb
#: ../../ref/models/querysets.txt:1631
msgid ""
"The ``delete()`` method does a bulk delete and does not call any ``delete()"
"`` methods on your models. It does, however, emit the :data:`~django.db."
"models.signals.pre_delete` and :data:`~django.db.models.signals.post_delete` "
"signals for all deleted objects (including cascaded deletions)."
msgstr ""
"Метод ``delete()`` выполняет массовое удаление и не вызывает метод ``delete()"
"`` модели. Однако, будут вызваны сигналы :data:`~django.db.models.signals."
"pre_delete` и :data:`~django.db.models.signals.post_delete` для всех "
"удаленных объектов (включая объекты удаленные каскадным удалением)."

# 6f7c8ae944d44149a7f4ff47bcd9d252
#: ../../ref/models/querysets.txt:1640
msgid "Field lookups"
msgstr "Операторы фильтрации"

# 51a52e84582f4171938ee8b0bfc913cf
#: ../../ref/models/querysets.txt:1642
msgid ""
"Field lookups are how you specify the meat of an SQL ``WHERE`` clause. "
"They're specified as keyword arguments to the ``QuerySet`` methods :meth:"
"`filter()`, :meth:`exclude()` and :meth:`get()`."
msgstr ""
"Операторы фильтрации используются для создания оператора ``WHERE`` в SQL. "
"Они используются как именованные аргументы для методов ``QuerySet``: :meth:"
"`filter()`, :meth:`exclude()` и :meth:`get()`."

# ae6ddfe541a64124b34b96b3977286e6
#: ../../ref/models/querysets.txt:1646
msgid ""
"For an introduction, see :ref:`models and database queries documentation "
"<field-lookups-intro>`."
msgstr ""
"Введение смотрите в разделе о :ref:`моделях и выполнении запросов к базе "
"данных <field-lookups-intro>`."

# bca209d42092487e9964c7652b9a211b
#: ../../ref/models/querysets.txt:1652
msgid "exact"
msgstr "exact"

# a9234d56d6b84edbbf3b8d8794028b17
#: ../../ref/models/querysets.txt:1654
msgid ""
"Exact match. If the value provided for comparison is ``None``, it will be "
"interpreted as an SQL ``NULL`` (see :lookup:`isnull` for more details)."
msgstr ""
"Точное совпадение. Если передано значение ``None``, оно будет "
"интерпретировано как SQL ``NULL`` (смотрите подробности в описании :lookup:"
"`isnull`)."

# d332fc1c658a4492ae9b562a479dfdab
# 24d5295c790c46f9a975fcd88f1e3ba7
# 86bd9402d19f48fe82b1bf3e6b1ee382
#: ../../ref/models/querysets.txt:1662 ../../ref/models/querysets.txt:2095
#: ../../ref/models/querysets.txt:2119
msgid "SQL equivalents::"
msgstr "Аналог SQL::"

# 56ead27abcc8461283aa4cf1d6797f50
#: ../../ref/models/querysets.txt:1669
msgid ""
"In MySQL, a database table's \"collation\" setting determines whether "
"``exact`` comparisons are case-sensitive. This is a database setting, *not* "
"a Django setting. It's possible to configure your MySQL tables to use case-"
"sensitive comparisons, but some trade-offs are involved. For more "
"information about this, see the :ref:`collation section <mysql-collation>` "
"in the :doc:`databases </ref/databases>` documentation."
msgstr ""
"В MySQL, настройка \"collation\" таблицы базы данных определяет будет ли "
"использовано регистро-зависимое сравнение для ``exact``. Это настройка базы "
"данных, *не* Django. Можно настроить регистро-зависимое сравнение для таблиц "
"MySQL. Подробности смотрите в :ref:`разделе о сравнении <mysql-collation>` "
"документации о :doc:`базах данных </ref/databases>`."

# ecfdd7bed2094711a71275393092098b
#: ../../ref/models/querysets.txt:1679
msgid "iexact"
msgstr "iexact"

# c790d016148f48d9bbcf0b0cf507598b
#: ../../ref/models/querysets.txt:1681
msgid "Case-insensitive exact match."
msgstr "Регистро-независимое точное совпадение."

# 46ea26d2a9f244268a100e9407d40d85
# 92ad5423ba9541819e942c734c6e7666
# 03305512d68f48819d082dcdf473db96
# 5c74e2dcd6d444c9a19dc3c73f649aa4
# 5aa8d6e8618c48c3be94d5c26a271fc5
# 48d1b44753ff4301be6c7f0f193e237d
# 905fc69346a2456babd76b663155d0c2
# 049c7c7798ce4d2a9b2f4e073e1dba4a
# 09afe94e5a654a16bfc456dc68636596
# 4a393b64d51d47eea9b79c0d803d4108
# 17e3207b845540da8abb27b21bdff0d4
# d64f76ce7139449695a255ca3fd0764d
# 7951d6720d58440a904b19337aac5c5c
# 8379281c0c194dfe8d56ed8b7c2dd56f
# c28ee383e69e4fc2bf54dfbf03ea8dcb
#: ../../ref/models/querysets.txt:1687 ../../ref/models/querysets.txt:1712
#: ../../ref/models/querysets.txt:1737 ../../ref/models/querysets.txt:1758
#: ../../ref/models/querysets.txt:1831 ../../ref/models/querysets.txt:1867
#: ../../ref/models/querysets.txt:1885 ../../ref/models/querysets.txt:1906
#: ../../ref/models/querysets.txt:1927 ../../ref/models/querysets.txt:1950
#: ../../ref/models/querysets.txt:1968 ../../ref/models/querysets.txt:1986
#: ../../ref/models/querysets.txt:2003 ../../ref/models/querysets.txt:2052
#: ../../ref/models/querysets.txt:2068
msgid "SQL equivalent::"
msgstr "Аналог SQL::"

# 24fc5adf9f7c4fafab99fa1468e29d2b
#: ../../ref/models/querysets.txt:1691
msgid ""
"Note this will match ``'Beatles Blog'``, ``'beatles blog'``, ``'BeAtLes "
"BLoG'``, etc."
msgstr ""
"Заметим что будет найден ``'Beatles Blog'``, ``'beatles blog'``, ``'BeAtLes "
"BLoG'`` и тд."

# 31922d4f9efd46af950059bc8e326b70
#: ../../ref/models/querysets.txt:1696
msgid ""
"When using the SQLite backend and Unicode (non-ASCII) strings, bear in mind "
"the :ref:`database note <sqlite-string-matching>` about string comparisons. "
"SQLite does not do case-insensitive matching for Unicode strings."
msgstr ""
"Используя SQLite и Unicode (не-ASCII) строки, помните :ref:`замечание о "
"сравнении строк в SQLite <sqlite-string-matching>`. SQLite не выполняет "
"регистро-независимое сравнение Unicode строк."

# dbbc4737795e4a4885885819f055ddb6
#: ../../ref/models/querysets.txt:1704
msgid "contains"
msgstr "contains"

# 67343a542c2b4215be9327d0e4f1f55b
#: ../../ref/models/querysets.txt:1706
msgid "Case-sensitive containment test."
msgstr "Регистро-зависимая проверка на вхождение."

# e5d327a989cb4a898992968cc8489424
#: ../../ref/models/querysets.txt:1716
msgid ""
"Note this will match the headline ``'Lennon honored today'`` but not "
"``'lennon honored today'``."
msgstr ""
"Заметим, что будет найдена строка ``'Lennon honored today'``, но не "
"``'lennon honored today'``."

# d7808b395aa945fa9d064e4b5430a13c
#: ../../ref/models/querysets.txt:1721
msgid ""
"SQLite doesn't support case-sensitive ``LIKE`` statements; ``contains`` acts "
"like ``icontains`` for SQLite. See the :ref:`database note <sqlite-string-"
"matching>` for more information."
msgstr ""
"SQLite не поддерживает регистро-зависимый оператор ``LIKE``; ``contains`` "
"работает так же как и ``icontains`` для SQLite. Смотрите :ref:`замечание о "
"сравнении строк в SQLite <sqlite-string-matching>`."

# 3fd1c8a55daf4573977c0a7222291e88
#: ../../ref/models/querysets.txt:1729
msgid "icontains"
msgstr "icontains"

# 77b1dc9d5c064180abdc64a1ca07f124
#: ../../ref/models/querysets.txt:1731
msgid "Case-insensitive containment test."
msgstr "Регистро-независимая проверка на вхождение."

# 3a8bf3be9bb64a409e14445f8ec03060
# e63d0675b70646bd88a85572c3fafc4e
# 19daad0c85bd4d89953acee3b9f59a77
#: ../../ref/models/querysets.txt:1743 ../../ref/models/querysets.txt:1891
#: ../../ref/models/querysets.txt:1933
msgid ""
"When using the SQLite backend and Unicode (non-ASCII) strings, bear in mind "
"the :ref:`database note <sqlite-string-matching>` about string comparisons."
msgstr ""
"Используя SQLite и Unicode (не-ASCII) строки, помните :ref:`замечание о "
"сравнении строк в SQLite <sqlite-string-matching>`."

# fcb2730a5a3e4b8597ae9319634d8f27
#: ../../ref/models/querysets.txt:1750
msgid "in"
msgstr "in"

# 87ea959d64274072873bb0c8167796b4
#: ../../ref/models/querysets.txt:1752
msgid "In a given list."
msgstr "Проверяет на вхождение в список значений."

# 060a14ce774b4558bbe7f4a1d5be3445
#: ../../ref/models/querysets.txt:1762
msgid ""
"You can also use a queryset to dynamically evaluate the list of values "
"instead of providing a list of literal values::"
msgstr "Вы можете так же передать ``QuerySet`` для получения списка значений::"

# 09549617c55b4da0be0d7c80bd940757
#: ../../ref/models/querysets.txt:1768
msgid "This queryset will be evaluated as subselect statement::"
msgstr "Он будет использован как подзапрос::"

# 0b7fc4a3228c42aabf3aa94d106113a8
#: ../../ref/models/querysets.txt:1772
msgid "The above code fragment could also be written as follows::"
msgstr "Пример выше может быть записан таким образом::"

# 9ae624ee61424a079d1c098af52c0b07
#: ../../ref/models/querysets.txt:1779
msgid ""
"This ``query`` attribute should be considered an opaque internal attribute. "
"It's fine to use it like above, but its API may change between Django "
"versions."
msgstr ""
"Атрибут ``query`` используется внутренними механизмами и не является частью "
"публичного API. Это нормально использовать его как в примере выше, но его "
"API может быть изменен в последующих Django."

# bd583955c9b54d38b2f0aa18316c83d2
#: ../../ref/models/querysets.txt:1783
msgid ""
"This second form is a bit less readable and unnatural to write, since it "
"accesses the internal ``query`` attribute and requires a ``ValuesQuerySet``. "
"If your code doesn't require compatibility with Django 1.0, use the first "
"form, passing in a queryset directly."
msgstr ""
"Второй способ не так \"красив\", т.к. использует внутренний атрибут "
"``query`` и требует ``ValuesQuerySet``. Если ваш код не должен поддерживать "
"Django 1.0, используйте первый вариант, передавайте непосредственно "
"``QuerySet``."

# 4a105d294b9e4eefa408d733720bc6a7
#: ../../ref/models/querysets.txt:1788
msgid ""
"If you pass in a ``ValuesQuerySet`` or ``ValuesListQuerySet`` (the result of "
"calling ``values()`` or ``values_list()`` on a queryset) as the value to an "
"``__in`` lookup, you need to ensure you are only extracting one field in the "
"result. For example, this will work (filtering on the blog names)::"
msgstr ""
"Передавая ``ValuesQuerySet`` или ``ValuesListQuerySet`` (результат вызова "
"``values()`` или ``values_list()``) как аргумент для фильтра ``__in``, вы "
"должны быть уверенным, что результат содержит данные только одного поля. "
"Например, этот код будет работать (фильтр по названиям блога)::"

# 6e61d91c22c44361af2c75b994c0cdc2
#: ../../ref/models/querysets.txt:1796
msgid ""
"This example will raise an exception, since the inner query is trying to "
"extract two field values, where only one is expected::"
msgstr ""
"Этот пример вызовет исключение т.к. подзапрос выбирает два поля в то время, "
"как ожидается одно::"

# 1894acc1d7c04b8da51f2a490e298bef
#: ../../ref/models/querysets.txt:1805
msgid ""
"Be cautious about using nested queries and understand your database server's "
"performance characteristics (if in doubt, benchmark!). Some database "
"backends, most notably MySQL, don't optimize nested queries very well. It is "
"more efficient, in those cases, to extract a list of values and then pass "
"that into the second query. That is, execute two queries instead of one::"
msgstr ""
"Будьте осторожны при использовании вложенных запросов и учитывайте "
"производительность вышей базы данных (если сомневаетесь, протестируйте "
"его!). Некоторые типы баз данных, особенно MySQL, не очень хорошо "
"оптимизируют вложенные запросы. В таком случае более эффективно получить "
"список значений первым запросом и передать в другой::"

# 3dffaf2d368b41228ba28d3674580965
#: ../../ref/models/querysets.txt:1816
msgid ""
"Note the ``list()`` call around the Blog ``QuerySet`` to force execution of "
"the first query. Without it, a nested query would be executed, because :ref:"
"`querysets-are-lazy`."
msgstr ""
"Отметим использование ``list()`` с первым ``QuerySet`` что бы спровоцировать "
"выполнение запроса. Без этого, он будет использован как подзапрос т.к. :ref:"
"`querysets-are-lazy`."

# efdcfa281a21404fb26fcb8bb34bdef5
#: ../../ref/models/querysets.txt:1823
msgid "gt"
msgstr "gt"

# 298b78972f8445dcb2ac8f0f189e6096
#: ../../ref/models/querysets.txt:1825
msgid "Greater than."
msgstr "Больше чем."

# 93226a1d19bc4775a46b54ad66c3a196
#: ../../ref/models/querysets.txt:1838
msgid "gte"
msgstr "gte"

# 700d1b4529a247b08eb6d54ec431bc0d
#: ../../ref/models/querysets.txt:1840
msgid "Greater than or equal to."
msgstr "Больше чем или равно."

# 2c2ab2f71bb84b9fa62774f8804dd5b1
#: ../../ref/models/querysets.txt:1845
msgid "lt"
msgstr "lt"

# 5f12fe0149774a9b86f7c8c583d35b65
#: ../../ref/models/querysets.txt:1847
msgid "Less than."
msgstr "Меньше чем."

# 634baf15353246e7a3262c1daa6772ba
#: ../../ref/models/querysets.txt:1852
msgid "lte"
msgstr "lte"

# e99ffbafead64b74b48a32b9d67edc85
#: ../../ref/models/querysets.txt:1854
msgid "Less than or equal to."
msgstr "Меньше чем или равно."

# 7ff40223fac34ad18eba45a83140a83b
#: ../../ref/models/querysets.txt:1859
msgid "startswith"
msgstr "startswith"

# 88cbfd11577c4dd183bf087d0899bef9
#: ../../ref/models/querysets.txt:1861
msgid "Case-sensitive starts-with."
msgstr "Регистро-зависимая проверка начинается ли поле с указанного значения."

# 92612c5066fb4c5ca34d09c691000470
#: ../../ref/models/querysets.txt:1871
msgid ""
"SQLite doesn't support case-sensitive ``LIKE`` statements; ``startswith`` "
"acts like ``istartswith`` for SQLite."
msgstr ""
"SQLite не поддерживает регистро-зависимый оператор ``LIKE``; ``startswith`` "
"работает так же как и ``istartswith`` для SQLite."

# 111d6588245743338bc6865cffd6b528
#: ../../ref/models/querysets.txt:1877
msgid "istartswith"
msgstr "istartswith"

# ff564778fbed4940ad6ca9079a6afb00
#: ../../ref/models/querysets.txt:1879
msgid "Case-insensitive starts-with."
msgstr ""
"Регистро-независимая проверка начинается ли поле с указанного значения."

# 4c98a20fb2914c2c86251bb55eb9e77c
#: ../../ref/models/querysets.txt:1898
msgid "endswith"
msgstr "endswith"

# a000eade0e104eeb869237a1a2221e86
#: ../../ref/models/querysets.txt:1900
msgid "Case-sensitive ends-with."
msgstr ""
"Регистро-зависимая проверка оканчивается ли поле с указанного значения."

# ed826e4d9d2e44c9bf4517ef099b194f
#: ../../ref/models/querysets.txt:1912
msgid ""
"SQLite doesn't support case-sensitive ``LIKE`` statements; ``endswith`` acts "
"like ``iendswith`` for SQLite. Refer to the :ref:`database note <sqlite-"
"string-matching>` documentation for more."
msgstr ""
"SQLite не поддерживает регистро-зависимый оператор ``LIKE``; ``endswith`` "
"работает так же как и ``iendswith`` для SQLite. Смотрите :ref:`замечание о "
"сравнении строк в SQLite <sqlite-string-matching>`."

# 1922221732f14962b994fd2ea4ba7f0d
#: ../../ref/models/querysets.txt:1919
msgid "iendswith"
msgstr "iendswith"

# 071c72167d2043aca090635e4060f292
#: ../../ref/models/querysets.txt:1921
msgid "Case-insensitive ends-with."
msgstr ""
"Регистро-независимая проверка оканчивается ли поле с указанного значения."

# 9ed5736e60ef43b8a31f2631034d5f8c
#: ../../ref/models/querysets.txt:1940
msgid "range"
msgstr "range"

# d4da44bd202649b08723993ca9536afc
#: ../../ref/models/querysets.txt:1942
msgid "Range test (inclusive)."
msgstr "Проверка на вхождение в диапазон (включающий)."

# 5b0e615a17dc44aa88d03060f4da36fa
#: ../../ref/models/querysets.txt:1954
msgid ""
"You can use ``range`` anywhere you can use ``BETWEEN`` in SQL — for dates, "
"numbers and even characters."
msgstr ""
"Вы можете использовать ``range`` там же, где можно использовать ``BETWEEN`` "
"в SQL — для дат, чисел и даже строк."

# f4d814190b4344149dbc839518920ac4
#: ../../ref/models/querysets.txt:1960
msgid "year"
msgstr "year"

# fd13d794f2a2494689122c5fc066e0cd
#: ../../ref/models/querysets.txt:1962
msgid "For date/datetime fields, exact year match. Takes a four-digit year."
msgstr ""
"Проверка года для полей date/datetime. Принимает значение года из 4-х цифр."

# 29083d0d847d4a7e8bff552fb33ec6c8
# 56fee1cc131943e1922b92d0ce10e52e
# 8c63272bae8e4af4b3187a69dae74c62
#: ../../ref/models/querysets.txt:1972 ../../ref/models/querysets.txt:1990
#: ../../ref/models/querysets.txt:2007
msgid "(The exact SQL syntax varies for each database engine.)"
msgstr "(Точный синтаксис SQL зависит от базы данных.)"

# 003f2b547be24a74b2a8ffcb2f3a0d8a
#: ../../ref/models/querysets.txt:1977
msgid "month"
msgstr "month"

# 8ab04c7938334d4cb1b2571c04614547
#: ../../ref/models/querysets.txt:1979
msgid ""
"For date and datetime fields, an exact month match. Takes an integer 1 "
"(January) through 12 (December)."
msgstr ""
"Проверка месяца для полей date/datetime. Принимает целое число от 1(январь) "
"до 12(декабрь)."

# 3a7fa46732934635ba5767f67a5aaa83
#: ../../ref/models/querysets.txt:1995
msgid "day"
msgstr "day"

# 774d8c63fc154b85a91ae9aba6b60abd
#: ../../ref/models/querysets.txt:1997
msgid "For date and datetime fields, an exact day match."
msgstr "Проверка дня месяца для полей date/datetime."

# 86d6c940d9aa427d822aae2f525b374c
#: ../../ref/models/querysets.txt:2009
msgid ""
"Note this will match any record with a pub_date on the third day of the "
"month, such as January 3, July 3, etc."
msgstr ""
"Заметим, что будут найдены записи, у которых значение ``pub_date`` это дата "
"3-го числа любого месяца, такие как 3-го января, 3-го июля и тд."

# 431be0498e904a54ad9c34278ca3bbb4
#: ../../ref/models/querysets.txt:2015
msgid "week_day"
msgstr "week_day"

# 92392f5c054441589284b93eadbeef2e
#: ../../ref/models/querysets.txt:2017
msgid "For date and datetime fields, a 'day of the week' match."
msgstr "Проверка дня недели для полей date/datetime."

# 3b6f9608043a48feb7b8fedd160c34c3
#: ../../ref/models/querysets.txt:2019
msgid ""
"Takes an integer value representing the day of week from 1 (Sunday) to 7 "
"(Saturday)."
msgstr "Принимает номер дня недели от 1 (воскресение) до 7 (суббота)."

# 9c3d1a50ec6e4c268855f16ee1bf6b13
#: ../../ref/models/querysets.txt:2026
msgid ""
"(No equivalent SQL code fragment is included for this lookup because "
"implementation of the relevant query varies among different database "
"engines.)"
msgstr ""
"(Аналог SQL не представлен т.к. реализация отличается для различных баз "
"данных.)"

# 567c6d131a684d7a8d1019ac60c9749f
#: ../../ref/models/querysets.txt:2029
msgid ""
"Note this will match any record with a ``pub_date`` that falls on a Monday "
"(day 2 of the week), regardless of the month or year in which it occurs. "
"Week days are indexed with day 1 being Sunday and day 7 being Saturday."
msgstr ""
"Будут найдены записи, у которых дата в ``pub_date`` -- понедельник (второй "
"день недели), независимо от месяца и года. Дни недели пронумерованы от 1"
"(воскресение) до 7(суббота)."

# 2c9d52cc99be446aacd1620c56e67d2b
#: ../../ref/models/querysets.txt:2035
msgid ""
"When :doc:`time zone support </topics/i18n/timezones>` is enabled, Django "
"uses UTC in the database connection, which means the ``year``, ``month``, "
"``day`` and ``week_day`` lookups are performed in UTC. This is a known "
"limitation of the current implementation."
msgstr ""
"Если используются :doc:`временные зоны </topics/i18n/timezones>` , Django "
"использует UTC при подключении к базе данных, это означает что фильтры "
"``year``, ``month``, ``day`` и ``week_day`` будут выполнены в UTC. Это "
"ограничение текущей реализации."

# 0f8c1aba3b344712a47b748a97f71791
#: ../../ref/models/querysets.txt:2043
msgid "isnull"
msgstr "isnull"

# b960054304bd41fb8c7ecfedc385b26b
#: ../../ref/models/querysets.txt:2045
msgid ""
"Takes either ``True`` or ``False``, which correspond to SQL queries of ``IS "
"NULL`` and ``IS NOT NULL``, respectively."
msgstr ""
"Принимает ``True`` или ``False``, что соответствует SQL запросу ``IS NULL`` "
"и ``IS NOT NULL``, соответственно."

# db6edd7fde1c4b9486c42146373b906c
#: ../../ref/models/querysets.txt:2059
msgid "search"
msgstr "search"

# 4a83426ab742406da796b34e4fd38ca5
#: ../../ref/models/querysets.txt:2061
msgid ""
"A boolean full-text search, taking advantage of full-text indexing. This is "
"like :lookup:`contains` but is significantly faster due to full-text "
"indexing."
msgstr ""
"Полнотекстовый поиск, который использует преимущества полнотекстового "
"индекса. Работает как и :lookup:`contains` но значительно быстрее благодаря "
"полнотекстовому индексу."

# 0332f758885746daa36ec358647475b5
#: ../../ref/models/querysets.txt:2072
msgid ""
"Note this is only available in MySQL and requires direct manipulation of the "
"database to add the full-text index. By default Django uses BOOLEAN MODE for "
"full text searches. See the `MySQL documentation`_ for additional details."
msgstr ""
"Работает только в MySQL и требует самостоятельного добавления "
"полнотекстового индекса. По-умолчанию Django использует BOOLEAN MODE для "
"полнотекстового поиска. Подробности в `документации MySQL <http://dev.mysql."
"com/doc/refman/5.1/en/fulltext-boolean.html>`_."

# 6e9ccec583714105bfd48647f2903e39
#: ../../ref/models/querysets.txt:2082
msgid "regex"
msgstr "regex"

# 227495836b474b5986622a6c1950ac2b
#: ../../ref/models/querysets.txt:2084
msgid "Case-sensitive regular expression match."
msgstr "Регистро-зависимая проверка регулярным выражением."

# 740fd2774c72493b9c8e212ef912da36
#: ../../ref/models/querysets.txt:2086
msgid ""
"The regular expression syntax is that of the database backend in use. In the "
"case of SQLite, which has no built in regular expression support, this "
"feature is provided by a (Python) user-defined REGEXP function, and the "
"regular expression syntax is therefore that of Python's ``re`` module."
msgstr ""
"Синтаксис регулярных выражений зависит от базы данных. Для SQLite, который "
"не поддерживает регулярные выражения, эта функция обеспечена на уровне "
"Python, по-этому используется синтаксис модуля Python ``re``."

# 9b3fc2d9a56548c3ba11e0247a34b673
#: ../../ref/models/querysets.txt:2105
msgid ""
"Using raw strings (e.g., ``r'foo'`` instead of ``'foo'``) for passing in the "
"regular expression syntax is recommended."
msgstr ""
"Рекомендуется использовать \"raw\" строки (например, ``r'foo'`` вместо "
"``'foo'``) для регулярных выражений."

# 2d839032a9214965a439641605172826
#: ../../ref/models/querysets.txt:2111
msgid "iregex"
msgstr "iregex"

# 05e579fa80194fe0a677ec04c254126a
#: ../../ref/models/querysets.txt:2113
msgid "Case-insensitive regular expression match."
msgstr "Регистро-независимая проверка регулярным выражением."

# 729b14fd249648b9b31bb0ef98f94119
#: ../../ref/models/querysets.txt:2132
msgid "Aggregation functions"
msgstr "Функции агрегации"

# 0db7cc5369fc410abe92d4b71fce6968
#: ../../ref/models/querysets.txt:2136
msgid ""
"Django provides the following aggregation functions in the ``django.db."
"models`` module. For details on how to use these aggregate functions, see :"
"doc:`the topic guide on aggregation </topics/db/aggregation>`."
msgstr ""
"Django предоставляет ряд функций агрегации в модуле ``django.db.models``. "
"Подробности, как использовать функции агрегации, смотрите в :doc:`разделе об "
"агрегации </topics/db/aggregation>`."

# b62b96d46a654d3491ba4da2641de110
#: ../../ref/models/querysets.txt:2142
msgid "Avg"
msgstr "Avg"

# 4f087bf53f1846879bddb58150ef6abd
#: ../../ref/models/querysets.txt:2146
msgid "Returns the mean value of the given field, which must be numeric."
msgstr ""
"Возвращает среднее значение указанного поля, которое должно быть численным."

# 6690fc6440444e229991c12a0bad51d7
#: ../../ref/models/querysets.txt:2148
msgid "Default alias: ``<field>__avg``"
msgstr "Псевдоним по-умолчанию: ``<field>__avg``"

# e9374dd835b64a0796f49cafb63d2793
# dc35896edcc54a28b706b32c314569ec
# 8af88572fb7043c295515783d6a8f2bf
#: ../../ref/models/querysets.txt:2149 ../../ref/models/querysets.txt:2197
#: ../../ref/models/querysets.txt:2231
msgid "Return type: ``float``"
msgstr "Тип возвращаемого значения: ``float``"

# 0c409d1475354def93edde29830f7ac4
#: ../../ref/models/querysets.txt:2152
msgid "Count"
msgstr "Count"

# 7620ea9ffc0648bf96b86af00b52b4f3
#: ../../ref/models/querysets.txt:2156
msgid ""
"Returns the number of objects that are related through the provided field."
msgstr "Возвращает количество объектов связанных через указанное поле.."

# ebcbab5dfc8948ac9da204f618439c2b
#: ../../ref/models/querysets.txt:2158
msgid "Default alias: ``<field>__count``"
msgstr "Псевдоним по-умолчанию: ``<field>__count``"

# 8f27a0c018b8479f89cb3436efa6200e
#: ../../ref/models/querysets.txt:2159
msgid "Return type: ``int``"
msgstr "Тип возвращаемого значения: ``int``"

# 7b78afaeef4f4c68a747e09ad5aa3808
# 965c986ae74645b68ccd5fd615dc7890
# 79693bc662c34ffab94db87939cbf07a
#: ../../ref/models/querysets.txt:2161 ../../ref/models/querysets.txt:2199
#: ../../ref/models/querysets.txt:2233
msgid "Has one optional argument:"
msgstr "Принимает один не обязательный параметр:"

# 475af4945fa7432ea3c6ccb205836fd7
#: ../../ref/models/querysets.txt:2165
msgid ""
"If ``distinct=True``, the count will only include unique instances. This is "
"the SQL equivalent of ``COUNT(DISTINCT <field>)``. The default value is "
"``False``."
msgstr ""
"При ``distinct=True``, будут подсчитаны только уникальные объекты. SQL "
"эквивалент -- ``COUNT(DISTINCT <field>)``. Значение по-умолчанию ``False``."

# ada47e189ee6457db1dfe81a771f62ba
#: ../../ref/models/querysets.txt:2170
msgid "Max"
msgstr "Max"

# c39eab0e29cc4c9e8f5c4906ffd2e0bd
#: ../../ref/models/querysets.txt:2174
msgid "Returns the maximum value of the given field."
msgstr "Возвращает максимальное значение указанного поля."

# ced5a09597d44654940ee0335d460243
#: ../../ref/models/querysets.txt:2176
msgid "Default alias: ``<field>__max``"
msgstr "Псевдоним по-умолчанию: ``<field>__max``"

# 3697fdcfb61d47f48026e21adf8a69dc
# 731b2c19d6d74c118da15e41828e0958
# f11f6e6ff69a493e8ea9e58573a648c5
#: ../../ref/models/querysets.txt:2177 ../../ref/models/querysets.txt:2187
#: ../../ref/models/querysets.txt:2221
msgid "Return type: same as input field"
msgstr "Тип возвращаемого значения: тип указанного поля."

# 005622d3bbfa4271956016793ade610f
#: ../../ref/models/querysets.txt:2180
msgid "Min"
msgstr "Min"

# 961c01be2a224222b5d329b06bee39e3
#: ../../ref/models/querysets.txt:2184
msgid "Returns the minimum value of the given field."
msgstr "Возвращает минимальное значение указанного поля."

# e32617a3373d412782bdfc2d70347a5e
#: ../../ref/models/querysets.txt:2186
msgid "Default alias: ``<field>__min``"
msgstr "Псевдоним по-умолчанию: ``<field>__min``"

# 6a9353ad6067426e9973c9e219303ad3
#: ../../ref/models/querysets.txt:2190
msgid "StdDev"
msgstr "StdDev"

# 0c05bca7d1314a0c967070c0b345f71d
#: ../../ref/models/querysets.txt:2194
msgid "Returns the standard deviation of the data in the provided field."
msgstr "Возвращает стандартное отклонение для данных указанного поля."

# b52735b21eac46eb9a5d41d9ff8489cd
#: ../../ref/models/querysets.txt:2196
msgid "Default alias: ``<field>__stddev``"
msgstr "Псевдоним по-умолчанию: ``<field>__stddev``"

# 24195ce6426e45c38ee7918f58c49587
#: ../../ref/models/querysets.txt:2203
msgid ""
"By default, ``StdDev`` returns the population standard deviation. However, "
"if ``sample=True``, the return value will be the sample standard deviation."
msgstr ""
"По-умолчанию, ``StdDev`` возвращает \"population\" стандартное отклонение. "
"Однако, если использовать аргумент ``sample=True``, возвращаемое значение "
"будет \"sample\" стандартное отклонение."

# 3e965735e1444d8885183edd5981400c
#: ../../ref/models/querysets.txt:2208
msgid ""
"SQLite doesn't provide ``StdDev`` out of the box. An implementation is "
"available as an extension module for SQLite. Consult the `SQlite "
"documentation`_ for instructions on obtaining and installing this extension."
msgstr ""
"SQLite не поддерживает ``StdDev`` из коробки. Реализация доступна в качестве "
"модуля расширения для SQLite. Смотрите инструкцию по установке в "
"`документации SQlite <http://www.sqlite.org/contrib>`_."

# c15dfc1c05a14212bb0fc4be6550fc31
#: ../../ref/models/querysets.txt:2214
msgid "Sum"
msgstr "Sum"

# 3d3652bb66364c77a828d2e0197165ac
#: ../../ref/models/querysets.txt:2218
msgid "Computes the sum of all values of the given field."
msgstr "Возвращает сумму всех значений указанного поля."

# 28ecdfc98f5e42a5a0bc42c286d93393
#: ../../ref/models/querysets.txt:2220
msgid "Default alias: ``<field>__sum``"
msgstr "Псевдоним по-умолчанию: ``<field>__sum``"

# 3a32fc4286914984813cde2c218131c2
#: ../../ref/models/querysets.txt:2224
msgid "Variance"
msgstr "Variance"

# 783e403140ed4b3bbbec4334b291bc5f
#: ../../ref/models/querysets.txt:2228
msgid "Returns the variance of the data in the provided field."
msgstr "Возвращает дисперсию значений в указанном поле."

# 36da04f912d944988d28bedf8f989068
#: ../../ref/models/querysets.txt:2230
msgid "Default alias: ``<field>__variance``"
msgstr "Псевдоним по-умолчанию: ``<field>__variance``"

# 10d003b4052e43a0ba85413ce4eae0b5
#: ../../ref/models/querysets.txt:2237
msgid ""
"By default, ``Variance`` returns the population variance. However, if "
"``sample=True``, the return value will be the sample variance."
msgstr ""
"По-умолчанию, ``Variance`` возвращает \"population\" дисперсию. Однако, если "
"использовать аргумент ``sample=True``, возвращаемое значение будет \"sample"
"\" дисперсия."

# 7bab55b99e094dd299f28af98b427972
#: ../../ref/models/querysets.txt:2242
msgid ""
"SQLite doesn't provide ``Variance`` out of the box. An implementation is "
"available as an extension module for SQLite. Consult the `SQlite "
"documentation`_ for instructions on obtaining and installing this extension."
msgstr ""
"SQLite не поддерживает ``Variance`` из коробки. Реализация доступна в "
"качестве модуля расширения для SQLite. Смотрите инструкцию по установке в "
"`документации SQlite <http://www.sqlite.org/contrib>`_."
