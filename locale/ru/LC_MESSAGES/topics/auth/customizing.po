# Russian translations for Django package.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
# Automatically generated, 2013.
#
msgid ""
msgstr ""
"Project-Id-Version: Django 1.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-03-19 15:06+0200\n"
"PO-Revision-Date: 2013-02-27 00:21\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: %10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"

#: ../../topics/auth/customizing.txt:3
# 5ec0bd06f7af46689f4fa0570b023d69
msgid "Customizing authentication in Django"
msgstr "Расширяем модуль аутентификации Django"

#: ../../topics/auth/customizing.txt:5
# a90f5369338d4281b63e29ba2f38050e
msgid ""
"The authentication that comes with Django is good enough for most common "
"cases, but you may have needs not met by the out-of-the-box defaults. To "
"customize authentication to your projects needs involves understanding what "
"points of the provided system are extensible or replaceable. This document "
"provides details about how the auth system can be customized."
msgstr "Система аутентификации, входящая в состав Django, отлично подойдет для"
"решения многих типичных задач, однако вам может не хватить функциональности"
"предоставляемой \"из коробки\". Для того что бы изменить модуль аутентификации"
"в первую очередь необходимо разобраться какие части этой системы могут быть расшинены"
"или перемещены. В этом документе мы детально рассмотрим систему аутентификации."

#: ../../topics/auth/customizing.txt:11
# e5e0af4c5e384a28888b0568f4269e41
msgid ""
":ref:`Authentication backends <authentication-backends>` provide an "
"extensible system for when a username and password stored with the User "
"model need to be authenticated against a different service than Django's "
"default."
msgstr ":ref:`Authentication backends <authentication-backends>`  обеспечивает расширяемую"
"систему для аутентификации в разных сервисах, помимо стандартного сервиса Django,"
"и хранит пароль и имя пользователя в модели User."

#: ../../topics/auth/customizing.txt:15
# 5584008e640c4f7ca6d09b3cfa5e13ab
msgid ""
"You can give your models :ref:`custom permissions <custom-permissions>` that "
"can be checked through Django's authorization system."
msgstr "Вы можете назначить вашим моделям собственные :ref:`права доступа <custom-permissions>`,"
"которые могут быть проверены системой аутентификации Django."

#: ../../topics/auth/customizing.txt:18
# d16de6ae94754ab9b2aecb9738288385
msgid ""
"You can :ref:`extend <extending-user>` the default User model, or :ref:"
"`substitute <auth-custom-user>` a completely customized model."
msgstr "Вы можете :ref:`расширить <extending-user>` стандартную модель User или"
"полностью :ref:`заменить <auth-custom-user>` модель."

#: ../../topics/auth/customizing.txt:24
# f056ebbb410a48a09ff73ff9e565e40e
msgid "Other authentication sources"
msgstr "Альтернативная аутентификация"

#: ../../topics/auth/customizing.txt:26
# ee9546fdc72546f290d3a086eaa944f6
msgid ""
"There may be times you have the need to hook into another authentication "
"source -- that is, another source of usernames and passwords or "
"authentication methods."
msgstr "Бывают случаи когда вам надо необходимо реализовать систему "
"аутентификации использующую альтернативные источники имен пользователей,"
"паролей или использующие иные методы аутентификации."

#: ../../topics/auth/customizing.txt:30
# 17edfc9b916d4fec948452e426ea5e93
msgid ""
"For example, your company may already have an LDAP setup that stores a "
"username and password for every employee. It'd be a hassle for both the "
"network administrator and the users themselves if users had separate "
"accounts in LDAP and the Django-based applications."
msgstr "На пример, в вашей компании исользуется система LDAP для хранения"
"логинов и паролей для каждого сотрудника.  Иметь разные аккаунты для"
"LDAP и Django приложений не очень удобно как для пользователей так и"
"для администраторов сети."

#: ../../topics/auth/customizing.txt:35
# 6d93153aa438434a905c56859d8ea67e
msgid ""
"So, to handle situations like this, the Django authentication system lets "
"you plug in other authentication sources. You can override Django's default "
"database-based scheme, or you can use the default system in tandem with "
"other systems."
msgstr "В такой ситуации возможно интегрировать систему аутентификации Django"
"с другой системой аутентификации.  Вы можете переписать стандартную схему Django,"
"использующую базу данных в своей основе, или использоать базовую систему в тандеме"
"с другими системами."

#: ../../topics/auth/customizing.txt:40
# 17cd403e6cc9420d84af05c96efe1a38
msgid ""
"See the :ref:`authentication backend reference <authentication-backends-"
"reference>` for information on the authentication backends included with "
"Django."
msgstr "Детальную информацию о системе аутентификации входящую в"
"стандартную поставку Django вы можете найти по :ref:`ссылке <authentication-backends-reference>` "

#: ../../topics/auth/customizing.txt:45
# 8c51fd65446a4d92b3d746b15695078c
msgid "Specifying authentication backends"
msgstr "Определение системы аутентификации"

#: ../../topics/auth/customizing.txt:47
# 28b746db6d1049c4b36103cf2990165e
msgid ""
"Behind the scenes, Django maintains a list of \"authentication backends\" "
"that it checks for authentication. When somebody calls :func:`django.contrib."
"auth.authenticate()` -- as described in :ref:`How to log a user in <how-to-"
"log-a-user-in>` -- Django tries authenticating across all of its "
"authentication backends. If the first authentication method fails, Django "
"tries the second one, and so on, until all backends have been attempted."
msgstr "Система аутентификации Django поддерживает одновременное"
"использование разных бекэндов аутентифифкации или \"authentication backends\"."
"Когда кто то вызывает :func:`django.contrib.auth.authenticate()` --в соответсвии с документом"
":ref:`Как авториозвать пользователя <how-to-log-a-user-in>` -- Django пробует авторизовать пользователя"
"использую каждый бекэнд аутентификации. Если первый метод не удался, Django пробует использовать второй и т.д."
"с каждым бекэндом в списке."

#: ../../topics/auth/customizing.txt:54
# b42258a85c2a45a2bba28acc112b1a10
msgid ""
"The list of authentication backends to use is specified in the :setting:"
"`AUTHENTICATION_BACKENDS` setting. This should be a tuple of Python path "
"names that point to Python classes that know how to authenticate. These "
"classes can be anywhere on your Python path."
msgstr "Список бекэндов аутентификации хранится в параметре :setting:"
"`AUTHENTICATION_BACKENDS` настроек приложения Django в виде кортежа "
"путей к классам Python'а хранящими методы аутентификации. Эти классы"
"могут распологаться где угодно в вашей директории интерпритатора Python."

#: ../../topics/auth/customizing.txt:59
# 83023254ab044d6186a0e4e76b46c021
msgid "By default, :setting:`AUTHENTICATION_BACKENDS` is set to::"
msgstr "По умолчанию, :setting:`AUTHENTICATION_BACKENDS`  устанавливается как:"

#: ../../topics/auth/customizing.txt:63
# 39a3d191a7c5468eb2e1c8ec5c9298af
msgid ""
"That's the basic authentication backend that checks the Django users "
"database and queries the built-in permissions. It does not provide "
"protection against brute force attacks via any rate limiting mechanism. You "
"may either implement your own rate limiting mechanism in a custom auth "
"backend, or use the mechanisms provided by most Web servers."
msgstr "Это стандартный бекэнд аутентификации Django который провереят "
"пользователей в базе данных и запрашивает встроенные права доступа."
"Так же этот модуль не поддерживает защиту от перебора паролей путем "
"какого-либо ограничивающего механизма. Вы можете либо реализовать свой "
"собственный механизм ограничения либо использовать механизм предоставляемый"
"многими Веб серверами."

#: ../../topics/auth/customizing.txt:69
# 376348d9a83743f48ea4e93660321c82
msgid ""
"The order of :setting:`AUTHENTICATION_BACKENDS` matters, so if the same "
"username and password is valid in multiple backends, Django will stop "
"processing at the first positive match."
msgstr "Так же имеет значение в каком порядке перечислены бекэнды в"
":setting:`AUTHENTICATION_BACKENDS`. Так если один логин и пароль"
"совпадает в нескольких бекэндах аутентификации Django остановится на первом из них."

#: ../../topics/auth/customizing.txt:73
# a668ad5f24c843ddae9f6c218798656b
msgid ""
"If a backend raises a :class:`~django.core.exceptions.PermissionDenied` "
"exception, authentication will immediately fail. Django won't check the "
"backends that follow."
msgstr "Если какой-либо бекэнд вызовет исключение :class:`~django.core.exceptions.PermissionDenied` "
"процесс аутентификации немедленно остановится. В этом случае Django не будет проверять"
"авторизацию использую бекэнды следующие далее по списку."

#: ../../topics/auth/customizing.txt:79
# 6b23cccc193a4ed2a7c73dab43d508fe
msgid ""
"Once a user has authenticated, Django stores which backend was used to "
"authenticate the user in the user's session, and re-uses the same backend "
"for the duration of that session whenever access to the currently "
"authenticated user is needed. This effectively means that authentication "
"sources are cached on a per-session basis, so if you change :setting:"
"`AUTHENTICATION_BACKENDS`, you'll need to clear out session data if you need "
"to force users to re-authenticate using different methods. A simple way to "
"do that is simply to execute ``Session.objects.all().delete()``."
msgstr "В случае если пользователь был успешно авторизован Django сохранит"
"имя этого бекэнда в сессию пользователя и будет использовать тот же бекэнд"
"каждый раз когда это будет необходимо авторизованному пользователю в течении"
"длительности его сессии. Фактически это означает что источник аутентификации кэшируется"
"для каждой сессии отдельно. Поэтомупри если вы измените параметр "
":setting:`AUTHENTICATION_BACKENDS` вам будет необходимо очистить данные в сессии и"
"заново авторизовать пользователя. Простой путь сделать это вызвать ``Session.objects.all().delete()``."

#: ../../topics/auth/customizing.txt:89
# 671ab7feee21419e953be714e89daf61
msgid "Writing an authentication backend"
msgstr "Пишем бекэнд аутентификации"

#: ../../topics/auth/customizing.txt:91
# f9f5d6985b5746af8828d36a164aae10
msgid ""
"An authentication backend is a class that implements two required methods: "
"``get_user(user_id)`` and ``authenticate(**credentials)``, as well as a set "
"of optional permission related :ref:`authorization methods "
"<authorization_methods>`."
msgstr "Бекэнд аутентификации - это класс реализующий два обязательных метода:"
"``get_user(user_id)`` и ``authenticate(**credentials)``, а так же набор дополнительных"
":ref:`методов аутентификации <authorization_methods>`  для проверки прав пользователя."

#: ../../topics/auth/customizing.txt:95
# 0a139829d40c457a822c16cef0b2f8b5
msgid ""
"The ``get_user`` method takes a ``user_id`` -- which could be a username, "
"database ID or whatever, but has to be the primary key of your ``User`` "
"object -- and returns a ``User`` object."
msgstr "Метод ``get_user`` принимает в качестве параметра переменную ``user_id``,"
"которая может быть как именем пользователя так и ID базы данных или чем либо еще,"
"но передаваемое значение обязательно должно быть первичным ключом"
"модели ``User``, а так же метод должен возвращать объект ``User``."

#: ../../topics/auth/customizing.txt:99
# 622e4a3c44214a19a2f43d85f9349d60
msgid ""
"The ``authenticate`` method takes credentials as keyword arguments. Most of "
"the time, it'll just look like this::"
msgstr "В качестве аргументов метод ``authenticate`` принимает учетные данные в виде ключевых слов."
"Часто он будет выглядеть как показано ниже:"

#: ../../topics/auth/customizing.txt:107
# 636606df6d234b918978016d6c4bd281
msgid "But it could also authenticate a token, like so::"
msgstr "Но он так же может принимать в качестве аутентификационных данных токен,"
"как в примере ниже:"

#: ../../topics/auth/customizing.txt:114
# 90055239e5d5462487d82d78428d964f
msgid ""
"Either way, ``authenticate`` should check the credentials it gets, and it "
"should return a ``User`` object that matches those credentials, if the "
"credentials are valid. If they're not valid, it should return ``None``."
msgstr "В любом случае, метод ``authenticate`` должен проверить переданные"
"ему учетные данные и вернуть объект ``User`` соответсвующий этим данным,"
"в случае икорректности. В другом случае он должен вернуть ``None``."

#: ../../topics/auth/customizing.txt:118
# 26f836d7400e49d688998ae5c22365cc
msgid ""
"The Django admin system is tightly coupled to the Django ``User`` object "
"described at the beginning of this document. For now, the best way to deal "
"with this is to create a Django ``User`` object for each user that exists "
"for your backend (e.g., in your LDAP directory, your external SQL database, "
"etc.) You can either write a script to do this in advance, or your "
"``authenticate`` method can do it the first time a user logs in."
msgstr "Система администрирования фреймворка тесно связана с объектом ``User``"
"описанного в начале этого документа. Лучшим способом реализовать ваш"
"бекэнд аутентификации это создать объект ``User`` для кажого юзера существующего"
"во всех ваших источниках аутентификационных данных (например, каталог LDAP,"
"внешняя SQL базы данных, и т.д.). Вы можете написать скрипт который сделает это заранее"
"или ваш метод ``authenticate`` может сделать это когда пользователь первый раз входит в систему."

#: ../../topics/auth/customizing.txt:125
# f6f24bbbf4c24e78b2c8d67bbe199d49
msgid ""
"Here's an example backend that authenticates against a username and password "
"variable defined in your ``settings.py`` file and creates a Django ``User`` "
"object the first time a user authenticates::"
msgstr "Здесь вы можете помотреть пример аутентификации использующий в"
"качестве логина и пароля переменные определнные в вашем файле настроек"
"``settings.py``  и возвращает объект Django ``User`` при входе аутентификации пользователя."

#: ../../topics/auth/customizing.txt:168
# 6cf7c0d6dc6b4620bbfb6cf265610d77
msgid "Handling authorization in custom backends"
msgstr "Управление методами авторизациями"

#: ../../topics/auth/customizing.txt:170
# 599389d4f1db44febd97a46b19acaec2
msgid "Custom auth backends can provide their own permissions."
msgstr "Ваши бекэнды аутентифифкации могут поддерживать"
"ваши собтвенные методы проверки прав пользователей."

#: ../../topics/auth/customizing.txt:172
# a9e9d321d8c94e4a95d7df294fbbdb41
msgid ""
"The user model will delegate permission lookup functions (:meth:`~django."
"contrib.auth.models.User.get_group_permissions()`, :meth:`~django.contrib."
"auth.models.User.get_all_permissions()`, :meth:`~django.contrib.auth.models."
"User.has_perm()`, and :meth:`~django.contrib.auth.models.User."
"has_module_perms()`) to any authentication backend that implements these "
"functions."
msgstr "Если бекэнд поддерживает функции проверки прав пользователей :meth:`~django."
"contrib.auth.models.User.get_group_permissions()`, :meth:`~django.contrib."
"auth.models.User.get_all_permissions()`, :meth:`~django.contrib.auth.models."
"User.has_perm()`, и :meth:`~django.contrib.auth.models.User.has_module_perms()`)"
"пользовательская модель Django передаст проверку прав бекэнду."

#: ../../topics/auth/customizing.txt:179
# 568437b1632044d6ae37c05da09c4ffe
msgid ""
"The permissions given to the user will be the superset of all permissions "
"returned by all backends. That is, Django grants a permission to a user that "
"any one backend grants."
msgstr "Все предоставленые права любым бекэндом будут сохранены для пользователя."
"Другими словами Django сохранит права мользоватлея предоставленные ему"
"любым бекэндом."

#: ../../topics/auth/customizing.txt:185
msgid ""
"If a backend raises a :class:`~django.core.exceptions.PermissionDenied` "
"exception in :meth:`~django.contrib.auth.models.User.has_perm()` or :meth:"
"`~django.contrib.auth.models.User.has_module_perms()`, the authorization "
"will immediately fail and Django won't check the backends that follow."
msgstr "Если бекэнд вызовет :class:`~django.core.exceptions.PermissionDenied` "
"исключение в методах :meth:`~django.contrib.auth.models.User.has_perm()` или :meth:"
"`~django.contrib.auth.models.User.has_module_perms()`, процесс авторизации"
"будет немедленно остановлен и бекэнды следуюющие за бекэндом вызвавшим"
"исключения вызваны не будут."

#: ../../topics/auth/customizing.txt:191
# f985f557564a4d7a81e7f0c2af23a077
msgid ""
"The simple backend above could implement permissions for the magic admin "
"fairly simply::"
msgstr "Организовать проверку прав для простого бекэнда из примера выше довольно просто:"

#: ../../topics/auth/customizing.txt:202
# 654b7b22963a4392b382b0641395d0e9
msgid ""
"This gives full permissions to the user granted access in the above example. "
"Notice that in addition to the same arguments given to the associated :class:"
"`django.contrib.auth.models.User` functions, the backend auth functions all "
"take the user object, which may be an anonymous user, as an argument."
msgstr "Этот простой пример показывает как можно дать полный доступ пользователю."
"Обратите внимание что помимо  передачи стандартных аргументов аналогичных"
"функции :class:`django.contrib.auth.models.User` необходимо передавать объект"
"пользователя в качестве аргумента."

#: ../../topics/auth/customizing.txt:207
# 30ff60bc4ee143848b4e407dd08529db
msgid ""
"A full authorization implementation can be found in the ``ModelBackend`` "
"class in `django/contrib/auth/backends.py`_, which is the default backend "
"and queries the ``auth_permission`` table most of the time. If you wish to "
"provide custom behavior for only part of the backend API, you can take "
"advantage of Python inheritance and subclass ``ModelBackend`` instead of "
"implementing the complete API in a custom backend."
msgstr "Класс ``ModelBackend``  в файле `django/contrib/auth/backends.py`_ является"
"стандартной реализацией бекэнда авторизации и проверки прав доступа."
"Если вы хотите изменить отдельные функции стандартного бекэнда вы можете"
"реализовать это с помощью наслдедования и субкласса ``ModelBackend``"
"вместо того что бы переписывать бекэнд полностью."

#: ../../topics/auth/customizing.txt:219
# 201f8d055ec7430dace2eddd89e5b3d6
msgid "Authorization for anonymous users"
msgstr "Авторизация анонимного пользователя"

#: ../../topics/auth/customizing.txt:221
# c1136bd9d3f14ffb8502c6bf58faa27e
msgid ""
"An anonymous user is one that is not authenticated i.e. they have provided "
"no valid authentication details. However, that does not necessarily mean "
"they are not authorized to do anything. At the most basic level, most Web "
"sites authorize anonymous users to browse most of the site, and many allow "
"anonymous posting of comments etc."
msgstr "Анонимный пользователь это тот кто не прошел процедуру аутентификации"
"соответсвенно мы не имеем о нем какой-либо информации. Однако это не"
"значит что анонимные пользователи не могут пользоваться вашим приложением."
"Многие сайты в сети позволяют анонимам просматривать информацию, некоторые "
"даже разрешают оставлять анонимные комментарии."

#: ../../topics/auth/customizing.txt:227
# 78278ca440a249619f67a25c0620c2b7
msgid ""
"Django's permission framework does not have a place to store permissions for "
"anonymous users. However, the user object passed to an authentication "
"backend may be an :class:`django.contrib.auth.models.AnonymousUser` object, "
"allowing the backend to specify custom authorization behavior for anonymous "
"users. This is especially useful for the authors of re-usable apps, who can "
"delegate all questions of authorization to the auth backend, rather than "
"needing settings, for example, to control anonymous access."
msgstr "Фреймворк Django не предоставляет никакне хранит информации об"
"анонимных пользователях. Тем не менее вы можете определить повдение"
"приложение для анонимных пользователей передав в качестве аргумента"
"объект :class:`django.contrib.auth.models.AnonymousUser`. Это будет особенно"
"полезно для разработчиков приложений многоразового использования."
"Всю работу касательно авторизации пользователей можно возложить на плечи бекэнда,"
"вместо того что бы каждый раз настраивать приложение, например, для контроля"
"доступа анонимных пользователей."

#: ../../topics/auth/customizing.txt:238
# 33cbb996040b4fc89bfaedb3728baebb
msgid "Authorization for inactive users"
msgstr "Авторизация неактивных пользователей"

#: ../../topics/auth/customizing.txt:240
# baf6645cbc0e4ad5a48e7382f87a34da
msgid ""
"An inactive user is a one that is authenticated but has its attribute "
"``is_active`` set to ``False``. However this does not mean they are not "
"authorized to do anything. For example they are allowed to activate their "
"account."
msgstr "Неактивные пользователи так же могут пройти аутентификацию, но"
"атрибут ``is_active`` у них установлен в ``False``. Но это не значит что они не могут"
"что либо сделать в приложении. Например, они могут активировать свой аккаунт."

#: ../../topics/auth/customizing.txt:245
# 225654e8769c4a5db9b1eeabe67610bc
msgid ""
"The support for anonymous users in the permission system allows for a "
"scenario where anonymous users have permissions to do something while "
"inactive authenticated users do not."
msgstr "Поддержка анонимных пользователей в системе прав доступа позволяет"
"реализовать сценарий когда анонимный пользователь может выполнять какие-либо"
"действия в то время как неактивные авторизованные пользователи не могут этого делать."

#: ../../topics/auth/customizing.txt:249
# a4553b8476ba48df822f255965edf1ad
msgid ""
"Do not forget to test for the ``is_active`` attribute of the user in your "
"own backend permission methods."
msgstr "Не забывайте проверять атрибут ``is_active`` в методах проверки прав"
"пользователей вашего бекэнда."

#: ../../topics/auth/customizing.txt:254
# c3860481df894ccabd5fe9af2c5a03b6
msgid "Handling object permissions"
msgstr "Обработка разрешений для объектов"

#: ../../topics/auth/customizing.txt:256
# c1438f0240144ef5aa43fbd2179c94fa
msgid ""
"Django's permission framework has a foundation for object permissions, "
"though there is no implementation for it in the core. That means that "
"checking for object permissions will always return ``False`` or an empty "
"list (depending on the check performed). An authentication backend will "
"receive the keyword parameters ``obj`` and ``user_obj`` for each object "
"related authorization method and can return the object level permission as "
"appropriate."
msgstr "В Django механизм управления правами подготовлен для работы с правами"
"объектов, хотя и ещё не реализован в ядре фреймворка. Это означает, что проверка"
"прав объекта всегда будет возвращать False или пустой список (в зависимости от вида"
"выполняемой проверки). Бэкенд аутентификации получает именованные параметры"
"``obj`` и ``user_obj`` для каждого объекта использованного в методе авторизации и соответственно"
"может вернуть информацию о правах этого объекта."

#: ../../topics/auth/customizing.txt:266
# 9fcd36b508824c408868817f397b43ae
msgid "Custom permissions"
msgstr "Создаем пользовательские права доступа"

#: ../../topics/auth/customizing.txt:268
# 20ecf50e12844bd39fba51decae86b24
msgid ""
"To create custom permissions for a given model object, use the "
"``permissions`` :ref:`model Meta attribute <meta-options>`."
msgstr "Что бы создать пользовательские права доступа для вашей модели"
"необходимо определить их в переменной ``permissions`` :ref:`атрибуте Meta<meta-options>`"
"вашей модели."

#: ../../topics/auth/customizing.txt:271
# 7282b04b9cac44598dcf8b2a636b8bf7
msgid ""
"This example Task model creates three custom permissions, i.e., actions "
"users can or cannot do with Task instances, specific to your application::"
msgstr "В примере ниже описывается как создать пользовательсике права доступа"
"для модели Task, другими словами вы определяеете что пользователь может"
"делать в вашем приложении, а что нет:"

#: ../../topics/auth/customizing.txt:283
# 55d5a1fcfc0a4a228979ffa9d41793ba
msgid ""
"The only thing this does is create those extra permissions when you run :"
"djadmin:`manage.py migrate <migrate>`. Your code is in charge of checking "
"the value of these permissions when a user is trying to access the "
"functionality provided by the application (viewing tasks, changing the "
"status of tasks, closing tasks.) Continuing the above example, the following "
"checks if a user may view tasks::"
msgstr "Новые пользовательские права будут созданы после вызова "
":djadmin:`manage.py migrate <migrate>`. Вашему приложению будет"
"необходимо проверять эти значения каждый раз когда пользователь"
"пытается получить доступ к функциям приложения (просмотр заданий,"
"изменения статуса заданий, закрытие заданий). В продолжении выше описаного"
"примера, так вы можете проверить права пользователя для просмотра заданий:"

#: ../../topics/auth/customizing.txt:295
# 7556e3bacc294cce96aa2e70dd1f6542
msgid "Extending the existing User model"
msgstr "Расширяем модель User"

#: ../../topics/auth/customizing.txt:297
# eb2571bbb2324da2a328491c1c86ba74
msgid ""
"There are two ways to extend the default :class:`~django.contrib.auth.models."
"User` model without substituting your own model. If the changes you need are "
"purely behavioral, and don't require any change to what is stored in the "
"database, you can create a :ref:`proxy model <proxy-models>` based on :class:"
"`~django.contrib.auth.models.User`. This allows for any of the features "
"offered by proxy models including default ordering, custom managers, or "
"custom model methods."
msgstr "Существуюет два способа расширения стандартной модели"
"class:`~django.contrib.auth.models.User` без замены модели на вашу"
"собственную. Если вам нужно изменить только поведение модели"
"без измения данных вы можете создать :ref:`proxy модель <proxy-models>`"
"на основе модели :class:`~django.contrib.auth.models.User`. С помощью модели proxy"
"вы можете,добавить, добавить пользовательские менеджеры или методы сохранив стандартные"
"функции."

#: ../../topics/auth/customizing.txt:305
# 5c9b8b7a6bd84e7cb5f8337d8758926f
msgid ""
"If you wish to store information related to ``User``, you can use a :ref:"
"`one-to-one relationship <ref-onetoone>` to a model containing the fields "
"for additional information. This one-to-one model is often called a profile "
"model, as it might store non-auth related information about a site user. For "
"example you might create an Employee model::"
msgstr "Если вы хотите хранить ддополнительную информацию относящуююся к модели"
"``User`` вы можете использовать :ref:`связь один к одному <ref-onetoone>` с полями"
"модели хранящей эту ифнормацию. Эту связанную модель часто называют профайл"
"пользователя, так как она хранит информацию не относящююся к аутентификации"
"пользователей. Например, вы можете создать модель Employee:"

#: ../../topics/auth/customizing.txt:317
# d65ecf8f14b349e38e7b34e6eff30c82
msgid ""
"Assuming an existing Employee Fred Smith who has both a User and Employee "
"model, you can access the related information using Django's standard "
"related model conventions::"
msgstr "Если предположить что сотрудник Fred Smith имеет записи как модели"
"User так и в модели Employee, вы можете получить связанную информацию "
"используя стандартные соглашения Django для использования моделей:"

#: ../../topics/auth/customizing.txt:324
# 6e93b67b98494c73ae0d884aff2f686c
msgid ""
"To add a profile model's fields to the user page in the admin, define an :"
"class:`~django.contrib.admin.InlineModelAdmin` (for this example, we'll use "
"a :class:`~django.contrib.admin.StackedInline`) in your app's ``admin.py`` "
"and add it to a ``UserAdmin`` class which is registered with the :class:"
"`~django.contrib.auth.models.User` class::"
msgstr "Что бы добавить поля из модели профайла в интерфейс администратора"
"нужно определить :class:`~django.contrib.admin.InlineModelAdmin` в файле"
"``admin.py`` вашего приложения (для этого примера используется"
":class:`~django.contrib.admin.StackedInline`), добавить его к классу  ``UserAdmin``"
"и заново зарегистрировать вместе с классом  :class:`~django.contrib.auth.models.User`"

#: ../../topics/auth/customizing.txt:351
# 57bbe0bedf8d48bdb503b39b41c0d606
msgid ""
"These profile models are not special in any way - they are just Django "
"models that happen to have a one-to-one link with a User model. As such, "
"they do not get auto created when a user is created, but a :attr:`django.db."
"models.signals.post_save` could be used to create or update related models "
"as appropriate."
msgstr "Модель профайл это обычная модель Django. От других моделей ее отличает"
"только наличие свзяи один к одному с моделью User. Как правило записи"
"в этой модели не создаются автоматичски вместе с созданием пользователя,"
"но вы можете воспользоваться методом :attr:`django.db.models.signals.post_save`"
"для создания или обновления записей в профайле по мере необходимости."

#: ../../topics/auth/customizing.txt:357
# d103270b09a94b35b939844a79ed9e1e
msgid ""
"Note that using related models results in additional queries or joins to "
"retrieve the related data, and depending on your needs substituting the User "
"model and adding the related fields may be your better option.  However "
"existing links to the default User model within your project's apps may "
"justify the extra database load."
msgstr "Заметим, что использование связаных моделей приводит к увеличению"
"запросов к базе данных и дополнительной нагрузке на нее, и, в зависиомтис"
"от ваших потребностей, замена модели User на вашу собственную модель"
"с нужными вам полями может быть лучшим выбором."

#: ../../topics/auth/customizing.txt:366
# 5e1cf218bbc349bd9a3e3b4ab118193f
msgid "Substituting a custom User model"
msgstr "Заменяем стандартную модель User"

#: ../../topics/auth/customizing.txt:368
# 6e5c2887477443cabdeb5947773a6940
msgid ""
"Some kinds of projects may have authentication requirements for which "
"Django's built-in :class:`~django.contrib.auth.models.User` model is not "
"always appropriate. For instance, on some sites it makes more sense to use "
"an email address as your identification token instead of a username."
msgstr "Для некоторых проектов возможностей встроенной в Django модели"
":class:`~django.contrib.auth.models.User` будет недостаточно. Например,"
"вам необходимо использовать в качестве идентификатора пользоавтеля"
"email адрес вместо имени пользователя."

#: ../../topics/auth/customizing.txt:373
# 69e185ee6a0f4d61a3fa3014a9941c91
msgid ""
"Django allows you to override the default User model by providing a value "
"for the :setting:`AUTH_USER_MODEL` setting that references a custom model::"
msgstr "Вы можете переписать стандартную модель User указав в настройках "
"приложения :setting:`AUTH_USER_MODEL` ссылка на вашу модель:"

#: ../../topics/auth/customizing.txt:378
# 519e8345beac402c8df46b18e5a54e26
msgid ""
"This dotted pair describes the name of the Django app (which must be in "
"your :setting:`INSTALLED_APPS`), and the name of the Django model that you "
"wish to use as your User model."
msgstr "Эта ностройка определят что для этого приложения (myapp, которое должно быть"
"прописано в :setting:`INSTALLED_APPS`) необходимо использовать другую модель"
"(MyUser) вместо стандартной."

#: ../../topics/auth/customizing.txt:384
# 88cb4d3a0f3446f9b6a772b91f11d0e4
msgid ""
"Changing :setting:`AUTH_USER_MODEL` has a big effect on your database "
"structure. It changes the tables that are available, and it will affect the "
"construction of foreign keys and many-to-many relationships. If you intend "
"to set :setting:`AUTH_USER_MODEL`, you should set it before creating any "
"migrations or running ``manage.py migrate`` for the first time."
msgstr "Изменение :setting:`AUTH_USER_MODEL` может сильно отразиться на структуре"
"вашей базы данных. Так же это изменит доступность таблиц и отразится на"
"конструкции внешних ключей и отношение многие ко многим. Если вы собираетесь"
"использовать альтернативную модель вы должны указать ее в :setting:`AUTH_USER_MODEL`"
"до того как выполните какие либо миграции или первого запуска ``manage.py migrate``."

#: ../../topics/auth/customizing.txt:390
# 331b540519f14caba211192e8fd4f3aa
msgid ""
"Changing this setting after you have tables created is not supported by :"
"djadmin:`makemigrations` and will result in you having to manually fix your "
"schema, port your data from the old user table, and possibly manually "
"reapply some migrations."
msgstr "Изменение этой настройки после того как вы уже создали ваши таблицы"
"не отразится в :djadmin:`makemigrations` и вам нужно будет вручную править"
"схему вашей БД, переносить данные из старой таблицы пользователей и,"
"возможно, вручную применять некторые миграции."

#: ../../topics/auth/customizing.txt:397
# 0f8e67f670b64406b18b98ca2ac52990
msgid ""
"Due to limitations of Django's dynamic dependency feature for swappable "
"models, you must ensure that the model referenced by :setting:"
"`AUTH_USER_MODEL` is created in the first migration of its app (usually "
"called ``0001_initial``); otherwise, you will have dependency issues."
msgstr "Из-за ограничей в динамических зависимостях Django вам необходимо"
"убедиться что заменяемая модель указанная в :setting:`AUTH_USER_MODEL`"
"была создано в вашей первой миграции (обчно она называется 0001_initial)."
"В противном случае у вас будут проблемы с зависимотями."

#: ../../topics/auth/customizing.txt:402
# 31377eea681b4826994f1224a735094c
msgid ""
"In addition, you may run into a CircularDependencyError when running your "
"migrations as Django won't be able to automatically break the dependency "
"loop due to the dynamic dependency. If you see this error, you should break "
"the loop by moving the models depended on by your User model into a second "
"migration (you can try making two normal models that have a ForeignKey to "
"each other and seeing how ``makemigrations`` resolves that circular "
"dependency if you want to see how it's usually done)"
msgstr "Кроме того вы можете столкнуться с CircularDependencyError когда запустите"
"миграцию, Django не сможет самостоятельно выйти из бесконечного цикла вызванного"
"автоматическими зависимостями. Если вы видите эту ошибку вам необходимо определить"
"модель ссылающуюся на старую модель User и исправить это в следующей миграции."
"Вы можете создать две обычные модели с внешними ключами ссылающимися друг на друга"
"и, запустив ``makemigrations``, увидеть что происходит когда появляются циклические зависимости."

#: ../../topics/auth/customizing.txt:412
# ad8dae4d04194c59a9a0fd8bc3eb97bd
msgid "Referencing the User model"
msgstr "Ссылка на модель User"

#: ../../topics/auth/customizing.txt:416
# 813e9db1f7484e16adee27304e40e0b5
msgid ""
"If you reference :class:`~django.contrib.auth.models.User` directly (for "
"example, by referring to it in a foreign key), your code will not work in "
"projects where the :setting:`AUTH_USER_MODEL` setting has been changed to a "
"different User model."
msgstr "Если вы ссылаетесь на модель на модель :class:`~django.contrib.auth.models.User`"
"напрямую (например испльзую внешние ключи), ваш код не будет работать в"
"проектах где стандартная модель заменена на другую в настройке:setting:`AUTH_USER_MODEL`."

#: ../../topics/auth/customizing.txt:423
# 2c54437ee8a445ff929050ce283ba902
msgid ""
"Instead of referring to :class:`~django.contrib.auth.models.User` directly, "
"you should reference the user model using ``django.contrib.auth."
"get_user_model()``. This method will return the currently active User model "
"-- the custom User model if one is specified, or :class:`~django.contrib."
"auth.models.User` otherwise."
msgstr "Вместо того что бы ссылаться на модель :class:`~django.contrib.auth.models.User`"
"напрямую, вы должны делать это использу метод ``django.contrib.auth.get_user_model()``."
"Этот метод возвращает действующею модель -- указаную в настройках приложении"
"или стандартную модель :class:`~django.contrib.auth.models.User`, в случае если не изменялась."

#: ../../topics/auth/customizing.txt:429
# 233be4509bae4067b93692459d7ba477
msgid ""
"When you define a foreign key or many-to-many relations to the User model, "
"you should specify the custom model using the :setting:`AUTH_USER_MODEL` "
"setting. For example::"
msgstr "Когда вы определяете в вашей модели пользователей внешние ключи или"
"отношения многие ко многим вы должны указывать параметр"
":setting:`AUTH_USER_MODEL`. Например:"

#: ../../topics/auth/customizing.txt:441
# 27369d91c7774c6e8dea0e2544f72963
msgid ""
"When connecting to signals sent by the User model, you should specify the "
"custom model using the :setting:`AUTH_USER_MODEL` setting. For example::"
msgstr "Когда вы подключаете отсылку сигналов моделью пользователей вы"
"должны указать параметр :setting:`AUTH_USER_MODEL`. Например:"

#: ../../topics/auth/customizing.txt:452
# fd2b020c92a74b14aaebb37b5e66d2d7
msgid ""
"Generally speaking, you should reference the User model with the :setting:"
"`AUTH_USER_MODEL` setting in code that is executed at import time. "
"``get_user_model()`` only works once Django has imported all models."
msgstr "Другими словами вы всегда должны ссылаться на пользовательскую"
"модель используя настройку :setting:`AUTH_USER_MODEL` в вашем коде"
"которая будет проверться во время импорта. ``get_user_model()` работает"
"только один раз, когда Django импортирует модели."

#: ../../topics/auth/customizing.txt:459
# 3762aaf1d15c47bfa9f0db67b258e8af
msgid "Specifying a custom User model"
msgstr "Определение пользовательской модели"

#: ../../topics/auth/customizing.txt:461
# 45ec0dc8c1314162b7b8b847acd628e1
msgid "Model design considerations"
msgstr "Разработка пользовательской модели"

#: ../../topics/auth/customizing.txt:463
# b07acbf1e9324851b473306d1ecd0536
msgid ""
"Think carefully before handling information not directly related to "
"authentication in your custom User Model."
msgstr "Тщательно подумайте прежде чем хранить в пользовательской модели"
"информацию не относящуюся к аутентификации пользователя."

#: ../../topics/auth/customizing.txt:466
# a5d470a2037f4295ad363e46847be06f
msgid ""
"It may be better to store app-specific user information in a model that has "
"a relation with the User model. That allows each app to specify its own user "
"data requirements without risking conflicts with other apps. On the other "
"hand, queries to retrieve this related information will involve a database "
"join, which may have an effect on performance."
msgstr "Может буть лучше хранить дополнительную информацию о пользователях"
"необходимые вашему приложениею в другой модели с указанием связи на"
"модель User. Это позволит каждому приложению определять специфичную"
"только для него информацию без риска возникновения конфликтов с другими"
"приложениями. Но с другой стороны такой подход приведе к увеличению запросов"
"к базе данных а слдеовательно и нагрузки на нее."

#: ../../topics/auth/customizing.txt:472
# ad7153fa53394a069777c77b1bdc92f1
msgid ""
"Django expects your custom User model to meet some minimum requirements."
msgstr "Django ожидает что ваше модель User будет отвечать некоторым минимальным"
"рекомендациям."

#: ../../topics/auth/customizing.txt:474
# 9fdebefc3eb842c4b5e32efe4ea72a85
msgid "Your model must have an integer primary key."
msgstr "Ваше модель должна иметь числовой первичный ключ."

#: ../../topics/auth/customizing.txt:476
# 3aa1507638cd4390becc6aa86ebaac8e
msgid ""
"Your model must have a single unique field that can be used for "
"identification purposes. This can be a username, an email address, or any "
"other unique attribute."
msgstr "Ваша модель хотя бы одно уникальное поле для идентификации."
"Это может быть имя пользователя, имейл адрес или любой другой"
"уникальный атрибут."

#: ../../topics/auth/customizing.txt:480
# 0a269a9798fd40f4ad8aa830df53d043
msgid ""
"Your model must provide a way to address the user in a \"short\" and \"long"
"\" form. The most common interpretation of this would be to use the user's "
"given name as the \"short\" identifier, and the user's full name as the "
"\"long\" identifier. However, there are no constraints on what these two "
"methods return - if you want, they can return exactly the same value."
msgstr "Ваша модель должна поддерживать короткую \"short\" и длинную \"long\""
"форму обращения к пользователю. В наиболее общей интерпритации"
"этого можно использовать имя пользователя как \"короткий\" идентификатор,"
"а его полное имя как \"длинный\" идентификатор. Однако ни кто не мешает вам"
"сдлеать так что бы этих методоа возвращали одно и тоже значение."

#: ../../topics/auth/customizing.txt:487
# 904e1b078f6f4220aced801e26509c66
msgid ""
"The easiest way to construct a compliant custom User model is to inherit "
"from :class:`~django.contrib.auth.models.AbstractBaseUser`. :class:`~django."
"contrib.auth.models.AbstractBaseUser` provides the core implementation of a "
"``User`` model, including hashed passwords and tokenized password resets. "
"You must then provide some key implementation details:"
msgstr "Простейший способ построить модель совместимую с моделью User это"
"наследовать модель :class:`~django.contrib.auth.models.AbstractBaseUser`."
":class:`~django.contrib.auth.models.AbstractBaseUser` обеспечивает базовую"
"реализацию модели User, в том числе хэширование паролей и сброс пароля"
"посредством токенов."

#: ../../topics/auth/customizing.txt:499
# d7d73cec0c814f20b9ad744c7a0e189b
msgid ""
"A string describing the name of the field on the User model that is used as "
"the unique identifier. This will usually be a username of some kind, but it "
"can also be an email address, or any other unique identifier. The field "
"*must* be unique (i.e., have ``unique=True`` set in its definition)."
msgstr "Строка, указывающая имя поля модели User, которая испльзуется в"
"качестве уникального идентификатора. Это, как правило, имя пользователя"
"в нектором виде, но также можеть и адресом эелектронной почты, или"
"любой другой уникальный идентификатор. Поле должно быть уникальным"
"(т.е. unique=True)."

#: ../../topics/auth/customizing.txt:505
# fcc69f52a8d041c7a9503d06fb513502
msgid ""
"In the following example, the field ``identifier`` is used as the "
"identifying field::"
msgstr "В примере ниже поле ``identifier`` используется в качестве"
"уникального идентификатора:"

#: ../../topics/auth/customizing.txt:515
msgid ""
":attr:`USERNAME_FIELD` now supports :class:`~django.db.models.ForeignKey`"
"\\s. Since there is no way to pass model instances during the :djadmin:"
"`createsuperuser` prompt, expect the user to enter the value of :attr:"
"`~django.db.models.ForeignKey.to_field` value (the :attr:`~django.db.models."
"Field.primary_key` by default) of an existing instance."
msgstr "Атрибут :attr:`USERNAME_FIELD` теперь поддеоживает внешние ключи."
"В связи с этим возникает проблема. При выполнении команды из"
":djadmin:`createsuperuser` из командной строки вы неможете передать"
"объект связанного объекта, по этому вы можете просто указать просто"
"ID записи в БД (:attr:`~django.db.models.ForeignKey.to_field` указывает"
"на ID по умолчанию)."

#: ../../topics/auth/customizing.txt:524
msgid ""
"A list of the field names that will be prompted for when creating a user via "
"the :djadmin:`createsuperuser` management command. The user will be prompted "
"to supply a value for each of these fields. It must include any field for "
"which :attr:`~django.db.models.Field.blank` is ``False`` or undefined and "
"may include additional fields you want prompted for when a user is created "
"interactively. ``REQUIRED_FIELDS`` has no effect in other parts of Django, "
"like creating a user in the admin."
msgstr "Список имен полей, которые будут запрашиваться при создании пользователя"
"с использованием команды :djadmin:`createsuperuser`. Пользователю будет"
"предложено задать значение для каждого из этих полей. Этот список должен"
"содержать имена всех полей для которых атрибут blank уставновлен False и поля"
"для которых этот атрибут не определен, а так же любые другие поля какие вы захотите."
"Изменение параметра ``REQUIRED_FIELDS`` ни как не отразится на остальных частях"
"фреймворка Django, таких как создание пользователя через панель администратора."

#: ../../topics/auth/customizing.txt:533
# 0dc922a0f91545438b8f6170a72f5b1c
msgid ""
"For example, here is the partial definition for a ``User`` model that "
"defines two required fields - a date of birth and height::"
msgstr "Пример ниже показывает как можно задать два обязательных поля --"
"дата рождения и рост:"

#: ../../topics/auth/customizing.txt:545
# 84288d96abf548b096b0c85f6ecf6ffc
msgid ""
"``REQUIRED_FIELDS`` must contain all required fields on your ``User`` model, "
"but should *not* contain the ``USERNAME_FIELD`` or ``password`` as these "
"fields will always be prompted for."
msgstr "В атрибуте ``REQUIRED_FIELDS`` вы можете задать любые обязательные поля"
"вашей модели ``User`` кроме ``USERNAME_FIELD`` и ``password``. Эти поля"
"являются обязательными по умолчанию."

#: ../../topics/auth/customizing.txt:551
msgid ""
":attr:`REQUIRED_FIELDS` now supports :class:`~django.db.models.ForeignKey`"
"\\s. Since there is no way to pass model instances during the :djadmin:"
"`createsuperuser` prompt, expect the user to enter the value of :attr:"
"`~django.db.models.ForeignKey.to_field` value (the :attr:`~django.db.models."
"Field.primary_key` by default) of an existing instance."
msgstr "Атрибут ``REQUIRED_FIELDS`` теперь поддеоживает внешние ключи."
"В связи с этим возникает проблема. При выполнении команды из"
":djadmin:`createsuperuser` из командной строки вы неможете передать"
"объект связанного объекта, по этому вы можете просто указать просто"
"ID записи в БД (:attr:`~django.db.models.ForeignKey.to_field` указывает"
"на ID по умолчанию)."

#: ../../topics/auth/customizing.txt:560
# 89c8b06e27974c5eb46a86cde8661c98
msgid ""
"A boolean attribute that indicates whether the user is considered \"active"
"\".  This attribute is provided as an attribute on ``AbstractBaseUser`` "
"defaulting to ``True``. How you choose to implement it will depend on the "
"details of your chosen auth backends. See the documentation of the :attr:"
"`is_active attribute on the built-in user model <django.contrib.auth.models."
"User.is_active>` for details."
msgstr "Логические атрибут указывающий является ли пользователь \"активным\"."
"По умолчанию класс ``AbstractBaseUser`` устанавливает его в ``True``.  Вы"
"можете изменить это в вашем бекэнде аутентификации. Для подробностей"
"смотри документ :attr:`атрибут is_active во встроеное модели ``User``"
"<django.contrib.auth.models.User.is_active>`"

#: ../../topics/auth/customizing.txt:569
# e98f6146206c4e358f8360cf978d3fe8
msgid ""
"A longer formal identifier for the user. A common interpretation would be "
"the full name of the user, but it can be any string that identifies the user."
msgstr "\"Длинная\" форма формально идентификатора пользователя. В общем случае"
"должна возвращать полное имя пользователя, но может так же"
"возвращать любую строку однозначно идентифицирующая пользователя."

#: ../../topics/auth/customizing.txt:575
# 7ea944340e414547adb58536aaa890fb
msgid ""
"A short, informal identifier for the user. A common interpretation would be "
"the first name of the user, but it can be any string that identifies the "
"user in an informal way. It may also return the same value as :meth:`django."
"contrib.auth.models.User.get_full_name()`."
msgstr "\"Короткая\" форма, не формальная, идентификации пользователя. В общем"
"случае должна возращать имя пользователя. Но так же может возвращать"
"любую строку однозначно идентифицирующую пользователя. Может возвращать"
"такое же значение что и :meth:`django.contrib.auth.models.User.get_full_name()`."

#: ../../topics/auth/customizing.txt:580
# cd022a86211546c2927f81c447e72198
msgid ""
"The following methods are available on any subclass of :class:`~django."
"contrib.auth.models.AbstractBaseUser`:"
msgstr "Следующие методы доступны из любого класса наследующего"
":class:`~django.contrib.auth.models.AbstractBaseUser`:"

#: ../../topics/auth/customizing.txt:587
# 9f31b17dfce44100bba07471966f941b
msgid "Returns the value of the field nominated by ``USERNAME_FIELD``."
msgstr "Возвращает значение из поля указанного в качестве ``USERNAME_FIELD``."

#: ../../topics/auth/customizing.txt:591
# 707ca33fcf83468a87cdd66794ec1404
msgid ""
"Always returns ``False``. This is a way of differentiating from  :class:"
"`~django.contrib.auth.models.AnonymousUser` objects. Generally, you should "
"prefer using :meth:`~django.contrib.auth.models.AbstractBaseUser."
"is_authenticated()` to this method."
msgstr "Всегда возвращает ``False``. Это способ дифференцировать от объектов"
":class:`~django.contrib.auth.models.AnonymousUser`. Обычно предпочтительнее"
"использовать :meth:`~django.contrib.auth.models.AbstractBaseUser."
"is_authenticated()` метод."

#: ../../topics/auth/customizing.txt:599
# 9616f410cb424ba9b5845b5beb4e193a
msgid ""
"Always returns ``True``. This is a way to tell if the user has been "
"authenticated. This does not imply any permissions, and doesn't check if the "
"user is active - it only indicates that the user has provided a valid "
"username and password."
msgstr "Всегда возвращает ``True``. Это способ определить был ли пользователь"
"идентифицирован. Метод не подразумевает проверку прав доступа"
"или статус активности пользователя. Он только указывает что пользователь"
"ввел правильные имя пользователя и пароль."

#: ../../topics/auth/customizing.txt:606
# dd445814ddd346378a548adcfcdcb96a
msgid ""
"Sets the user's password to the given raw string, taking care of the "
"password hashing. Doesn't save the :class:`~django.contrib.auth.models."
"AbstractBaseUser` object."
msgstr "Меняет пароль пользователя на переданный в параметре педварительно"
"хэшировав его. Объект :class:`~django.contrib.auth.models.AbstractBaseUser` "
"не сохраняется."

#: ../../topics/auth/customizing.txt:610
# 9fdfe846f54d4fcbb6422a6763c7578d
msgid ""
"When the raw_password is ``None``, the password will be set to an unusable "
"password, as if :meth:`~django.contrib.auth.models.AbstractBaseUser."
"set_unusable_password()` were used."
msgstr "Если используется метод:meth:`~django.contrib.auth.models.AbstractBaseUser."
"set_unusable_password()` и ``raw_password`` равен ``None`` пользователь будет"
"помечен как не использующий пароль."

#: ../../topics/auth/customizing.txt:617
# f6a25c9b78cf4db88a150df4da042b32
msgid ""
"Returns ``True`` if the given raw string is the correct password for the "
"user. (This takes care of the password hashing in making the comparison.)"
msgstr "Возвращает ``True`` если пароль указан верно (вычисляет хэш и"
"сравнивает его с хэшем хранимым в базе данных)."

#: ../../topics/auth/customizing.txt:623
# be6465ec0b374a3fbe4fd9f6d599b89d
msgid ""
"Marks the user as having no password set.  This isn't the same as having a "
"blank string for a password. :meth:`~django.contrib.auth.models."
"AbstractBaseUser.check_password()` for this user will never return ``True``. "
"Doesn't save the :class:`~django.contrib.auth.models.AbstractBaseUser` "
"object."
msgstr "Помечает пользователя как не использующего пароля. Но это не тоже"
"самое что указывать пустую строку в качестве пароля. Если уставнолено то"
"метод :meth:`~django.contrib.auth.models.AbstractBaseUser.check_password()`"
"никогда не вернет ``True``. Объект :class:`~django.contrib.auth.models.AbstractBaseUser`"
"не сохраняется."

#: ../../topics/auth/customizing.txt:629
# bd690ab3f8ec4ceeba86225e382ad20c
msgid ""
"You may need this if authentication for your application takes place against "
"an existing external source such as an LDAP directory."
msgstr "Вам может это понадобиться если вы используете внешний источник"
"данных для аутентифифкации, например, директорю LDAP."

#: ../../topics/auth/customizing.txt:634
# 796785bbe49f456ca1d0ffb31d1f40f7
msgid ""
"Returns ``False`` if :meth:`~django.contrib.auth.models.AbstractBaseUser."
"set_unusable_password()` has been called for this user."
msgstr "Вернет ``False`` если для пользователя бул вызван метод"
":meth:`~django.contrib.auth.models.AbstractBaseUser.set_unusable_password()`."

#: ../../topics/auth/customizing.txt:642
# 0ad167949f0646b4be22f0be2c0fbdf6
msgid ""
"Returns an HMAC of the password field. Used for :ref:`session-invalidation-"
"on-password-change`."
msgstr "Вернет HMAC (хэш) пароля. Используется для :ref:`переопределения сессии"
"после смены пароля <session-invalidation-on-password-change>`."

#: ../../topics/auth/customizing.txt:645
# 60e492c932e643c78ec795bbdd160054
msgid ""
"You should also define a custom manager for your ``User`` model. If your "
"``User`` model defines ``username``, ``email``, ``is_staff``, ``is_active``, "
"``is_superuser``, ``last_login``, and ``date_joined`` fields the same as "
"Django's default ``User``, you can just install Django's :class:`~django."
"contrib.auth.models.UserManager`; however, if your ``User`` model defines "
"different fields, you will need to define a custom manager that extends :"
"class:`~django.contrib.auth.models.BaseUserManager` providing two additional "
"methods:"
msgstr "Вам так же необходимо определить собственный менеджер пользователей"
"вашей модели ``User``. Если ваше модель ``User`` определяет поля ``username``,"
"``email``, ``is_staff``, ``is_active``, ``is_superuser``, ``last_login`` и ``date_joined`` так же"
"и в стандартной модели ``User`` вы можете использовать стандартный :class:`~django."
"contrib.auth.models.UserManager` Django. Однако, если вы определили другие"
"поля в вашей модели вам необходим ваш собственный менеджер пользователй"
"который будет унаследован от :class:`~django.contrib.auth.models.BaseUserManager`"
"и определять два обязательных метода:"

#: ../../topics/auth/customizing.txt:658
# 6b112742fdb7412fb4240505fcf8c98d
msgid ""
"The prototype of ``create_user()`` should accept the username field, plus "
"all required fields as arguments. For example, if your user model uses "
"``email`` as the username field, and has ``date_of_birth`` as a required "
"field, then ``create_user`` should be defined as::"
msgstr "Метод ``create_user()`` должен принимать вкачестве параметров"
"имя пользователя плюс другие обязательные поля. Например,"
"если ваша модель пользователей использует ``email`` в качестве"
"логина с обязательным указанием даты рождения то ваш метод"
"``create_user`` должен быть определен как:"

#: ../../topics/auth/customizing.txt:669
# 56fa50d7fcb74245a524d32336c6c03a
msgid ""
"The prototype of ``create_superuser()`` should accept the username field, "
"plus all required fields as arguments. For example, if your user model uses "
"``email`` as the username field, and has ``date_of_birth`` as a required "
"field, then ``create_superuser`` should be defined as::"
msgstr "Метод ``create_superuser()`` должен принимать вкачестве параметров"
"имя пользователя плюс другие обязательные поля. Например,"
"если ваша модель пользователей использует ``email`` в качестве"
"логина с обязательным указанием даты рождения то ваш метод"
"``create_superuser()`` должен быть определен как:"

#: ../../topics/auth/customizing.txt:678
# 7a90ab1049e24007b6a5430a6d6739e0
msgid ""
"Unlike ``create_user()``, ``create_superuser()`` *must* require the caller "
"to provide a password."
msgstr "В отличие от ``create_user()``,  ``create_superuser()`` должен обязатльно"
"требовать пароль."

#: ../../topics/auth/customizing.txt:681
# 408d28a741634411a1ceb60fd9b43845
msgid ""
":class:`~django.contrib.auth.models.BaseUserManager` provides the following "
"utility methods:"
msgstr ":class:`~django.contrib.auth.models.BaseUserManager` предоставляет следующие методы:"

#: ../../topics/auth/customizing.txt:688
# 9ddb89ee8587417b912948701868a93f
msgid ""
"A ``classmethod`` that normalizes email addresses by lowercasing the domain "
"portion of the email address."
msgstr "Это ``classmethod`` который используется для нормализации электронного"
"адреса путем преобразования доменного имени в нижний регистр."

#: ../../topics/auth/customizing.txt:693
# 5ff291a1de9e44af82126869677a612e
msgid ""
"Retrieves a user instance using the contents of the field nominated by "
"``USERNAME_FIELD``."
msgstr "Получает экземпляр пользователя, использую содержимое поля,"
"указаного в ``USERNAME_FIELD``."

#: ../../topics/auth/customizing.txt:698
# 5cf3c7191d774f11b0153a9fef5991e9
msgid ""
"Returns a random password with the given length and given string of allowed "
"characters. Note that the default value of ``allowed_chars`` doesn't contain "
"letters that can cause user confusion, including:"
msgstr "Возвращает случайно сгенерированый пароль указанной длины и набора"
"символов. Обратите внимание, что стандартная строка ``allowed_chars``"
"не содержит символов которые могут ввести пользователя в заблуждение,"
"включая:"

#: ../../topics/auth/customizing.txt:702
# 3731bb5a184945bf9289e55c01fa376e
msgid ""
"``i``, ``l``, ``I``, and ``1`` (lowercase letter i, lowercase letter L, "
"uppercase letter i, and the number one)"
msgstr "``i``, ``l``, ``I``, и ``1`` (строчная буква i, строчная буква L,"
"прописная буква i и цифра один)"

#: ../../topics/auth/customizing.txt:704
# ac08d505c146401faf94c9c183fd0287
msgid ""
"``o``, ``O``, and ``0`` (lowercase letter o, uppercase letter o, and zero)"
msgstr "``o``, ``O``, и ``0`` (строчная бука о, прописаня буква о и ноль)"

#: ../../topics/auth/customizing.txt:708
# d0cc327fed794dd0a6a390da253fde7b
msgid "Extending Django's default User"
msgstr "Расширяем встроенную модель User"

#: ../../topics/auth/customizing.txt:710
# 63626680094846cdaf79034b8d341061
msgid ""
"If you're entirely happy with Django's :class:`~django.contrib.auth.models."
"User` model and you just want to add some additional profile information, "
"you could simply subclass ``django.contrib.auth.models.AbstractUser`` and "
"add your custom profile fields, although we'd recommend a separate model as "
"described in the \"Model design considerations\" note of :ref:`specifying-"
"custom-user-model`. ``AbstractUser`` provides the full implementation of the "
"default :class:`~django.contrib.auth.models.User` as an :ref:`abstract model "
"<abstract-base-classes>`."
msgstr "Если вас польностью удовлетворяет встроенная модель :class:`~django.contrib."
"auth.models.User` и нужно только добавить хранение дополнительной"
"ифнормации о пользователе, вы можете просто расширить модель"
"``django.contrib.auth.models.AbstractUser`` и добавить дополнительные поля,"
"хотя мы рекомендуем создать отдельную модель в соотвествии с заметкой"
"\"Разработка пользовательской модели\". ``AbstractUser`` полностью реализует"
"стандартную модель :class:`~django.contrib.auth.models.User`."

#: ../../topics/auth/customizing.txt:722
# 757515f54ea1438cb54dd39ba31948c5
msgid "Custom users and the built-in auth forms"
msgstr "Встроенные формы авторизации"

#: ../../topics/auth/customizing.txt:724
# c41928d682af4ab6a3db65002b84b3a3
msgid ""
"As you may expect, built-in Django's :ref:`forms <built-in-auth-forms>` and :"
"ref:`views <built-in-auth-views>` make certain assumptions about the user "
"model that they are working with."
msgstr "Встроенные в Django :ref:`формы <built-in-auth-forms>` и"
":ref:`представления <built-in-auth-views>` делают определенные предположения"
"о модели ``User`` с которой они работают."

#: ../../topics/auth/customizing.txt:728
# f827696ea1a341d6a4ee2f59bd1447b0
msgid ""
"If your user model doesn't follow the same assumptions, it may be necessary "
"to define a replacement form, and pass that form in as part of the "
"configuration of the auth views."
msgstr "Если ваше пользовательская модель не следует тем же прдположениям,"
"вам,возможно, придется определить новую форму и передать ее в виде"
"части конфигурации представления авторизации."

#: ../../topics/auth/customizing.txt:732
# 103f1905f71744f29f7345e2fd240188
msgid ":class:`~django.contrib.auth.forms.UserCreationForm`"
msgstr ":class:`~django.contrib.auth.forms.UserCreationForm`"

#: ../../topics/auth/customizing.txt:734
#: ../../topics/auth/customizing.txt:739
# 88d432581ca04609966ceeb666b32441
# 35dc6886a26b4badb9eba33e4dc7f59b
msgid ""
"Depends on the :class:`~django.contrib.auth.models.User` model. Must be re-"
"written for any custom user model."
msgstr "Зависит от :class:`~django.contrib.auth.models.User` модели. Должен"
"быть переписан для любой новой пользовательской модели."

#: ../../topics/auth/customizing.txt:737
# 833c2b1ec40b47a3b97c64425dd2d42b
msgid ":class:`~django.contrib.auth.forms.UserChangeForm`"
msgstr ":class:`~django.contrib.auth.forms.UserChangeForm`"

#: ../../topics/auth/customizing.txt:742
# d9edd7a5ac154a3ab6c40aa5a5a7a726
msgid ":class:`~django.contrib.auth.forms.AuthenticationForm`"
msgstr ":class:`~django.contrib.auth.forms.AuthenticationForm`"

#: ../../topics/auth/customizing.txt:744
# 4631bdc4e57e4ec5acb6392d0bee0f29
msgid ""
"Works with any subclass of :class:`~django.contrib.auth.models."
"AbstractBaseUser`, and will adapt to use the field defined in "
"``USERNAME_FIELD``."
msgstr "Работает с любым классом унаследованным от :class:`~django.contrib.auth.models."
"AbstractBaseUser` и должна быть адоптирована для использования "
"поля определенного в ``USERNAME_FIELD``."

#: ../../topics/auth/customizing.txt:747
# 110741093cd7475fbb7235cc53d9a13a
msgid ":class:`~django.contrib.auth.forms.PasswordResetForm`"
msgstr ":class:`~django.contrib.auth.forms.PasswordResetForm`"

#: ../../topics/auth/customizing.txt:749
msgid ""
"Assumes that the user model has a field named ``email`` that can be used to "
"identify the user and a boolean field named ``is_active`` to prevent "
"password resets for inactive users."
msgstr "Предполагается что модель пользователя имеет поле с именем ``email``,"
"которое может быть использовано для идентификации пользователя"
"и поле ``is_active`` хранящее булево значение для предотвращения сброса"
"пароля для неактивных пользователей."

#: ../../topics/auth/customizing.txt:753
# 548825e5354c45c9a590c1bfd947b600
msgid ":class:`~django.contrib.auth.forms.SetPasswordForm`"
msgstr ":class:`~django.contrib.auth.forms.SetPasswordForm`"

#: ../../topics/auth/customizing.txt:755
#: ../../topics/auth/customizing.txt:759
#: ../../topics/auth/customizing.txt:763
# 3eaab38c13df46e9a15e2816d1926e02
# 11e2349b004c42eb8c125991e3721df2
# 0854b13b0fbd41dfaf88ca178abe38e7
msgid ""
"Works with any subclass of :class:`~django.contrib.auth.models."
"AbstractBaseUser`"
msgstr "Работает с любым классом унаследованным от :class:`~django.contrib.auth.models."
"AbstractBaseUser`"

#: ../../topics/auth/customizing.txt:757
# af86245c1215499bb0aa69bc04a63a5e
msgid ":class:`~django.contrib.auth.forms.PasswordChangeForm`"
msgstr ":class:`~django.contrib.auth.forms.PasswordChangeForm`"

#: ../../topics/auth/customizing.txt:761
# c6405c8424404a44a2e37c0862d25d2c
msgid ":class:`~django.contrib.auth.forms.AdminPasswordChangeForm`"
msgstr ":class:`~django.contrib.auth.forms.AdminPasswordChangeForm`"

#: ../../topics/auth/customizing.txt:767
# 6a219b59f463415aa5709386d82009c0
msgid "Custom users and :mod:`django.contrib.admin`"
msgstr "Пользовательская модель и :mod:`django.contrib.admin`"

#: ../../topics/auth/customizing.txt:769
# 7749b18a757a4e5faeae1f61337f7706
msgid ""
"If you want your custom User model to also work with Admin, your User model "
"must define some additional attributes and methods. These methods allow the "
"admin to control access of the User to admin content:"
msgstr "Если вы хотите что бы ваша пользовательская модель так же работала с"
"административным интерфейсом она должна определять некторые"
"обязательные атрибуты и методы. Эти методы позволяют админ модулю"
"контролировать доступ пользователй к админской части приложения:"

#: ../../topics/auth/customizing.txt:777
# c3fdd99220ad4f2ebed867f916bef1dc
msgid ""
"Returns ``True`` if the user is allowed to have access to the admin site."
msgstr "Возвращает ``True`` если пользователю разрешен доступ к админ сайту."

#: ../../topics/auth/customizing.txt:781
# e75428947c9f4eb7858ad9b7372e900f
msgid "Returns ``True`` if the user account is currently active."
msgstr "Возвращает ``True`` если пользователь активен."

#: ../../topics/auth/customizing.txt:785
# 3c8cb81e149447a1a8c85c488db77e2d
msgid ""
"Returns ``True`` if the user has the named permission. If ``obj`` is "
"provided, the permission needs to be checked against a specific object "
"instance."
msgstr "Возвращает ``True`` если пользователь имеет указанное разрашение."
"Если ``obj`` поддерживается, разрешение должно быть проверено в отношени"
"конктретного экземпляра объекта."

#: ../../topics/auth/customizing.txt:791
# fb63950e7c274194aef7b0b41cc5fbdf
msgid ""
"Returns ``True`` if the user has permission to access models in the given "
"app."
msgstr "Возвращает ``True`` если пользователь имеет доступ к модели указанного приложения."

#: ../../topics/auth/customizing.txt:794
# 39641d068824477c955a59766fae7d48
msgid ""
"You will also need to register your custom User model with the admin. If "
"your custom User model extends ``django.contrib.auth.models.AbstractUser``, "
"you can use Django's existing ``django.contrib.auth.admin.UserAdmin`` class. "
"However, if your User model extends :class:`~django.contrib.auth.models."
"AbstractBaseUser`, you'll need to define a custom ``ModelAdmin`` class. It "
"may be possible to subclass the default ``django.contrib.auth.admin."
"UserAdmin``; however, you'll need to override any of the definitions that "
"refer to fields on ``django.contrib.auth.models.AbstractUser`` that aren't "
"on your custom User class."
msgstr "Вам так же надо зарегстрировать вашу пользовательскую модель для"
"админ модуля. Если ваша модель наследует ``django.contrib.auth.models.AbstractUser``"
"модель вы можете использовать ``django.contrib.auth.admin.UserAdmin`` класс Django."
"Однако, если вы наследуеете :class:`~django.contrib.auth.models.AbstractBaseUser` класс"
"вам необходимо определить пользовательский класс ``ModelAdmin``.  Для этого вы"
"можете наследовать стандартный класс ``django.contrib.auth.admin.UserAdmin`` и"
"переопределить все ссылки на поля в ``django.contrib.auth.models.AbstractUser`` в"
"соответсвии со структурой вашей модели."

#: ../../topics/auth/customizing.txt:806
# 380333cb6d5546ffbf5af3acf33a8dd0
msgid "Custom users and permissions"
msgstr "Пользовательские права доступа"

#: ../../topics/auth/customizing.txt:808
# 7f14c8514f5243d0a6597d7275f55aea
msgid ""
"To make it easy to include Django's permission framework into your own User "
"class, Django provides :class:`~django.contrib.auth.models."
"PermissionsMixin`. This is an abstract model you can include in the class "
"hierarchy for your User model, giving you all the methods and database "
"fields necessary to support Django's permission model."
msgstr "Что бы упростить подключения системы прав доступа фреймворка в ваш"
"пользовательский класс Django имеет класс :class:`~django.contrib.auth.models."
"PermissionsMixin`. Это абстрактная модель которую вы можете включить в иерархию"
"классов вашей пользовательской модели, предоставляющий вам доступ ко всем"
"методам и полям базы данных необходиых для работы модуля прав доступа."

#: ../../topics/auth/customizing.txt:814
# c145e8df4a804d43ab6553e0bd875b0a
msgid ""
":class:`~django.contrib.auth.models.PermissionsMixin` provides the following "
"methods and attributes:"
msgstr ":class:`~django.contrib.auth.models.PermissionsMixin`  предоставляют следуюющие"
"методы и атрибуты:"

#: ../../topics/auth/customizing.txt:821
# 378dc57e66ec48f19ded31f54975ec90
msgid ""
"Boolean. Designates that this user has all permissions without explicitly "
"assigning them."
msgstr "Булев тип. Указывает что пользователь имеет все права без их явного"
"назначения."

#: ../../topics/auth/customizing.txt:826
# 7a11ff8ca06f48938dadba472a7f5bed
msgid ""
"Returns a set of permission strings that the user has, through their groups."
msgstr "Возвращает набор прав доступа групп в которых состоит пользователь."

#: ../../topics/auth/customizing.txt:829
# f00a4e69fefa44a58f42fa1ed91fcd8d
msgid ""
"If ``obj`` is passed in, only returns the group permissions for this "
"specific object."
msgstr "Если передается ``obj`` возвращает групповые права доступа только"
"для указанного объекта."

#: ../../topics/auth/customizing.txt:834
# ef838cf5459643728e57f0f1c8ec6c4b
msgid ""
"Returns a set of permission strings that the user has, both through group "
"and user permissions."
msgstr "Возвращает набор как групповых так и индивидуальных прав доступа."

#: ../../topics/auth/customizing.txt:837
# 8068857ffaa843718c4ee863663caf81
msgid ""
"If ``obj`` is passed in, only returns the permissions for this specific "
"object."
msgstr "Если передается ``obj`` возвращает персональные права доступа только"
"для указанного объекта."

#: ../../topics/auth/customizing.txt:842
# 8162b07c6fc5475e916cd9f6a5b88c10
msgid ""
"Returns ``True`` if the user has the specified permission, where ``perm`` is "
"in the format ``\"<app label>.<permission codename>\"`` (see :ref:"
"`permissions <topic-authorization>`). If the user is inactive, this method "
"will always return ``False``."
msgstr "Возвращает ``True`` если пользователь имеет указанные права доступа."
"``perm`` указываются в формате ``\"<app label>.<permission codename>\"`` (для"
"подробностей смотри документ -- :ref:`права доступа <topic-authorization>`)."
"Если пользователь не активен будет всегда возвращать ``False``."

#: ../../topics/auth/customizing.txt:847
# 06c823c09d514abebf5dcd82cd4e8b66
msgid ""
"If ``obj`` is passed in, this method won't check for a permission for the "
"model, but for this specific object."
msgstr "Если передан ``obj``, этот метод проверит права доступа только"
"для указанного объекта."

#: ../../topics/auth/customizing.txt:852
# 284d1d5141c144858676db417b75d91a
msgid ""
"Returns ``True`` if the user has each of the specified permissions, where "
"each perm is in the format ``\"<app label>.<permission codename>\"``. If the "
"user is inactive, this method will always return ``False``."
msgstr "Возвращает ``True`` если пользователь имеет все перечисленные пара доступа"
"переданные в формате ``\"<app label>.<permission codename>\"``. "
"Если пользователь не активен метод вернет ``False``."

#: ../../topics/auth/customizing.txt:857
# 7148e7e6f0354829aa8078ffea398a76
msgid ""
"If ``obj`` is passed in, this method won't check for permissions for the "
"model, but for the specific object."
msgstr "Если передан ``obj``, этот метод проверит права доступа только"
"для указанного объекта."

#: ../../topics/auth/customizing.txt:862
# 7b275d4d9dee4f61b629ea93fc8546a2
msgid ""
"Returns ``True`` if the user has any permissions in the given package (the "
"Django app label). If the user is inactive, this method will always return "
"``False``."
msgstr "Вернет ``True`` если пользователь имеет какие либо права доступа для"
"указанного пакета (приложения Django). Вернет ``False`` если"
"пользователь не активен."

#: ../../topics/auth/customizing.txt:866
# aca86586415e451e80a2590f23380145
msgid "ModelBackend"
msgstr "ModelBackend"

#: ../../topics/auth/customizing.txt:868
# 3e7b6f224737443287a254d7f55379e4
msgid ""
"If you don't include the :class:`~django.contrib.auth.models."
"PermissionsMixin`, you must ensure you don't invoke the permissions methods "
"on ``ModelBackend``. ``ModelBackend`` assumes that certain fields are "
"available on your user model. If your User model doesn't provide  those "
"fields, you will receive database errors when you check permissions."
msgstr "Если вы не включаете класс :class:`~django.contrib.auth.models."
"PermissionsMixin` вы должны убедиться, что не ссылаетесь на методы"
"проверки прав доступа определенные в ``ModelBackend``. ``ModelBackend``"
"предполагает что определнные поля доступны в вашей модели пользователя."
"И если ваша модель пользователей не имеет этих полей вы будете получать"
"ошибки базы данных когда попытаетесь проверить права доступа."

#: ../../topics/auth/customizing.txt:876
# 3832bfa0c9ff4fc992b2693fb925e691
msgid "Custom users and Proxy models"
msgstr "Пользовательская модель ``User`` и Proxy модели"

#: ../../topics/auth/customizing.txt:878
# c5cbe64a379a46f4b19508c9ade5f540
msgid ""
"One limitation of custom User models is that installing a custom User model "
"will break any proxy model extending :class:`~django.contrib.auth.models."
"User`. Proxy models must be based on a concrete base class; by defining a "
"custom User model, you remove the ability of Django to reliably identify the "
"base class."
msgstr "Одним из ограничений пользовательской модели :class:`~django.contrib.auth.models."
"User` является то, что она сломает любые Proxy модели расширяющиее"
"стандартную модель. Proxy модели должны основываться на конкретом"
"базовом классе. Определяя пользовательскую модель ``User`` вы лишаеете"
"Django возможности конкрентно определить базовый класс."

#: ../../topics/auth/customizing.txt:883
# 0813f779256d4cfd80934a69de9b77f4
msgid ""
"If your project uses proxy models, you must either modify the proxy to "
"extend the User model that is currently in use in your project, or merge "
"your proxy's behavior into your User subclass."
msgstr "Если в своем проекте вы используете Proxy модели вы должны либо"
"модифицировать ее что бы она расширяла модель ``User``, которая"
"используется в ваше проекте, либо определить функции выполняемые"
"Proxy моделями непосредственно вашей пользовательской модели."

#: ../../topics/auth/customizing.txt:888
# b86cde4d432e4c32aeecb531696831de
msgid "Custom users and signals"
msgstr "Пользовательская модель ``User`` и сигналы"

#: ../../topics/auth/customizing.txt:890
# 31e973d7e66c4962b201c19d1f5c8f99
msgid ""
"Another limitation of custom User models is that you can't use :func:`django."
"contrib.auth.get_user_model()` as the sender or target of a signal handler. "
"Instead, you must register the handler with the resulting User model. See :"
"doc:`/topics/signals` for more information on registering and sending "
"signals."
msgstr "Другое ограничение пользовательской модели ``User`` является то, что"
"вы не можете использовать метод :func:`django.contrib.auth.get_user_model()`"
"в качестве отправителя или приемника обработчика сигналов. Вместо этого"
"вы должны регистрировать обработчик в вашей модели ``User``. Смотри"
":doc:`/topics/signals` для подробной информации."

#: ../../topics/auth/customizing.txt:897
# de0a3d172dda41d28c34e949b8b20cbd
msgid "Custom users and testing/fixtures"
msgstr "Пользовательская модель ``User`` и тестирование."

#: ../../topics/auth/customizing.txt:899
# 4868b3f0f37c4b13a62efe6697c16146
msgid ""
"If you are writing an application that interacts with the User model, you "
"must take some precautions to ensure that your test suite will run "
"regardless of the User model that is being used by a project. Any test that "
"instantiates an instance of User will fail if the User model has been "
"swapped out. This includes any attempt to create an instance of User with a "
"fixture."
msgstr "Если вы пишите приложение, которое взаимодествуеют с пользовательской"
"моделью, вы должны принять некоторые меры предосторожности, чтобы"
"убедиться, что ваш набор тестов работать независимо от использующейся"
"в вашем проекте модели пользователей. А также если вы создаете экземпляр"
"класса ``User`` используя файлы предварительной настройки."

#: ../../topics/auth/customizing.txt:905
# 607bdff86afa49c3910b89bafe4f1af3
msgid ""
"To ensure that your test suite will pass in any project configuration, "
"``django.contrib.auth.tests.utils`` defines a ``@skipIfCustomUser`` "
"decorator. This decorator will cause a test case to be skipped if any User "
"model other than the default Django user is in use. This decorator can be "
"applied to a single test, or to an entire test class."
msgstr "Что бы убедиться что ваш набор тестов будет успешно выполняться"
"в любой конфигурации ``django.contrib.auth.tests.utils`` определяет"
"декоратор ``@skipIfCustomUser``.  Этот декоратор позволяет пропустить"
"тест если используется модель позователей отличная от стандартной модели."
"Может применяться как для одного теста так и для всего тестового класса."

#: ../../topics/auth/customizing.txt:911
# 7acc4cc313884719afe3b83ddf214637
msgid ""
"Depending on your application, tests may also be needed to be added to "
"ensure that the application works with *any* user model, not just the "
"default User model. To assist with this, Django provides two substitute user "
"models that can be used in test suites:"
msgstr "В зависимости отвашего приложения, вам также может понадобиться"
"добавить тесты для проверки того, что ваше приложение работает с любой"
"моделью пользователей, а не только со стандартной моделью. Что бы"
"помочь с этим Django предоставляет два заменителя пользовательской"
"модели которые могут быть использованы в вашем наборе тестов:"

#: ../../topics/auth/customizing.txt:918
# 26b556c6a5814a98b3c59c93687fb0d5
msgid ""
"A custom user model that uses an ``email`` field as the username, and has a "
"basic admin-compliant permissions setup"
msgstr "Модель использующая поле ``email`` в качестве имени пользователя и"
"имеющее базовые настройки доступа к административной части."

#: ../../topics/auth/customizing.txt:923
# 79f493573cab458c91adf8afcc471c04
msgid ""
"A custom user model that extends ``django.contrib.auth.models."
"AbstractUser``, adding a ``date_of_birth`` field."
msgstr "Модель расширяющая ``django.contrib.auth.models."
"AbstractUser`` добавляя поле ``date_of_birth``."

#: ../../topics/auth/customizing.txt:926
# 46bc383a053d4a708534981f7e527794
msgid ""
"You can then use the ``@override_settings`` decorator to make that test run "
"with the custom User model. For example, here is a skeleton for a test that "
"would test three possible User models -- the default, plus the two User "
"models provided by ``auth`` app::"
msgstr "Вы можете использовать декоратор ``@override_settings`` что бы"
"запсутить ваши тесты с новой пользовательской моделью. "
"Вот каркас для теста, который будет тестировать три возможные"
"модели пользователей -- стандартную, плюс две модели представленные"
"в приложении ``auth``::"

#: ../../topics/auth/customizing.txt:953
# 9501300e6b5f4c02a0ec091bce5a3a61
msgid "A full example"
msgstr "Полный пример"

#: ../../topics/auth/customizing.txt:955
# 9809cb52cfef41fca1d0f6d39aa216cd
msgid ""
"Here is an example of an admin-compliant custom user app. This user model "
"uses an email address as the username, and has a required date of birth; it "
"provides no permission checking, beyond a simple ``admin`` flag on the user "
"account. This model would be compatible with all the built-in auth forms and "
"views, except for the User creation forms. This example illustrates how most "
"of the components work together, but is not intended to be copied directly "
"into projects for production use."
msgstr "Здесь вы можете посмотреть пример админ-совместимого приложения"
"управления пользователями. Пользовательская модельиспользует, в качестве"
"имени пользователя, поле ``admin`` и обязательное поле даты рождения. Также"
"она не предоставлет никаких пользовательских прав, за исключением простого флага"
"``admin``. Эта модель будет совместима со всеми встроенными формами и представлениями,"
"за исключением формы создания пользователя. Этот пример показывает, как можно"
"использовать много компонентов вместе не копируя их исходный код в ваше приложение."

#: ../../topics/auth/customizing.txt:963
# ce445ce2bbd0488a9b96396155807855
msgid ""
"This code would all live in a ``models.py`` file for a custom authentication "
"app::"
msgstr "Этот код будет полностью находится в файле ``models.py`` вашего"
"прилодения аутентификации::"

#: ../../topics/auth/customizing.txt:1046
# b0845fadf5fe4846b695275672fe2287
msgid ""
"Then, to register this custom User model with Django's admin, the following "
"code would be required in the app's ``admin.py`` file::"
msgstr "Затем, что бы зарегистрировать вашу пользовательскую модель для"
"панели администратора Django, нужно добавить следующий в файл"
"``admin.py`` вашего приложения::"

#: ../../topics/auth/customizing.txt:1136
# bc7f337c88634ec8ba7e25c8fb3e48c4
msgid ""
"Finally, specify the custom model as the default user model for your project "
"using the :setting:`AUTH_USER_MODEL` setting in your ``settings.py``::"
msgstr ""
"И, на конец, указать вашу пользотельскую модель в качестве модели"
"по умолчанию в файле ``settings.py`` (:setting:`AUTH_USER_MODEL`)::"

