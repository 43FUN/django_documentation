# Russian translations for Django package.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
# Automatically generated <>, 2012.
#
msgid ""
msgstr ""
"Project-Id-Version: Django 1.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2012-02-29 18:30\n"
"PO-Revision-Date: 2012-03-03 16:33+0200\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"

# bdb93eaefd364936a9887a44682519a0
#: ../../topics/db/queries.txt:3
msgid "Making queries"
msgstr "Выполнение запросов"

# 39d54aa7cfa3495bb44614d6afc19532
#: ../../topics/db/queries.txt:7
msgid ""
"Once you've created your :doc:`data models </topics/db/models>`, Django "
"automatically gives you a database-abstraction API that lets you create, "
"retrieve, update and delete objects. This document explains how to use this "
"API. Refer to the :doc:`data model reference </ref/models/index>` for full "
"details of all the various model lookup options."
msgstr ""
"После создания :doc:`модели </topics/db/models>`, Django автоматически "
"создает API для работы с базой данных, который позволяет вам создавать, "
"получать, изменять и удалять объекты. Этот раздел расскажет вам как "
"использовать этот API. В :doc:`описании моделей </ref/models/index>` вы "
"можете найти список всех существующих опций поиска."

# ed797a0cb12b48b482c43a7c27b78e50
#: ../../topics/db/queries.txt:13
msgid ""
"Throughout this guide (and in the reference), we'll refer to the following "
"models, which comprise a Weblog application:"
msgstr "В этом разделе(и последующих) мы будем использовать такие модели:"

# 214abe3695e0474eb33a993452e202f5
#: ../../topics/db/queries.txt:49
msgid "Creating objects"
msgstr "Создание объектов"

# 91a82e93d8db4c6aa8cf8cf3fe7b8df2
#: ../../topics/db/queries.txt:51
msgid ""
"To represent database-table data in Python objects, Django uses an intuitive "
"system: A model class represents a database table, and an instance of that "
"class represents a particular record in the database table."
msgstr ""
"Для представления данных таблицы в виде объектов Python, Django использует "
"интуитивно понятную систему: класс модели представляет таблицу, а экземпляр "
"модели - запись в этой таблице."

# 44d1d5cef05f4f5fa4cd4e5bc0d78293
#: ../../topics/db/queries.txt:55
msgid ""
"To create an object, instantiate it using keyword arguments to the model "
"class, then call ``save()`` to save it to the database."
msgstr ""
"Что бы создать объект, создайте экземпляр класса модели, указав необходимые "
"поля в аргументах и вызовите метод ``save()`` что бы сохранить его в базе "
"данной."

# a1daedded2014169aa4c423b77f1dda1
#: ../../topics/db/queries.txt:58
msgid ""
"You import the model class from wherever it lives on the Python path, as you "
"may expect. (We point this out here because previous Django versions "
"required funky model importing.)"
msgstr ""
"Вы можете импортировать класс модели как и любой другой класс в Python. (Мы "
"упомянули это потому что в ранних версиях Django импорт моделей выглядел "
"немного необычно.)"

# 4f8109ce20844472abc9f5f235f4d8f2
#: ../../topics/db/queries.txt:62
msgid ""
"Assuming models live in a file ``mysite/blog/models.py``, here's an example::"
msgstr "Предположим, что модель находится в ``mysite/blog/models.py``::"

# fa058105d9a24a56bc787f806d5ba406
#: ../../topics/db/queries.txt:68
msgid ""
"This performs an ``INSERT`` SQL statement behind the scenes. Django doesn't "
"hit the database until you explicitly call ``save()``."
msgstr ""
"В результате выполнения этого кода будет создан ``INSERT`` SQL запрос. "
"Django не выполняет запросов к базе данных, пока не будет вызван метод ``save"
"()``."

# f0b45d018f5548f0b9eb9e653a33483c
#: ../../topics/db/queries.txt:71
msgid "The ``save()`` method has no return value."
msgstr "Метод ``save()``ничего не возвращает."

# edd3c4ad955c43659bdba26f82170e58
#: ../../topics/db/queries.txt:75
msgid ""
"``save()`` takes a number of advanced options not described here. See the "
"documentation for ``save()`` for complete details."
msgstr ""
"``save()`` принимает ряд аргументов не описанных в этом разделе. Смотрите "
"документацию о методе ``save()`` для подробностей."

# 8315103794ad4013bf4f1dcc5bb27b46
#: ../../topics/db/queries.txt:78
msgid ""
"To create an object and save it all in one step see the ``create()`` method."
msgstr "Что бы создать и сохранить объект используйте метод ``create()``."

# fcac470e103146d7b0591630f381417a
#: ../../topics/db/queries.txt:82
msgid "Saving changes to objects"
msgstr "Сохранение изменений в объектах"

# 32cd7e30dc36437cb37b0ae2ce886732
#: ../../topics/db/queries.txt:84
msgid ""
"To save changes to an object that's already in the database, use ``save()``."
msgstr ""
"Для сохранения изменений в объект, который уже существует в базе данных, "
"используйте ``save()``."

# a8cdaaed9aec406994b8610219ad1c5c
#: ../../topics/db/queries.txt:86
msgid ""
"Given a ``Blog`` instance ``b5`` that has already been saved to the "
"database, this example changes its name and updates its record in the "
"database::"
msgstr ""
"В данном примере изменяется название объекта ``b5`` модели ``Blog``и "
"обновляется запись в базе данных::"

# 545bb75ea29e46a198344d220e0f0f44
#: ../../topics/db/queries.txt:92
msgid ""
"This performs an ``UPDATE`` SQL statement behind the scenes. Django doesn't "
"hit the database until you explicitly call ``save()``."
msgstr ""
"В результате выполнения этого кода будет создан ``UPDATE`` SQL запрос. "
"Django не выполняет каких либо запросов к базе данных, пока не будет вызван "
"метод ``save()``."

# 61fc6798d83341919647dd8eec754e24
#: ../../topics/db/queries.txt:96
msgid "Saving ``ForeignKey`` and ``ManyToManyField`` fields"
msgstr "Сохранение полей ``ForeignKey`` и ``ManyToManyField``"

# 7b6667eb03eb44869680a74b24fa6ddb
#: ../../topics/db/queries.txt:98
msgid ""
"Updating a ``ForeignKey`` field works exactly the same way as saving a "
"normal field; simply assign an object of the right type to the field in "
"question. This example updates the ``blog`` attribute of an ``Entry`` "
"instance ``entry``::"
msgstr ""
"Обновление ``ForeignKey`` работает так же как и сохранение обычных полей; "
"просто назначьте полю объект необходимого типа. Этот пример обновляется "
"атрибут ``blog`` модели ``Entry`` объектом ``entry``::"

# b3a73e0272ef462daad7421096970447
#: ../../topics/db/queries.txt:108
msgid ""
"Updating a ``ManyToManyField`` works a little differently; use the ``add()`` "
"method on the field to add a record to the relation. This example adds the "
"``Author`` instance ``joe`` to the ``entry`` object::"
msgstr ""
"Обновление ``ManyToManyField`` работает немного по другому; используйте "
"метод ``add()`` поля, что бы добавить связанный объект. В этом примере "
"объект ``joe`` модели  ``Author`` добавляется к объекту ``entry``::"

# 5b1f65fabce6419a83f2f5388991515a
#: ../../topics/db/queries.txt:116
msgid ""
"To add multiple records to a ``ManyToManyField`` in one go, include multiple "
"arguments in the call to ``add()``, like this::"
msgstr ""
"Для добавления сразу нескольких объектов в ``ManyToManyField``, добавьте "
"несколько аргументов в метод ``add()``. Например::"

# 39ba66c21d0942e7a6f993bed62e81cc
#: ../../topics/db/queries.txt:125
msgid ""
"Django will complain if you try to assign or add an object of the wrong type."
msgstr ""
"Django вызовет исключение, если вы попытаетесь добавить объект неверного "
"типа."

# 8c7bd471ea974988b5d7c3e1445da818
#: ../../topics/db/queries.txt:128
msgid "Retrieving objects"
msgstr "Получение объектов"

# 0a5adb968aa7466faa0b09f698a14bab
#: ../../topics/db/queries.txt:130
msgid ""
"To retrieve objects from your database, you construct a ``QuerySet`` via a "
"``Manager`` on your model class."
msgstr ""
"Для получения объектов из базы данных, создается ``QuerySet`` через "
"``Manager`` модели."

# 4344cb14e331406aa163cdb656f09892
#: ../../topics/db/queries.txt:133
msgid ""
"A ``QuerySet`` represents a collection of objects from your database. It can "
"have zero, one or many *filters* -- criteria that narrow down the collection "
"based on given parameters. In SQL terms, a ``QuerySet`` equates to a "
"``SELECT`` statement, and a filter is a limiting clause such as ``WHERE`` or "
"``LIMIT``."
msgstr ""
"``QuerySet`` представляет выборку объектов из базы данных. Он может не "
"содержать, или содержать один или несколько *фильтров* -- критерии для "
"ограничения выборки по определенным параметрам. В терминах SQL,  "
"``QuerySet`` - это оператор ``SELECT``, а фильтры - условия такие, как "
"``WHERE`` или ``LIMIT``."

# c6eadadf12584b72998b2d4e75f5a288
#: ../../topics/db/queries.txt:138
msgid ""
"You get a ``QuerySet`` by using your model's ``Manager``. Each model has at "
"least one ``Manager``, and it's called ``objects`` by default. Access it "
"directly via the model class, like so::"
msgstr ""
"Вы получаете ``QuerySet`` используя ``Manager``. Каждая модель содержит как "
"минимум один ``Manager``, и он называется ``objects`` по-умолчанию. "
"Обратиться к нему можно непосредственно через класс модели::"

# 6b8bb227ae234bf18ea7723899f1ed8b
#: ../../topics/db/queries.txt:152
msgid ""
"``Managers`` are accessible only via model classes, rather than from model "
"instances, to enforce a separation between \"table-level\" operations and "
"\"record-level\" operations."
msgstr ""
"Обратиться к менеджерам можно только через модель и нельзя через ее "
"экземпляр. Это сделано для разделения \"table-level\" операций и \"record-"
"level\" операций."

# 53c4bfaf079340ffb99e11e4f208c6c4
#: ../../topics/db/queries.txt:156
msgid ""
"The ``Manager`` is the main source of ``QuerySets`` for a model. It acts as "
"a \"root\" ``QuerySet`` that describes all objects in the model's database "
"table. For example, ``Blog.objects`` is the initial ``QuerySet`` that "
"contains all ``Blog`` objects in the database."
msgstr ""
"``Manager`` - главный источник ``QuerySets`` для модели. Он является \"корнем"
"\" ``QuerySet``, который описывает все записи таблицы в базе данных. "
"Например, ``Blog.objects`` - первоначальный ``QuerySet``, который содержит "
"все объекты ``Blog`` из базы данных."

# 5144a2871c694667bff5ecb88f2d1e18
#: ../../topics/db/queries.txt:162
msgid "Retrieving all objects"
msgstr "Получение всех объектов"

# 2c6b2f4e92f14bbf9671e2438fe600a9
#: ../../topics/db/queries.txt:164
msgid ""
"The simplest way to retrieve objects from a table is to get all of them. To "
"do this, use the ``all()`` method on a ``Manager``::"
msgstr ""
"Самый простой способ получить объекты из таблицы - это получить их всех. Для "
"этого используйте метод ``all()`` менеджера::"

# 2e512666102e4fc0afdb13823fc8a4ce
#: ../../topics/db/queries.txt:169
msgid ""
"The ``all()`` method returns a ``QuerySet`` of all the objects in the "
"database."
msgstr "Метод ``all()`` возвращает ``QuerySet`` всех объектом в базе данных."

# e59bc3eb9f0c4e9693c40a0922595257
#: ../../topics/db/queries.txt:171
msgid ""
"(If ``Entry.objects`` is a ``QuerySet``, why can't we just do ``Entry."
"objects``? That's because ``Entry.objects``, the root ``QuerySet``, is a "
"special case that cannot be evaluated. The ``all()`` method returns a "
"``QuerySet`` that *can* be evaluated.)"
msgstr ""
"(Если ``Entry.objects`` - это ``QuerySet``, почему мы не можем просто "
"использовать ``Entry.objects``? Потому что ``Entry.objects`` фабрика "
"объектов ``QuerySet``. Для получения ``QuerySet`` необходимо использовать "
"метод ``all()``.)"

# 538083ba75be487a8e4f45ae3ffcdc97
#: ../../topics/db/queries.txt:178
msgid "Retrieving specific objects with filters"
msgstr "Получение объектов через фильтры"

# 3ec487a3588e488c9743989ef3f77657
#: ../../topics/db/queries.txt:180
msgid ""
"The root ``QuerySet`` provided by the ``Manager`` describes all objects in "
"the database table. Usually, though, you'll need to select only a subset of "
"the complete set of objects."
msgstr ""
"Корень ``QuerySet``, предоставленный ``Manager``, описывает все объекты в "
"таблице базы данных. Обычно вам нужно выбрать только подмножество всех "
"объектов."

# 182f1928158949fdb2bd2a87d2976d2d
#: ../../topics/db/queries.txt:184
msgid ""
"To create such a subset, you refine the initial ``QuerySet``, adding filter "
"conditions. The two most common ways to refine a ``QuerySet`` are:"
msgstr ""
"Для создания такого подмножества, вы можете изменить ``QuerySet``добавив "
"условия фильтрации. Два самых простых метода изменить ``QuerySet`` - это:"

# 23611b20266b40e1af50abf1f167d2c7
#: ../../topics/db/queries.txt:188
msgid ""
"Returns a new ``QuerySet`` containing objects that match the given lookup "
"parameters."
msgstr ""
"Возвращает новый ``QuerySet``, который содержит объекты удовлетворяющие "
"параметрам фильтрации."

# 0d937d9209f84bfbbe96b53423db16b3
#: ../../topics/db/queries.txt:192
msgid ""
"Returns a new ``QuerySet`` containing objects that do *not* match the given "
"lookup parameters."
msgstr ""
"Возвращает новый ``QuerySet`` содержащий объекты, которые *не* удовлетворяют "
"параметры фильтрации."

# aa47e448337245a48b065f3d29c84496
#: ../../topics/db/queries.txt:195
msgid ""
"The lookup parameters (``**kwargs`` in the above function definitions) "
"should be in the format described in `Field lookups`_ below."
msgstr ""
"Параметры фильтрации (``**kwargs`` в определении функций выше) должны быть в "
"формате описанном в разделе `Field lookups`_."

# 49dbfe6da92941528300a75cbbf1f08a
#: ../../topics/db/queries.txt:198
msgid ""
"For example, to get a ``QuerySet`` of blog entries from the year 2006, use "
"``filter()`` like so::"
msgstr ""
"Например, для создания ``QuerySet`` что бы получить записи с 2006, "
"используйте ``filter()`` таким образом::"

# ded654a1533b49ccbbc922bd7aa0fe0e
#: ../../topics/db/queries.txt:203
msgid ""
"We don't have to add an ``all()`` -- ``Entry.objects.all().filter(...)``. "
"That would still work, but you only need ``all()`` when you want all objects "
"from the root ``QuerySet``."
msgstr ""
"Мы не должны добавлять метод ``all()`` -- ``Entry.objects.all().filter(...)"
"``. Это будет работать, но вы должны использовать ``all()``, когда хотите "
"получить все объекты."

# eb78dea098a94225b381acb84fe69e50
#: ../../topics/db/queries.txt:210
msgid "Chaining filters"
msgstr "Цепочка фильтров"

# 586d2e9b00934a52af2fa7723197d315
#: ../../topics/db/queries.txt:212
msgid ""
"The result of refining a ``QuerySet`` is itself a ``QuerySet``, so it's "
"possible to chain refinements together. For example::"
msgstr ""
"Результат изменения ``QuerySet`` - это новый ``QuerySet``, по этому можно "
"использовать цепочки фильтров. Например::"

# 208aeca4bd80471f84a25f969113c2d4
#: ../../topics/db/queries.txt:223
msgid ""
"This takes the initial ``QuerySet`` of all entries in the database, adds a "
"filter, then an exclusion, then another filter. The final result is a "
"``QuerySet`` containing all entries with a headline that starts with \"What"
"\", that were published between January 1, 2005, and the current day."
msgstr ""
"В этом примере к начальному ``QuerySet``, который возвращает все объекты, "
"добавляется фильтр, затем исключающий фильтр, и еще один фильтр. Полученный "
"``QuerySet`` содержит все объекты, у которых заголовок начинается с  \"What"
"\", и которые были опубликованы между 1-го января 2005 и текущей датой."

# 71863ecd36b142f8a4e0d057a30b6c32
#: ../../topics/db/queries.txt:231
msgid "Filtered QuerySets are unique"
msgstr "Отфильтрованный QuerySets -- уникален"

# b6864fa2683b488b9811b1a1583915f1
#: ../../topics/db/queries.txt:233
msgid ""
"Each time you refine a ``QuerySet``, you get a brand-new ``QuerySet`` that "
"is in no way bound to the previous ``QuerySet``. Each refinement creates a "
"separate and distinct ``QuerySet`` that can be stored, used and reused."
msgstr ""
"После каждого изменения ``QuerySet``, вы получаете новый ``QuerySet``, "
"который никак не связан с предыдущим  ``QuerySet``. Каждый раз создается "
"отдельный  ``QuerySet``, который может быть сохранен и использован."

# dc29c0ea27ea476ab715e2683544683f
# 5e91e24cb1594c89b6bfe3f55ac80f24
# 433aa0a799de4613be266c553c4b00ce
#: ../../topics/db/queries.txt:237 ../../topics/db/queries.txt:964
#: ../../topics/db/queries.txt:1011
msgid "Example::"
msgstr "Например::"

# 33fbb1a88791463e85aa5048781e9106
#: ../../topics/db/queries.txt:243
msgid ""
"These three ``QuerySets`` are separate. The first is a base ``QuerySet`` "
"containing all entries that contain a headline starting with \"What\". The "
"second is a subset of the first, with an additional criteria that excludes "
"records whose ``pub_date`` is greater than now. The third is a subset of the "
"first, with an additional criteria that selects only the records whose "
"``pub_date`` is greater than now. The initial ``QuerySet`` (``q1``) is "
"unaffected by the refinement process."
msgstr ""
"Эти три ``QuerySets`` независимы. Первый -- это базовый ``QuerySet``, "
"который содержит все объекты с заголовками, которые начинаются с \"What\". "
"Второй -- это множество первых с дополнительным критерием фильтрации, "
"который исключает объекты с ``pub_date`` больше, чем текущая дата. Третий -- "
"это множество первого, с отфильтрованными объектами, у которых ``pub_date`` "
"больше, чем текущая дата. Первоначальный ``QuerySet`` (``q1``) не изменяется "
"последующим добавлением фильтров."

# d4643599691b41bfa29abd565dfdc595
#: ../../topics/db/queries.txt:254
msgid "QuerySets are lazy"
msgstr "QuerySets -- ленивы"

# 3ef428696244448f98e4b6327e75bd1e
#: ../../topics/db/queries.txt:256
msgid ""
"``QuerySets`` are lazy -- the act of creating a ``QuerySet`` doesn't involve "
"any database activity. You can stack filters together all day long, and "
"Django won't actually run the query until the ``QuerySet`` is *evaluated*. "
"Take a look at this example::"
msgstr ""
"``QuerySets`` -- ленивы, создание ``QuerySet`` не выполняет запросов к базе "
"данных. Вы можете добавлять фильтры хоть весь день и Django не выполнит ни "
"один запрос пока ``QuerySet`` не *вычислен*. Разберем такой пример::"

# 8257179a41074dbf85545adcceac9d26
#: ../../topics/db/queries.txt:266
msgid ""
"Though this looks like three database hits, in fact it hits the database "
"only once, at the last line (``print q``). In general, the results of a "
"``QuerySet`` aren't fetched from the database until you \"ask\" for them. "
"When you do, the ``QuerySet`` is *evaluated* by accessing the database. For "
"more details on exactly when evaluation takes place, see :ref:`when-"
"querysets-are-evaluated`."
msgstr ""
"Глядя на это можно подумать что было выполнено три запроса в базу данных. На "
"самом деле был выполнен один запрос, в последней строке (``print q``). "
"Результат ``QuerySet`` не будет получен из базы данных пока вы не \"попросите"
"\" об этом. Когда вы делаете это, ``QuerySet`` *вычисляется* запросом к базе "
"данных. Для подробностей, в какой момент выполняется запрос, смотрите :ref:"
"`when-querysets-are-evaluated`."

# 2674d6c7da6a4c189a08b80540561e2a
#: ../../topics/db/queries.txt:276
msgid "Retrieving a single object with get"
msgstr "Получение одного объекта с помощью ``get``"

# e2cc2906ccd04763950d12cb7d230178
#: ../../topics/db/queries.txt:278
msgid ""
"``.filter()`` will always give you a ``QuerySet``, even if only a single "
"object matches the query - in this case, it will be a ``QuerySet`` "
"containing a single element."
msgstr ""
"``.filter()`` всегда возвращает ``QuerySet``, даже если только один объект "
"возвращен запросом - в этом случае, это будет ``QuerySet`` содержащий один "
"объект."

# 0acb3c9442e44d02832a7e2ce77c75d5
#: ../../topics/db/queries.txt:282
msgid ""
"If you know there is only one object that matches your query, you can use "
"the ``get()`` method on a `Manager` which returns the object directly::"
msgstr ""
"Если вы знаете, что только один объект возвращается запросом, вы можете "
"использовать метод ``get()`` менеджера, который возвращает непосредственно "
"объект::"

# 315449410ab24115a7d18c12a37913f3
#: ../../topics/db/queries.txt:287
msgid ""
"You can use any query expression with ``get()``, just like with ``filter()`` "
"- again, see `Field lookups`_ below."
msgstr ""
"Вы можете использовать для ``get()`` аргументы, такие же как и для ``filter()"
"`` - смотрите `Field lookups`_ далее."

# feec9f84114f4941bcb44dc8b96269d6
#: ../../topics/db/queries.txt:290
msgid ""
"Note that there is a difference between using ``.get()``, and using ``.filter"
"()`` with a slice of ``[0]``. If there are no results that match the query, "
"``.get()`` will raise a ``DoesNotExist`` exception. This exception is an "
"attribute of the model class that the query is being performed on - so in "
"the code above, if there is no ``Entry`` object with a primary key of 1, "
"Django will raise ``Entry.DoesNotExist``."
msgstr ""
"Учтите, что есть разница между использованием ``.get()`` и ``.filter()`` с ``"
"[0]``. Если результат пустой, ``.get()`` вызовет исключение "
"``DoesNotExist``. Это исключение является атрибутом модели для которой "
"выполняется запрос. Если в примере выше, не существует объекта ``Entry`` с "
"первичным ключом равным 1, Django вызовет исключение ``Entry.DoesNotExist``."

# 150c11fe427a45418a203491b6d3f216
#: ../../topics/db/queries.txt:297
msgid ""
"Similarly, Django will complain if more than one item matches the ``get()`` "
"query. In this case, it will raise ``MultipleObjectsReturned``, which again "
"is an attribute of the model class itself."
msgstr ""
"Также Django отреагирует, если запрос ``get()`` вернет не один объект. В "
"этом случае будет вызвано исключение ``MultipleObjectsReturned``, которое "
"так же является атрибутом класса модели."

# 7020ee026d014fa39a53e805a0666d5d
#: ../../topics/db/queries.txt:303
msgid "Other QuerySet methods"
msgstr "Другие методы QuerySet"

# afc80b1fae7948d6a2ff98ecea318a5a
#: ../../topics/db/queries.txt:305
msgid ""
"Most of the time you'll use ``all()``, ``get()``, ``filter()`` and ``exclude"
"()`` when you need to look up objects from the database. However, that's far "
"from all there is; see the :ref:`QuerySet API Reference <queryset-api>` for "
"a complete list of all the various ``QuerySet`` methods."
msgstr ""
"В большинстве случаев вы будете использовать ``all()``, ``get()``, ``filter()"
"`` и ``exclude()`` для получения объектов из базы данных. Однако это не все "
"доступные возможности; смотрите :ref:`документацию о QuerySet API <queryset-"
"api>` для получения информации о всех существующих методах ``QuerySet``."

# e6ab06f5a63c4e5094c4759fe9d7fd90
#: ../../topics/db/queries.txt:313
msgid "Limiting QuerySets"
msgstr "Ограничение выборки"

# 848a171c660d468cb9817d448d4b1ff7
#: ../../topics/db/queries.txt:315
msgid ""
"Use a subset of Python's array-slicing syntax to limit your ``QuerySet`` to "
"a certain number of results. This is the equivalent of SQL's ``LIMIT`` and "
"``OFFSET`` clauses."
msgstr ""
"Используйте синтаксис срезов для списков Python для ограничения результата "
"выборки ``QuerySet``. Это эквивалент таких операторов SQL как ``LIMIT`` и "
"``OFFSET``."

# 9bfb58adbc01425c9338db52127220d9
#: ../../topics/db/queries.txt:319
msgid "For example, this returns the first 5 objects (``LIMIT 5``)::"
msgstr "Например, этот код возвращает 5 первых объектов (``LIMIT 5``)::"

# 9339b0a5a1424cd788eea90b9736832d
#: ../../topics/db/queries.txt:323
msgid "This returns the sixth through tenth objects (``OFFSET 5 LIMIT 5``)::"
msgstr "Этот возвращает с шестого по десятый (``OFFSET 5 LIMIT 5``)::"

# c21b44f0108f450e8d1cbfb175c98afb
#: ../../topics/db/queries.txt:327
msgid "Negative indexing (i.e. ``Entry.objects.all()[-1]``) is not supported."
msgstr ""
"Отрицательные индексы (например, ``Entry.objects.all()[-1]``) не "
"поддерживается."

# 5b26a862fb314eb9878516d586f8ed4b
#: ../../topics/db/queries.txt:329
msgid ""
"Generally, slicing a ``QuerySet`` returns a new ``QuerySet`` -- it doesn't "
"evaluate the query. An exception is if you use the \"step\" parameter of "
"Python slice syntax. For example, this would actually execute the query in "
"order to return a list of every *second* object of the first 10::"
msgstr ""
"На самом деле, срез ``QuerySet`` возвращает новый ``QuerySet`` -- запрос не "
"выполняется. При использовании аргумента \"шаг\" синтаксиса срезов в Python "
"будет вызвано исключение. Например, этот пример выполнил бы запрос, "
"возвращающий каждый *второй* объект из первых 10::"

# fadc974392e040b8b3a3fff0c101d29a
#: ../../topics/db/queries.txt:336
msgid ""
"To retrieve a *single* object rather than a list (e.g. ``SELECT foo FROM bar "
"LIMIT 1``), use a simple index instead of a slice. For example, this returns "
"the first ``Entry`` in the database, after ordering entries alphabetically "
"by headline::"
msgstr ""
"Для получения *одного* объекта, а не списка (например, ``SELECT foo FROM bar "
"LIMIT 1``), используйте индекс вместо среза. Например, этот код возвращает "
"первый объект ``Entry`` в базе данных, после сортировки записей по "
"заголовку::"

# 220cb5d52ebc474e87721620ed596880
#: ../../topics/db/queries.txt:343
msgid "This is roughly equivalent to::"
msgstr "Это эквивалент::"

# 569721c7a2fa41db8548d77a432bca46
#: ../../topics/db/queries.txt:347
msgid ""
"Note, however, that the first of these will raise ``IndexError`` while the "
"second will raise ``DoesNotExist`` if no objects match the given criteria. "
"See :meth:`~django.db.models.query.QuerySet.get` for more details."
msgstr ""
"Заметим, что первый пример вызовет ``IndexError`` в то время как первый - "
"``DoesNotExist``, если запрос вернет ни один объект. Смотрите :meth:`~django."
"db.models.query.QuerySet.get` для подробностей."

# 02f871217c9f4b9ea83acb8b1287a2cf
#: ../../topics/db/queries.txt:354
msgid "Field lookups"
msgstr "Фильтры полей"

# 598d069f7a26443fa09d4d8eea785a44
#: ../../topics/db/queries.txt:356
msgid ""
"Field lookups are how you specify the meat of an SQL ``WHERE`` clause. "
"They're specified as keyword arguments to the ``QuerySet`` methods ``filter()"
"``, ``exclude()`` and ``get()``."
msgstr ""
"Фильтры полей -- это \"операторы\" для составления условий SQL ``WHERE``. "
"Они задаются как именованные аргументы для метода ``filter()``, ``exclude()"
"`` и ``get()`` в ``QuerySet``."

# 9f1e3bb16101488693f7c293b170d957
#: ../../topics/db/queries.txt:360
msgid ""
"Basic lookups keyword arguments take the form ``field__lookuptype=value``. "
"(That's a double-underscore). For example::"
msgstr ""
"Фильтры полей выглядят как ``field__lookuptype=value``. (Используется "
"двойное подчеркивание). Например::"

# 1a5163a9e32446308bf900587d901cec
#: ../../topics/db/queries.txt:365
msgid "translates (roughly) into the following SQL::"
msgstr "будет транслировано в SQL::"

# fea015493f45478bb68f74805f67e744
#: ../../topics/db/queries.txt:371
msgid ""
"Python has the ability to define functions that accept arbitrary name-value "
"arguments whose names and values are evaluated at runtime. For more "
"information, see `Keyword Arguments`_ in the official Python tutorial."
msgstr ""
"Python позволяет определить функции, которые принимают именованные аргументы "
"с динамически вычисляемыми названиями и значениями. Подробности смотрите в "
"разделе `Именованные аргументы <http://docs.python.org/tutorial/controlflow."
"html#keyword-arguments>`_ в официальной документации Python."

# e3c6e5556fe04855a379c97c888c3b8e
#: ../../topics/db/queries.txt:386
msgid ""
"If you pass an invalid keyword argument, a lookup function will raise "
"``TypeError``."
msgstr ""
"При передаче неверного именованного аргумента, будет вызвано исключение "
"``TypeError``."

# 43f6899d141c4ab9ade3aa47a6c1052f
#: ../../topics/db/queries.txt:389
msgid ""
"The database API supports about two dozen lookup types; a complete reference "
"can be found in the :ref:`field lookup reference <field-lookups>`. To give "
"you a taste of what's available, here's some of the more common lookups "
"you'll probably use:"
msgstr ""
"API базы данных поддерживает около двух дюжин фильтров; полный список можно "
"найти в :ref:`разделе о фильтрах полей <field-lookups>`. Вот пример самых "
"используемых фильтров:"

# 28bae35c780c4821ae88dba1112fb92e
#: ../../topics/db/queries.txt:394
msgid "An \"exact\" match. For example::"
msgstr "\"Точное\" совпадение. Например::"

# b019ec8c34b146878d932824f57f1ae9
#: ../../topics/db/queries.txt:398
msgid "Would generate SQL along these lines:"
msgstr "Создаст такой SQL запрос:"

# 8614ff18facd4222a3ad393eaf8905b3
#: ../../topics/db/queries.txt:404
msgid ""
"If you don't provide a lookup type -- that is, if your keyword argument "
"doesn't contain a double underscore -- the lookup type is assumed to be "
"``exact``."
msgstr ""
"Если вы не укажите фильтр -- именованный аргумент не содержит двойное "
"подчеркивание -- будет использован фильтр ``exact``."

# 37440d02b41842a183968a9de6a21096
#: ../../topics/db/queries.txt:408
msgid "For example, the following two statements are equivalent::"
msgstr "Например, эти два выражения идентичны::"

# ef0175f7fcca4bcf9b90b44d1c0ce1a9
#: ../../topics/db/queries.txt:413
msgid "This is for convenience, because ``exact`` lookups are the common case."
msgstr ""
"Это сделано для удобства, т.к. ``exact`` самый распространенный фильтр."

# 71dcd93a692e47b6a4047f2d9dd82f06
#: ../../topics/db/queries.txt:416
msgid "A case-insensitive match. So, the query::"
msgstr "Регистро-независимый совпадение. Такой запрос::"

# 8433df2478144fbda0847a88ed8ccca6
#: ../../topics/db/queries.txt:420
msgid ""
"Would match a ``Blog`` titled \"Beatles Blog\", \"beatles blog\", or even "
"\"BeAtlES blOG\"."
msgstr ""
"Найдет ``Blog`` с названием \"Beatles Blog\", \"beatles blog\", и даже "
"\"BeAtlES blOG\"."

# 76db870a6e6c41db983f2ffff7de61ce
#: ../../topics/db/queries.txt:424
msgid "Case-sensitive containment test. For example::"
msgstr "Регистро-зависимая проверка на вхождение. Например::"

# bc59e9b2d10d44c9a3c49044f7dc3b6f
#: ../../topics/db/queries.txt:428
msgid "Roughly translates to this SQL:"
msgstr "Будет конвертировано в такой SQL запрос:"

# 2307a528ce81481382b9a8a56a3682ef
#: ../../topics/db/queries.txt:434
msgid ""
"Note this will match the headline ``'Today Lennon honored'`` but not "
"``'today lennon honored'``."
msgstr ""
"Заметим что этот пример найдет заголовок ``'Today Lennon honored'``, но не "
"найдет ``'today lennon honored'``."

# f7a625a14ee24abebce04602d73e8f6c
#: ../../topics/db/queries.txt:437
msgid "There's also a case-insensitive version, :lookup:`icontains`."
msgstr "Существует так же регистро-независимые версии, :lookup:`icontains`."

# 203d7a48fcab4001a57459e299a75d81
#: ../../topics/db/queries.txt:440
msgid ""
"Starts-with and ends-with search, respectively. There are also case-"
"insensitive versions called :lookup:`istartswith` and :lookup:`iendswith`."
msgstr ""
"Поиск по началу и окончанию соответственно. Существуют также регистро-"
"независимые версии :lookup:`istartswith` и :lookup:`iendswith`."

# 87cd7f058691427ba396a54066760024
#: ../../topics/db/queries.txt:444
msgid ""
"Again, this only scratches the surface. A complete reference can be found in "
"the :ref:`field lookup reference <field-lookups>`."
msgstr ""
"Это только основные фильтры. Полный список ищите в :ref:`разделе о фильтрах "
"по полям <field-lookups>`."

# 29d44ab4f0cc4353909092c2dfe0ea24
#: ../../topics/db/queries.txt:448
msgid "Lookups that span relationships"
msgstr "Фильтры по связанным объектам"

# 9f2fa0201f9949d9aae759ad993fa66e
#: ../../topics/db/queries.txt:450
msgid ""
"Django offers a powerful and intuitive way to \"follow\" relationships in "
"lookups, taking care of the SQL ``JOIN``\\s for you automatically, behind "
"the scenes. To span a relationship, just use the field name of related "
"fields across models, separated by double underscores, until you get to the "
"field you want."
msgstr ""
"Django предлагает удобный и понятный интерфейс для фильтрации по связанным "
"объектам, самостоятельно заботясь о ``JOIN`` в SQL. Для фильтра по полю из "
"связанных моделей, используйте имена связывающих полей разделенных двойным "
"нижним подчеркиванием, пока вы не достигните нужного поля."

# 55e64e2168d84553a6b63ad8f2b42fdf
#: ../../topics/db/queries.txt:456
msgid ""
"This example retrieves all ``Entry`` objects with a ``Blog`` whose ``name`` "
"is ``'Beatles Blog'``::"
msgstr ""
"Этот пример получает все объекты ``Entry`` с ``Blog``, ``name`` которого "
"равен ``'Beatles Blog'``::"

# 168b259fd9f04a82ac775974bef1915e
#: ../../topics/db/queries.txt:461
msgid "This spanning can be as deep as you'd like."
msgstr "Этот поиск может быть на столько глубоким, на сколько вам нужно."

# 9069ac0d75b44358b5f125d83bb77179
#: ../../topics/db/queries.txt:463
msgid ""
"It works backwards, too. To refer to a \"reverse\" relationship, just use "
"the lowercase name of the model."
msgstr ""
"Все работает и в другую сторону. Что бы обратиться к \"обратной\" связи, "
"просто используйте имя модели в нижнем регистре."

# d27965616e9f48a18d38c51eaf12d4c6
#: ../../topics/db/queries.txt:466
msgid ""
"This example retrieves all ``Blog`` objects which have at least one "
"``Entry`` whose ``headline`` contains ``'Lennon'``::"
msgstr ""
"Этот пример получает все объект ``Blog``, которые имеют хотя бы один "
"связанный объект ``Entry`` с ``headline`` содержащим ``'Lennon'``::"

# 36fad69af884472cb2ced7751e38b3bc
#: ../../topics/db/queries.txt:471
msgid ""
"If you are filtering across multiple relationships and one of the "
"intermediate models doesn't have a value that meets the filter condition, "
"Django will treat it as if there is an empty (all values are ``NULL``), but "
"valid, object there. All this means is that no error will be raised. For "
"example, in this filter::"
msgstr ""
"Если вы используйте фильтр через несколько связей и одна из промежуточных "
"моделей не содержит подходящей связи, Django расценит это как пустое "
"значение (все значения равны ``NULL``). Исключение не будет вызвано. "
"Например, в этом фильтре::"

# ea722f4d5cae4ae8a56cfdec92c36bac
#: ../../topics/db/queries.txt:478
msgid ""
"(if there was a related ``Author`` model), if there was no ``author`` "
"associated with an entry, it would be treated as if there was also no "
"``name`` attached, rather than raising an error because of the missing "
"``author``. Usually this is exactly what you want to have happen. The only "
"case where it might be confusing is if you are using ``isnull``. Thus::"
msgstr ""
"(при связанной модели ``Author``), если нет объекта ``author`` связанного с "
"``entry``, это будет расценено как отсутствие ``name``, вместо вызова "
"исключения т.к. ``author`` отсутствует. В большинстве случаев это то, что "
"вам нужно. Единственный случай, когда это может работать не однозначно - при "
"использовании ``isnull``. Например::"

# 6b8ae985d83a4a9182be16753422ad76
#: ../../topics/db/queries.txt:486
msgid ""
"will return ``Blog`` objects that have an empty ``name`` on the ``author`` "
"and also those which have an empty ``author`` on the ``entry``. If you don't "
"want those latter objects, you could write::"
msgstr ""
"вернет объекты ``Blog`` у которого пустое поле ``name`` у ``author`` и также "
"объекты, у которых пустой ``author``в  ``entry``. Если вы не хотите включать "
"вторые объекты, используйте::"

# 7dfbc48ae5eb436293a1ebe39fe76c49
#: ../../topics/db/queries.txt:494
msgid "Spanning multi-valued relationships"
msgstr "Фильтрация по связям много-ко-многим"

# ae164b44f5564345b5d2ce74f2fae93a
#: ../../topics/db/queries.txt:496
msgid ""
"When you are filtering an object based on a ``ManyToManyField`` or a reverse "
"``ForeignKey``, there are two different sorts of filter you may be "
"interested in. Consider the ``Blog``/``Entry`` relationship (``Blog`` to "
"``Entry`` is a one-to-many relation). We might be interested in finding "
"blogs that have an entry which has both *\"Lennon\"* in the headline and was "
"published in 2008. Or we might want to find blogs that have an entry with *"
"\"Lennon\"* in the headline as well as an entry that was published in 2008. "
"Since there are multiple entries associated with a single ``Blog``, both of "
"these queries are possible and make sense in some situations."
msgstr ""
"Когда вы используете фильтрация по связанным через ``ManyToManyField`` "
"объектам или по обратной связи для ``ForeignKey``, может быть два вида "
"фильтров. Рассмотрим свзять ``Blog``/``Entry`` (от ``Blog`` к ``Entry`` -- "
"это связь один-ко-многим). Нам может понадобиться получить блоги с записями, "
"у которых заголовок содержит *\"Lennon\"* и которые были опубликованы в "
"2008. Или нам могут понадобиться блоги с записями с *\"Lennon\"* в заголовке "
"и в то же время блоги с записями опубликованными до 2008. Т.к. один ``Blog`` "
"может иметь несколько связанных ``Entry``, оба варианта возможны."

# 3723c17a0362496e9cb5312c546c5ee2
#: ../../topics/db/queries.txt:506
msgid ""
"The same type of situation arises with a ``ManyToManyField``. For example, "
"if an ``Entry`` has a ``ManyToManyField`` called ``tags``, we might want to "
"find entries linked to tags called *\"music\"* and *\"bands\"* or we might "
"want an entry that contains a tag with a name of *\"music\"* and a status of "
"*\"public\"*."
msgstr ""
"Аналогичная ситуация и с ``ManyToManyField``. Например, если ``Entry`` имеет "
"``ManyToManyField`` названное ``tags``, нам могут понадобиться записи "
"связанные с тегами *\"music\"* и *\"bands\"* или нам может понадобиться "
"запись содержащая тег *\"music\"* и статусом *\"public\"*."

# c0cfd5cb496e46b9a50035f791c80e6f
#: ../../topics/db/queries.txt:511
msgid ""
"To handle both of these situations, Django has a consistent way of "
"processing ``filter()`` and ``exclude()`` calls. Everything inside a single "
"``filter()`` call is applied simultaneously to filter out items matching all "
"those requirements. Successive ``filter()`` calls further restrict the set "
"of objects, but for multi-valued relations, they apply to any object linked "
"to the primary model, not necessarily those objects that were selected by an "
"earlier ``filter()`` call."
msgstr ""
"Что бы обеспечить оба варианта, Django использует определенные правила для "
"вызовов ``filter()`` и ``exclude()``. Все, что в одном вызове ``filter()``, "
"применяется одновременно, чтобы отфильтровать все объекты, соответствующие "
"этим параметрам фильтрации. Успешные вызовы ``filter()`` каждый раз "
"сокращают выборку объектов, но для множественных связей, они применяются "
"каждый раз ко всем связанным объектам, а не только к объектам "
"отфильтрованным предыдущим вызовом ``filter()``."

# 7bd3f99bf3fe44208404a8672d8a7292
#: ../../topics/db/queries.txt:519
msgid ""
"That may sound a bit confusing, so hopefully an example will clarify. To "
"select all blogs that contain entries with both *\"Lennon\"* in the headline "
"and that were published in 2008 (the same entry satisfying both conditions), "
"we would write::"
msgstr ""
"Звучит немного непонятно, но пример должен все прояснить. Для выбора всех "
"блогов, содержащих записи и с *\"Lennon\"* в заголовке и опубликованные в "
"2008 (запись должна удовлетворять оба условия), мы будем использовать такой "
"код::"

# 7a884561801443c9a3944ea257dd4c99
#: ../../topics/db/queries.txt:527
msgid ""
"To select all blogs that contain an entry with *\"Lennon\"* in the headline "
"**as well as** an entry that was published in 2008, we would write::"
msgstr ""
"Для выбора блогов с записями, у которых заголовок содержит *\"Lennon\"*, **а "
"так же** с записями опубликованными в 2008, мы напишем::"

# 0171ffc0fb7c48c2a81d1c78dbad5d72
#: ../../topics/db/queries.txt:533
msgid ""
"In this second example, the first filter restricted the queryset to all "
"those blogs linked to that particular type of entry. The second filter "
"restricted the set of blogs *further* to those that are also linked to the "
"second type of entry. The entries select by the second filter may or may not "
"be the same as the entries in the first filter. We are filtering the "
"``Blog`` items with each filter statement, not the ``Entry`` items."
msgstr ""
"В это примере, первый фильтр ограничит выборку блогами с определенными "
"связанными записями. Второй фильтр *расширит* выборку блогами с записями "
"второго типа. Записи выбранные вторым фильтром могут быть такими же как и из "
"первого фильтра, а могут и не быть. Мы фильтруем объекты ``Blog`` с каждым "
"вызовом ``filter()``, а не объекты ``Entry``."

# e0c354100c6a4f72b5ed282f90ac2cf3
#: ../../topics/db/queries.txt:540
msgid ""
"All of this behavior also applies to ``exclude()``: all the conditions in a "
"single ``exclude()`` statement apply to a single instance (if those "
"conditions are talking about the same multi-valued relation). Conditions in "
"subsequent ``filter()`` or ``exclude()`` calls that refer to the same "
"relation may end up filtering on different linked objects."
msgstr ""
"Все эти правила так же распространяются и на ``exclude()``: все условия в "
"одном ``exclude()`` применяются к одному объекту (если это условия для "
"множественной связи)."

# d03542d8cfc94a68be7678d4fc5c16c3
#: ../../topics/db/queries.txt:549
msgid "Filters can reference fields on the model"
msgstr "Фильтры могут ссылаться на поля на модели"

# daf680ef5b7b4c1dae58f9d4d4715432
#: ../../topics/db/queries.txt:551
msgid ""
"In the examples given so far, we have constructed filters that compare the "
"value of a model field with a constant. But what if you want to compare the "
"value of a model field with another field on the same model?"
msgstr ""
"В примерах выше мы использовали фильтры, которые приравнивали поля к "
"определенным значениям(константам). Но что, если вы хотите сравнить одно "
"поле с другим полем одной модели?"

# 96c2498aa253463899e504d5e5696d0a
#: ../../topics/db/queries.txt:555
msgid ""
"Django provides the ``F()`` object to allow such comparisons. Instances of "
"``F()`` act as a reference to a model field within a query. These references "
"can then be used in query filters to compare the values of two different "
"fields on the same model instance."
msgstr ""
"Django предоставляет объект ``F()`` для таких сравнений. Экземпляр ``F()`` "
"рассматривается как ссылка на другое поле модели. Эти ссылки могут быть "
"использованы для сравнения значений двух разных полей одного объекта модели."

# 5dbba97bfd8d46feb6b62def596a66b8
#: ../../topics/db/queries.txt:560
msgid ""
"For example, to find a list of all blog entries that have had more comments "
"than pingbacks, we construct an ``F()`` object to reference the pingback "
"count, and use that ``F()`` object in the query::"
msgstr ""
"Например, что бы выбрать все записи, у которых количество комментариев "
"больше, чем \"pingback\", мы создаем объект ``F()`` с ссылкой на поле "
"\"pingback\", и использовать этот объект ``F()`` в запросе::"

# 38a8b48e80b240bd876eb2daf7ebd84b
#: ../../topics/db/queries.txt:567
msgid ""
"Django supports the use of addition, subtraction, multiplication, division "
"and modulo arithmetic with ``F()`` objects, both with constants and with "
"other ``F()`` objects. To find all the blog entries with more than *twice* "
"as many comments as pingbacks, we modify the query::"
msgstr ""
"Django поддерживает операции суммирования, вычитания, умножения, деления и "
"арифметический модуль для объектов ``F()``, с константами или другими "
"объектами ``F()``. Что бы найти все записи с количеством комментариев в *два "
"раза больше* чем \"pingbacks\", используем такой запрос::"

# 1b4656c76a914e7c989975855b270f2d
#: ../../topics/db/queries.txt:574
msgid ""
"To find all the entries where the rating of the entry is less than the sum "
"of the pingback count and comment count, we would issue the query::"
msgstr ""
"Что бы найти все записи с рейтингом ниже суммы \"pingback\" и количества "
"комментариев, необходимо выполнить такой запрос::"

# 7640beb6287741be8fb1e3b627883152
#: ../../topics/db/queries.txt:580
msgid ""
"You can also use the double underscore notation to span relationships in an "
"``F()`` object. An ``F()`` object with a double underscore will introduce "
"any joins needed to access the related object. For example, to retrieve all "
"the entries where the author's name is the same as the blog name, we could "
"issue the query::"
msgstr ""
"Вы можете использовать два нижних подчеркивания для использования полей "
"связанных объектов в ``F()``. Объект ``F()`` с двойным нижним подчеркиванием "
"обеспечит все необходимые ``JOIN`` для получения необходимых связанных "
"объектов. Например, что бы получить все записи, у которых имя автора "
"совпадает с названием блога, нужно выполнить такой запрос::"

# 33f2bb6676324a2ab398a74705af9cfa
#: ../../topics/db/queries.txt:590
msgid ""
"For date and date/time fields, you can add or subtract a ``datetime."
"timedelta`` object.  The following would return all entries that were "
"modified more than 3 days after they were published::"
msgstr ""
"Для полей даты и времени вы можете использовать сумму или разницу объектов "
"``datetime.timedelta``.  Этот код вернет все записи, которые были "
"отредактированы через 3 дня после публикации::"

# 747410fa45a143589fc635ec7d748c00
#: ../../topics/db/queries.txt:598
msgid "The pk lookup shortcut"
msgstr "\"Shortcut\" для фильтрации по первичному ключу"

# 6be18a0ecccd41218e0df6f3492c6655
#: ../../topics/db/queries.txt:600
msgid ""
"For convenience, Django provides a ``pk`` lookup shortcut, which stands for "
"\"primary key\"."
msgstr ""
"Для удобства, Django предоставляет специальный фильтр ``pk`` для работы с "
"первичным ключом."

# 729e96fa9f6a4d15b7aceb1bf99a25c1
#: ../../topics/db/queries.txt:603
msgid ""
"In the example ``Blog`` model, the primary key is the ``id`` field, so these "
"three statements are equivalent::"
msgstr ""
"Например, первичный ключ модели ``Blog`` -- поле ``id``. Эти три запроса "
"идентичны::"

# bd8f98e87fe64fb5b741d19900b4d293
#: ../../topics/db/queries.txt:610
msgid ""
"The use of ``pk`` isn't limited to ``__exact`` queries -- any query term can "
"be combined with ``pk`` to perform a query on the primary key of a model::"
msgstr ""
"Использование ``pk`` не ограничено только фильтром ``__exact`` -- любой "
"фильтр может быть использован с ``pk``::"

# 440e5e390e324d54a6a24936e7a08982
#: ../../topics/db/queries.txt:619
msgid ""
"``pk`` lookups also work across joins. For example, these three statements "
"are equivalent::"
msgstr ""
"``pk`` работает так же и для связей. Например, эти три запроса идентичны::"

# 2734ae7f3b434e19bf4dc2c193c3f548
#: ../../topics/db/queries.txt:627
msgid "Escaping percent signs and underscores in LIKE statements"
msgstr ""
"Экранирование знака процента и нижнего подчеркивания для оператора LIKE"

# 6b8f4c6a30084ef9aea95d40f8316362
#: ../../topics/db/queries.txt:629
msgid ""
"The field lookups that equate to ``LIKE`` SQL statements (``iexact``, "
"``contains``, ``icontains``, ``startswith``, ``istartswith``, ``endswith`` "
"and ``iendswith``) will automatically escape the two special characters used "
"in ``LIKE`` statements -- the percent sign and the underscore. (In a "
"``LIKE`` statement, the percent sign signifies a multiple-character wildcard "
"and the underscore signifies a single-character wildcard.)"
msgstr ""
"Фильтры, эквивалентые оператору ``LIKE`` в SQL(``iexact``, ``contains``, "
"``icontains``, ``startswith``, ``istartswith``, ``endswith`` и "
"``iendswith``), автоматически экранируют два символа используемых оператором "
"``LIKE`` -- знак процента и нижнего подчеркивания. (В операторе ``LIKE``, "
"знак процента означает \"wildcard\" из нескольких символов, нижнего "
"подчеркивания - одно-символьный \"wildcard\".)"

# 3f68ccdad09a4628adaf0417bb4b9e02
#: ../../topics/db/queries.txt:636
msgid ""
"This means things should work intuitively, so the abstraction doesn't leak. "
"For example, to retrieve all the entries that contain a percent sign, just "
"use the percent sign as any other character::"
msgstr ""
"Это делает работу с API интуитивно-понятной. Например, что бы получить все "
"записи со знаком процента, просто используйте символ знака процента как "
"любой другой символ::"

# 27aaccc5d173456191bdc649cfc4bc5d
#: ../../topics/db/queries.txt:642
msgid ""
"Django takes care of the quoting for you; the resulting SQL will look "
"something like this:"
msgstr ""
"Django самостоятельно позаботится об экранировании; полученный SQL будет "
"выглядеть приблизительно вот так:"

# d7edc2b172e44cdab998ca5284b7346a
#: ../../topics/db/queries.txt:649
msgid ""
"Same goes for underscores. Both percentage signs and underscores are handled "
"for you transparently."
msgstr ""
"Так же работает и символ нижнего подчеркивания. Оба, знак процента и нижнего "
"подчеркивания, обрабатываются автоматически, прозрачно для вас."

# f968d2f6665c47a0854ca91731525e61
#: ../../topics/db/queries.txt:655
msgid "Caching and QuerySets"
msgstr "Кеширование и QuerySets"

# 4410cb11d332487280399ced7fbba0d0
#: ../../topics/db/queries.txt:657
msgid ""
"Each ``QuerySet`` contains a cache, to minimize database access. It's "
"important to understand how it works, in order to write the most efficient "
"code."
msgstr ""
"Каждый ``QuerySet`` содержит кеш, для уменьшения количества запросов. Очень "
"важно знать как он работает, для эффективного использования Django."

# 5212b8430b004737973f06edf4697629
#: ../../topics/db/queries.txt:660
msgid ""
"In a newly created ``QuerySet``, the cache is empty. The first time a "
"``QuerySet`` is evaluated -- and, hence, a database query happens -- Django "
"saves the query results in the ``QuerySet``'s cache and returns the results "
"that have been explicitly requested (e.g., the next element, if the "
"``QuerySet`` is being iterated over). Subsequent evaluations of the "
"``QuerySet`` reuse the cached results."
msgstr ""
"В только что созданном ``QuerySet`` кеш пустой. После вычисления "
"``QuerySet`` -- и будет выполнен запрос к базе данных -- Django сохраняет "
"результат запроса в кеше ``QuerySet`` и возвращает необходимый результат "
"(например, следующий элемент при итерации по ``QuerySet``). Последующие "
"вычисления ``QuerySet`` используют кеш."

# 485d2b9560224de6b2e96c47e41c0c9a
#: ../../topics/db/queries.txt:667
msgid ""
"Keep this caching behavior in mind, because it may bite you if you don't use "
"your ``QuerySet``\\s correctly. For example, the following will create two "
"``QuerySet``\\s, evaluate them, and throw them away::"
msgstr ""
"Помните о кешировании, что бы использовать ``QuerySet`` правильно. Например, "
"этот код создаст два экземпляра ``QuerySet`` и вычислит их не сохраняя::"

# 17a35f3adc8d43928f2e476a2e1a30ef
#: ../../topics/db/queries.txt:674
msgid ""
"That means the same database query will be executed twice, effectively "
"doubling your database load. Also, there's a possibility the two lists may "
"not include the same database records, because an ``Entry`` may have been "
"added or deleted in the split second between the two requests."
msgstr ""
"Это означает, что один и тот же запрос будет выполнен дважды, удваивая "
"нагрузку на базу данных. Также, есть вероятность, что списки могут содержать "
"разные результаты, потому что запись ``Entry`` может быть добавлена или "
"удалена в доли секунды между запросами."

# 32a73dc57b404d8a85eef07fc6ceb410
#: ../../topics/db/queries.txt:679
msgid "To avoid this problem, simply save the ``QuerySet`` and reuse it::"
msgstr ""
"Что бы избежать этой проблемы, просто сохраните ``QuerySet`` и используйте "
"его повторно::"

# 223d8b76d30d4f8b8c5539dc89d26e90
#: ../../topics/db/queries.txt:688
msgid "Complex lookups with Q objects"
msgstr "Сложные запросы с помощью объектов Q"

# 875b5fab606e49688631a843c5dc1bed
#: ../../topics/db/queries.txt:690
msgid ""
"Keyword argument queries -- in ``filter()``, etc. -- are \"AND\"ed together. "
"If you need to execute more complex queries (for example, queries with "
"``OR`` statements), you can use ``Q`` objects."
msgstr ""
"Именованные аргументы функции ``filter()`` и др. -- объединяются оператором "
"\"AND\". Если вам нужны более сложные запросы (например, запросы с "
"оператором ``OR``), вы можете использовать объекты ``Q``."

# 674127ebd747487089e469ba45fff1d4
#: ../../topics/db/queries.txt:694
msgid ""
"A ``Q`` object (``django.db.models.Q``) is an object used to encapsulate a "
"collection of keyword arguments. These keyword arguments are specified as in "
"\"Field lookups\" above."
msgstr ""
"Объект ``Q``(``django.db.models.Q``) -- объект, используемый для "
"инкапсуляции множества именованных аргументов для фильтрации. Аргументы "
"определяются так же как и в примерах выше."

# 9a3eea84c46149589a0b8881e789cc9b
#: ../../topics/db/queries.txt:698
msgid "For example, this ``Q`` object encapsulates a single ``LIKE`` query::"
msgstr "Например, этот объект ``Q`` определяет запрос ``LIKE``::"

# bbefbbfb4d0941eda81fa43a71138c0c
#: ../../topics/db/queries.txt:703
msgid ""
"``Q`` objects can be combined using the ``&`` and ``|`` operators. When an "
"operator is used on two ``Q`` objects, it yields a new ``Q`` object."
msgstr ""
"Объекты ``Q`` могут быть объединены операторами  ``&`` и ``|``, при этом "
"будет создан новый объект ``Q``."

# e9d6d727a53a43669301e5b843e7d03e
#: ../../topics/db/queries.txt:706
msgid ""
"For example, this statement yields a single ``Q`` object that represents the "
"\"OR\" of two ``\"question__startswith\"`` queries::"
msgstr ""
"Например, это определение представляет объект ``Q``, который представляет "
"операцию \"OR\" двух фильтров с ``\"question__startswith\"``::"

# 705510ff892d44f3a18cc95c9ae46d5d
#: ../../topics/db/queries.txt:711
msgid "This is equivalent to the following SQL ``WHERE`` clause::"
msgstr "Этот фильтр равнозначен такому оператору SQL ``WHERE``::"

# c13885b1e2874b65ad91bf58787a1240
#: ../../topics/db/queries.txt:715
msgid ""
"You can compose statements of arbitrary complexity by combining ``Q`` "
"objects with the ``&`` and ``|`` operators and use parenthetical grouping. "
"Also, ``Q`` objects can be negated using the ``~`` operator, allowing for "
"combined lookups that combine both a normal query and a negated (``NOT``) "
"query::"
msgstr ""
"Вы можете комбинировать различные объекты ``Q`` с операторами ``&`` и ``|`` "
"и использовать скобки. Можно использовать оператор ``~`` для отрицания"
"(``NOT``) в запросе::"

# 3ccf0a35a62341d087ac8e8fcd6a514d
#: ../../topics/db/queries.txt:722
msgid ""
"Each lookup function that takes keyword-arguments (e.g. ``filter()``, "
"``exclude()``, ``get()``) can also be passed one or more ``Q`` objects as "
"positional (not-named) arguments. If you provide multiple ``Q`` object "
"arguments to a lookup function, the arguments will be \"AND\"ed together. "
"For example::"
msgstr ""
"Каждый метод для фильтрации, который принимает именованные аргументы "
"(например, ``filter()``, ``exclude()``, ``get()``) так же может принимать "
"объекты ``Q``. Если вы передадите несколько объектов ``Q`` как аргументы, "
"они будут объединены оператором \"AND\". Например::"

# 8a2b582e756f4e25af771abdd008aa2b
#: ../../topics/db/queries.txt:733
msgid "... roughly translates into the SQL::"
msgstr "... примерно переводится в SQL::"

# 5bd89ed905d94e80912bef8cf3999e92
#: ../../topics/db/queries.txt:738
msgid ""
"Lookup functions can mix the use of ``Q`` objects and keyword arguments. All "
"arguments provided to a lookup function (be they keyword arguments or ``Q`` "
"objects) are \"AND\"ed together. However, if a ``Q`` object is provided, it "
"must precede the definition of any keyword arguments. For example::"
msgstr ""
"Вы можете использовать одновременно объекты ``Q`` и именованные аргументы. "
"Все аргументы(будь то именованные аргументы или объекты ``Q``) объединяются "
"оператором \"AND\". Однако, если присутствует объект ``Q``, он должен "
"следовать перед именованными аргументами. Например::"

# 91663bded41c4d89abffacd92cd56d7b
#: ../../topics/db/queries.txt:747
msgid "... would be a valid query, equivalent to the previous example; but::"
msgstr "... правильный запрос, идентичный предыдущему примеру; но::"

# 824e3be530e94066a9a7ca961684fbb0
#: ../../topics/db/queries.txt:754
msgid "... would not be valid."
msgstr ""
"... будет не правильный`(Вообще Django здесь не причем. Синтаксис Python не "
"позволяет передавать именованные аргументы перед позиционными -- прим. "
"переводчика)`."

# 9c3dc79cbab141ecbcf0b54674db105b
#: ../../topics/db/queries.txt:758
msgid ""
"The `OR lookups examples`_ in the Django unit tests show some possible uses "
"of ``Q``."
msgstr ""
"Вы можете найти `примеры использования OR с Q <https://code.djangoproject."
"com/browser/django/trunk/tests/modeltests/or_lookups/tests.py>`_."

# 2a5bbb7cbe4b4308baaa21b4faf17e95
#: ../../topics/db/queries.txt:764
msgid "Comparing objects"
msgstr "Сравнение объектов"

# 3b377f861a164ba2922f651aebf8b364
#: ../../topics/db/queries.txt:766
msgid ""
"To compare two model instances, just use the standard Python comparison "
"operator, the double equals sign: ``==``. Behind the scenes, that compares "
"the primary key values of two models."
msgstr ""
"Для сравнения двух экземпляров модели, используйте стандартный оператор "
"сравнения Python, двойной знак равно: ``==``. При этом будут сравнены "
"первичные ключи."

# 34f084c0f65143feb8d10782bf55a4f1
#: ../../topics/db/queries.txt:770
msgid ""
"Using the ``Entry`` example above, the following two statements are "
"equivalent::"
msgstr ""
"Используя модель ``Entry`` из примеров выше, эти два утверждения "
"эквивалентны::"

# c67dd80bf875447c9ef8fe8c99a2a3ba
#: ../../topics/db/queries.txt:775
msgid ""
"If a model's primary key isn't called ``id``, no problem. Comparisons will "
"always use the primary key, whatever it's called. For example, if a model's "
"primary key field is called ``name``, these two statements are equivalent::"
msgstr ""
"Если первичный ключ назван не ``id`` -- это не проблема. Сравнение всегда "
"использует первичный ключ. Например, если первичный ключ назван ``name``, "
"эти два утверждения эквивалентны::"

# e79b6b8b79214d0ebdcf90a1ea3296c2
#: ../../topics/db/queries.txt:785
msgid "Deleting objects"
msgstr "Удаление объектов"

# 12c8a561a8db436cac6b9e7026b6169b
#: ../../topics/db/queries.txt:787
msgid ""
"The delete method, conveniently, is named ``delete()``. This method "
"immediately deletes the object and has no return value. Example::"
msgstr ""
"Метод удаления соответственно называется ``delete()``. Этот метод сразу "
"удаляет объект и ничего не возвращает. Например::"

# f562bcec62704e03a6eeca005171bafd
#: ../../topics/db/queries.txt:792
msgid ""
"You can also delete objects in bulk. Every ``QuerySet`` has a ``delete()`` "
"method, which deletes all members of that ``QuerySet``."
msgstr ""
"Можно так же удалить несколько объектов сразу. Каждый ``QuerySet`` имеет "
"метод ``delete()``, который удаляет все объекты из ``QuerySet``."

# 29d5a6d552b34dfc902b9af19607082a
#: ../../topics/db/queries.txt:795
msgid ""
"For example, this deletes all ``Entry`` objects with a ``pub_date`` year of "
"2005::"
msgstr ""
"Например, этот код удаляет все объекты ``Entry`` у годом ``pub_date`` равным "
"2005::"

# 42fafab98e06479d880cc1d583dee050
#: ../../topics/db/queries.txt:800
msgid ""
"Keep in mind that this will, whenever possible, be executed purely in SQL, "
"and so the ``delete()`` methods of individual object instances will not "
"necessarily be called during the process. If you've provided a custom "
"``delete()`` method on a model class and want to ensure that it is called, "
"you will need to \"manually\" delete instances of that model (e.g., by "
"iterating over a ``QuerySet`` and calling ``delete()`` on each object "
"individually) rather than using the bulk ``delete()`` method of a "
"``QuerySet``."
msgstr ""
"Учтите, что при любой возможности будет использован непосредственно SQL "
"запрос, то есть метод ``delete()`` объекта может и не использоваться при "
"удалении. Если вы переопределяете метод ``delete()`` модели и хотите быть "
"уверенным, что он будет вызван, вы должны \"самостоятельно\" удалить объект "
"модели (например, использовать цикл по ``QuerySet`` и вызывать метод ``delete"
"()`` для каждого объекта) не используя метод ``delete()`` ``QuerySet``."

# 0ede23c152e542dd988752b6af812fed
#: ../../topics/db/queries.txt:809
msgid ""
"When Django deletes an object, by default it emulates the behavior of the "
"SQL constraint ``ON DELETE CASCADE`` -- in other words, any objects which "
"had foreign keys pointing at the object to be deleted will be deleted along "
"with it. For example::"
msgstr ""
"При удалении Django повторяет поведение SQL выражения ``ON DELETE CASCADE`` "
"-- другими словами, каждый объект, имеющий связь(``ForeignKey``) с удаляемым "
"объектом, будет так же удален. Например::"

# f67a2d004f8044ad821ce0afbcb87b44
#: ../../topics/db/queries.txt:823
msgid ""
"Note that ``delete()`` is the only ``QuerySet`` method that is not exposed "
"on a ``Manager`` itself. This is a safety mechanism to prevent you from "
"accidentally requesting ``Entry.objects.delete()``, and deleting *all* the "
"entries. If you *do* want to delete all the objects, then you have to "
"explicitly request a complete query set::"
msgstr ""
"Метод ``delete()`` содержится только в ``QuerySet`` и не существует в "
"``Manager``. Это сделано, что бы вы случайно не выполнили ``Entry.objects."
"delete()``, и не удалили *все* записи. Если вы *на самом деле* хотите "
"удалить все объекты, сначала явно получите ``QuerySet`` содержащий все "
"записи::"

# ae2a313325c54157b06781adbd7f8ac1
#: ../../topics/db/queries.txt:834
msgid "Copying model instances"
msgstr "Копирование объекта модели"

# 81c2d5d79d1d41c48414728113e1a885
#: ../../topics/db/queries.txt:836
msgid ""
"Although there is no built-in method for copying model instances, it is "
"possible to easily create new instance with all fields' values copied. In "
"the simplest case, you can just set ``pk`` to ``None``. Using our blog "
"example::"
msgstr ""
"Хоть модель и не содержит встроенного метода для копирования объекта модели, "
"очень просто создать новый экземпляр с копией всех полей другого объекта. "
"Самый простой вариант -- установите ``pk`` в ``None``. Используя модели из "
"примеров выше::"

# 4cf698eb363649559b38f6aebd891382
#: ../../topics/db/queries.txt:846
msgid ""
"Things get more complicated if you use inheritance. Consider a subclass of "
"``Blog``::"
msgstr ""
"Все немного сложнее, если вы используете наследование. Рассмотрим подкласс "
"``Blog``::"

# 4aafc8d17e2a41669e1bab2715b2bb84
#: ../../topics/db/queries.txt:855
msgid ""
"Due to how inheritance works, you have to set both ``pk`` and ``id`` to "
"None::"
msgstr ""
"Учитывая как работает наследование, необходимо установить и ``pk`` и ``id`` "
"в None::"

# fa510ea6d64c461a85892099ce76d86f
#: ../../topics/db/queries.txt:861
msgid ""
"This process does not copy related objects. If you want to copy relations, "
"you have to write a little bit more code. In our example, ``Entry`` has a "
"many to many field to ``Author``::"
msgstr ""
"Связанные объекты не копируются. Если вы хотите скопировать связанные "
"объекты, нужно написать немного больше кода. В нашем примере, ``Entry`` "
"содержит связь много-ко-многим к модели ``Author``::"

# 4e99683ce0e947be9167c79edb058c5f
#: ../../topics/db/queries.txt:874
msgid "Updating multiple objects at once"
msgstr "Изменение нескольких объектов"

# d3d4c95936a4497eabd03a6652c10613
#: ../../topics/db/queries.txt:876
msgid ""
"Sometimes you want to set a field to a particular value for all the objects "
"in a ``QuerySet``. You can do this with the ``update()`` method. For "
"example::"
msgstr ""
"Если вам понадобиться установить значение поля для всех объектов в "
"``QuerySet``, используйте метод ``update()``. Например::"

# bf7b6e6c7753494291b9891c9dc5b89b
#: ../../topics/db/queries.txt:882
msgid ""
"You can only set non-relation fields and ``ForeignKey`` fields using this "
"method. To update a non-relation field, provide the new value as a constant. "
"To update ``ForeignKey`` fields, set the new value to be the new model "
"instance you want to point to. For example::"
msgstr ""
"Вы можете изменить только обычные поля или ``ForeignKey`` используя этот "
"метод. Для обычным полей просто определите новое значение как константу. Что "
"бы обновить ``ForeignKey``, укажите объект связанной модели. Например::"

# 43a9217ba7a542afb5e96c6444f638d7
#: ../../topics/db/queries.txt:892
msgid ""
"The ``update()`` method is applied instantly and returns the number of rows "
"affected by the query. The only restriction on the ``QuerySet`` that is "
"updated is that it can only access one database table, the model's main "
"table. You can filter based on related fields, but you can only update "
"columns in the model's main table. Example::"
msgstr ""
"Метод ``update()`` применяется мгновенно и возвращает количество измененных "
"запросом объектов. Единственное ограничение для изменяемого ``QuerySet`` -- "
"он может изменять только главную таблицу модели. Вы можете использовать "
"фильтры по связанным полям, но вы можете изменять поля только таблицы "
"изменяемой модели. Например::"

# c32824823bdb4d788282ff418af903b7
#: ../../topics/db/queries.txt:903
msgid ""
"Be aware that the ``update()`` method is converted directly to an SQL "
"statement. It is a bulk operation for direct updates. It doesn't run any "
"``save()`` methods on your models, or emit the ``pre_save`` or ``post_save`` "
"signals (which are a consequence of calling ``save()``). If you want to save "
"every item in a ``QuerySet`` and make sure that the ``save()`` method is "
"called on each instance, you don't need any special function to handle that. "
"Just loop over them and call ``save()``::"
msgstr ""
"Учтите, что метод ``update()`` использует непосредственно SQL запрос. Это "
"операция для массового изменения. Метод ``save()`` модели не будет вызван, "
"сигналы ``pre_save`` или ``post_save`` не будут вызваны (которые являются "
"следствием вызова ``save()``). Если вы хотите сохранить каждый объект в "
"``QuerySet`` и удостовериться что метод ``save()`` вызван для каждого "
"объекта, вы не должны использовать какой-либо специальный метод. Просто "
"используйте цикл и вызовите метод ``save()``::"

# 6ec6bee63e7348d1aeb7ce9230d36876
#: ../../topics/db/queries.txt:914
msgid ""
"Calls to update can also use :ref:`F() objects <query-expressions>` to "
"update one field based on the value of another field in the model. This is "
"especially useful for incrementing counters based upon their current value. "
"For example, to increment the pingback count for every entry in the blog::"
msgstr ""
"Метод ``update()`` может использовать :ref:`объект F() <query-expressions>` "
"для обновления одного поля значением другого поля модели. Это особенно "
"полезно для изменения счетчика. Например, например увеличить значение "
"``n_pingbacks`` на один для каждой записи::"

# 512e4e1efe294d0d9da9579148de042d
#: ../../topics/db/queries.txt:921
msgid ""
"However, unlike ``F()`` objects in filter and exclude clauses, you can't "
"introduce joins when you use ``F()`` objects in an update -- you can only "
"reference fields local to the model being updated. If you attempt to "
"introduce a join with an ``F()`` object, a ``FieldError`` will be raised::"
msgstr ""
"Однако, в отличии от использования объектов ``F()`` в методах ``filter()`` и "
"``exclude()``, вы не можете использовать связанные поля при обновлении. Если "
"вы будете использовать связанное поле в объекте ``F()``, буде вызвано "
"исключение ``FieldError``::"

# 1181022be17a492db4e34ced0747fcc4
#: ../../topics/db/queries.txt:932
msgid "Related objects"
msgstr "Связанные объекты"

# 12ca6be79571436c817ebce5e7d6f5f8
#: ../../topics/db/queries.txt:934
msgid ""
"When you define a relationship in a model (i.e., a ``ForeignKey``, "
"``OneToOneField``, or ``ManyToManyField``), instances of that model will "
"have a convenient API to access the related object(s)."
msgstr ""
"Используя связанные объекты в модели (например, ``ForeignKey``, "
"``OneToOneField`` или ``ManyToManyField``), в объект модели будет добавлен "
"API для работы со связанными объектами."

# 76a00e3eabcb497b9cdaf9000060755e
#: ../../topics/db/queries.txt:938
msgid ""
"Using the models at the top of this page, for example, an ``Entry`` object "
"``e`` can get its associated ``Blog`` object by accessing the ``blog`` "
"attribute: ``e.blog``."
msgstr ""
"Используя модели из примеров выше, например, объект ``e`` модели ``Entry`` "
"может получить связанные объекты ``Blog`` используя атрибут ``blog``: ``e."
"blog``."

# a6ec2c148731455cb7b7381415382104
#: ../../topics/db/queries.txt:942
msgid ""
"(Behind the scenes, this functionality is implemented by Python "
"descriptors_. This shouldn't really matter to you, but we point it out here "
"for the curious.)"
msgstr ""
"(Это все работает благодаря  `дескрипторам Python <http://users.rcn.com/"
"python/download/Descriptor.htm>`_. Это совсем не важно и упоминается для "
"любознательных.)"

# 2432ded29ac746fc9cc2b23e86703616
#: ../../topics/db/queries.txt:945
msgid ""
"Django also creates API accessors for the \"other\" side of the relationship "
"-- the link from the related model to the model that defines the "
"relationship. For example, a ``Blog`` object ``b`` has access to a list of "
"all related ``Entry`` objects via the ``entry_set`` attribute: ``b.entry_set."
"all()``."
msgstr ""
"Django так же предоставляет доступ к связанным объектам с \"другой\" "
"стороны  -- ссылка с связанного объекта на объект, который определяет связь. "
"Например, объект ``b`` модели ``Blog`` имеет доступ ко всем связанным "
"объектам ``Entry`` через атрибут ``entry_set``: ``b.entry_set.all()``."

# f9c620084c2340699062d5cd7e99b510
#: ../../topics/db/queries.txt:950
msgid ""
"All examples in this section use the sample ``Blog``, ``Author`` and "
"``Entry`` models defined at the top of this page."
msgstr ""
"Все примеры в этом разделе используют вышеупомянутые модели ``Blog``, "
"``Author`` и ``Entry``."

# ddba1e5f35134b1d9b42c3f6e3e05951
#: ../../topics/db/queries.txt:956
msgid "One-to-many relationships"
msgstr "Связь один-к-одному"

# 2a588632bef445558e59b9e4f6e921d4
#: ../../topics/db/queries.txt:959
msgid "Forward"
msgstr "Прямая"

# ca55dce52f474004a985e923621508ba
#: ../../topics/db/queries.txt:961
msgid ""
"If a model has a ``ForeignKey``, instances of that model will have access to "
"the related (foreign) object via a simple attribute of the model."
msgstr ""
"Если модель содержит ``ForeignKey``, объект этой модели может получить "
"связанный объект через атрибут модели."

# 046b04d00de8478c877833241743ad96
#: ../../topics/db/queries.txt:969
msgid ""
"You can get and set via a foreign-key attribute. As you may expect, changes "
"to the foreign key aren't saved to the database until you call ``save()``. "
"Example::"
msgstr ""
"Вы можете получить и изменить его через атрибут внешнего ключа. Как вы "
"можете предполагать, изменения не будут сохранены в базу данных пока не "
"будет вызван метод ``save()``. Например::"

# a7dfa9b31d80453ea55661fb837380e5
#: ../../topics/db/queries.txt:977
msgid ""
"If a ``ForeignKey`` field has ``null=True`` set (i.e., it allows ``NULL`` "
"values), you can assign ``None`` to it. Example::"
msgstr ""
"Если поле ``ForeignKey`` содержит ``null=True`` (то есть разрешено значение "
"``NULL``), вы можете указать ``None`` для этого поля. Например::"

# aaecabd4a9994a2aabee92706f81442a
#: ../../topics/db/queries.txt:984
msgid ""
"Forward access to one-to-many relationships is cached the first time the "
"related object is accessed. Subsequent accesses to the foreign key on the "
"same object instance are cached. Example::"
msgstr ""
"Прямой доступ для связи один-ко-многим кеширует полученное значение при "
"первом обращении. Последующие обращения к внешнему ключу этого же объекта "
"будут использовать кешированое значение. Например::"

# b0c2840f6ebc48c9821ae1199ac04cb9
#: ../../topics/db/queries.txt:992
msgid ""
"Note that the ``select_related()`` ``QuerySet`` method recursively "
"prepopulates the cache of all one-to-many relationships ahead of time. "
"Example::"
msgstr ""
"Запомните, что вызов метода ``select_related()`` ``QuerySet`` рекурсивно "
"заполняет кеш значениями для всех связей один-ко-многим. Например::"

# 2ac51945c1724da08d97c46265d95795
#: ../../topics/db/queries.txt:1002
msgid "Following relationships \"backward\""
msgstr "\"Обратная\" связь"

# 6fa632cc418e43fe9e9403e72960ca1c
#: ../../topics/db/queries.txt:1004
msgid ""
"If a model has a ``ForeignKey``, instances of the foreign-key model will "
"have access to a ``Manager`` that returns all instances of the first model. "
"By default, this ``Manager`` is named ``FOO_set``, where ``FOO`` is the "
"source model name, lowercased. This ``Manager`` returns ``QuerySets``, which "
"can be filtered and manipulated as described in the \"Retrieving objects\" "
"section above."
msgstr ""
"Если модель содержит ``ForeignKey``, экземпляры модели указанной в "
"``ForeignKey`` содержат ``Manager``, который вернет все связанные объекты "
"первой модели. По-умолчанию, этот ``Manager`` называется ``FOO_set``, где "
"``FOO`` названием основной модели в нижнем регистре. Этот ``Manager`` "
"возвращает ``QuerySets``, который может быть отфильтрован и изменен как было "
"описано в разделе \"Получение объектов\"."

# 2b06ad760bd24dd485cae060c6fb842d
#: ../../topics/db/queries.txt:1020
msgid ""
"You can override the ``FOO_set`` name by setting the ``related_name`` "
"parameter in the ``ForeignKey()`` definition. For example, if the ``Entry`` "
"model was altered to ``blog = ForeignKey(Blog, related_name='entries')``, "
"the above example code would look like this::"
msgstr ""
"Вы можете переопределить название ``FOO_set`` установив параметр "
"``related_name`` при определении ``ForeignKey()``. Например, если бы модель "
"``Entry`` содержала ``blog = ForeignKey(Blog, related_name='entries')``, "
"пример выше выглядел бы как::"

# 9961ef20f97a4df5b272a1165f4f62b2
#: ../../topics/db/queries.txt:1032
msgid ""
"You cannot access a reverse ``ForeignKey`` ``Manager`` from the class; it "
"must be accessed from an instance::"
msgstr ""
"Вы не можете обращаться к \"обратному\" менеджеру через класс модели; вы "
"должны использовать экземпляр модели::"

# 961836648e6a477e824770cf337525fd
#: ../../topics/db/queries.txt:1040
msgid ""
"In addition to the ``QuerySet`` methods defined in \"Retrieving objects\" "
"above, the ``ForeignKey`` ``Manager`` has additional methods used to handle "
"the set of related objects. A synopsis of each is below, and complete "
"details can be found in the :doc:`related objects reference </ref/models/"
"relations>`."
msgstr ""
"В дополнение к методам ``QuerySet`` описанным в разделе \"Получение объектов"
"\", \"обратный\" менеджер  ``ForeignKey`` содержит дополнительные методы для "
"работы со связанными объектами. Краткий список находится ниже, полное "
"описание смотрите в разделе о :doc:`связанных объектах </ref/models/"
"relations>`."

# 216f9640763048febb0bd4facc1c8c5e
#: ../../topics/db/queries.txt:1046
msgid "Adds the specified model objects to the related object set."
msgstr "Добавляет указанный объект к связанным объектам."

# db0515d208244ec39a0a80028f6a47c1
#: ../../topics/db/queries.txt:1049
msgid ""
"Creates a new object, saves it and puts it in the related object set. "
"Returns the newly created object."
msgstr ""
"Создает новый объект, сохраняет его и добавляет к связанным объектам. "
"Возвращает созданный объект."

# deda08b2ca3244ea8106ec0558c7d55c
#: ../../topics/db/queries.txt:1053
msgid "Removes the specified model objects from the related object set."
msgstr "Удаляет указанный объект из списка связанных объектов."

# 7389187100f54ca7972ee45ce505af34
#: ../../topics/db/queries.txt:1056
msgid "Removes all objects from the related object set."
msgstr "Удаляет все объекты из списка связанных."

# f3a792203f994426b93f1ff3b68a491e
#: ../../topics/db/queries.txt:1058
msgid ""
"To assign the members of a related set in one fell swoop, just assign to it "
"from any iterable object. The iterable can contain object instances, or just "
"a list of primary key values. For example::"
msgstr ""
"Что бы добавить несколько связанных объектов одним махом, просто установите "
"любой итератор. Итератор должен содержать объекты или просто значения "
"первичных ключей. Например::"

# 1aaed1cd411b456eab1caa3d6692aad1
#: ../../topics/db/queries.txt:1065
msgid ""
"In this example, ``e1`` and ``e2`` can be full Entry instances, or integer "
"primary key values."
msgstr ""
"В этом примере, ``e1`` и ``e2`` могут быть экземплярами ``Entry``, или "
"значениями первичного ключа."

# 9c0557108268448c94282e171e6e3893
#: ../../topics/db/queries.txt:1068
msgid ""
"If the ``clear()`` method is available, any pre-existing objects will be "
"removed from the ``entry_set`` before all objects in the iterable (in this "
"case, a list) are added to the set. If the ``clear()`` method is *not* "
"available, all objects in the iterable will be added without removing any "
"existing elements."
msgstr ""
"Если доступен метод ``clear()``, все связанные объекты будут удаленны из "
"``entry_set`` перед тем, как все объекты из итератора(в примере это список) "
"будут добавлены в список связанных объектов. Если метод ``clear()`` *не* "
"доступен, все объекты из итератора будут добавлены без удаления существующих "
"объектов."

# 592feacc21004d15b4cfd91271940422
#: ../../topics/db/queries.txt:1074
msgid ""
"Each \"reverse\" operation described in this section has an immediate effect "
"on the database. Every addition, creation and deletion is immediately and "
"automatically saved to the database."
msgstr ""
"Все вышеупомянутые методы сохраняют результат в базу. Каждое добавление, "
"создание или удаление сразу и автоматически выполняет соответствующий запрос "
"в базу данных."

# 6be458cd37dc4e59ae7498f5729fec3d
#: ../../topics/db/queries.txt:1081
msgid "Many-to-many relationships"
msgstr "Связь много-ко-многим"

# 9a401310d540429bb0db647a8a06ab3b
#: ../../topics/db/queries.txt:1083
msgid ""
"Both ends of a many-to-many relationship get automatic API access to the "
"other end. The API works just as a \"backward\" one-to-many relationship, "
"above."
msgstr ""
"Обе \"стороны\"  связи многое-ко-многим автоматически получает API для "
"работы со связанными объектами. Этот API работает так же, как и \"обратный\" "
"менеджер для связи один-ко-многим описанный выше."

# f00cec0ad3044822ae04b25f8996a9b0
#: ../../topics/db/queries.txt:1086
msgid ""
"The only difference is in the attribute naming: The model that defines the "
"``ManyToManyField`` uses the attribute name of that field itself, whereas "
"the \"reverse\" model uses the lowercased model name of the original model, "
"plus ``'_set'`` (just like reverse one-to-many relationships)."
msgstr ""
"Единственное отличие: Модель содержащая ``ManyToManyField`` использует имя "
"атрибута этого поля, в то время, как \"обратная\" модель использует название "
"состоящее из названия модели в нижнем регистре плюс ``'_set'`` (так же как и "
"для связи один-ко-многим)."

# 5d56c76b4efd46ef8b082d43eba6ed1a
#: ../../topics/db/queries.txt:1091
msgid "An example makes this easier to understand::"
msgstr "Пример все разъяснит::"

# ed67193473614bfca7a6d6917f7118e5
#: ../../topics/db/queries.txt:1101
msgid ""
"Like ``ForeignKey``, ``ManyToManyField`` can specify ``related_name``. In "
"the above example, if the ``ManyToManyField`` in ``Entry`` had specified "
"``related_name='entries'``, then each ``Author`` instance would have an "
"``entries`` attribute instead of ``entry_set``."
msgstr ""
"Так же как и ``ForeignKey``, ``ManyToManyField`` позволяет определить "
"``related_name``. В примере выше, если поле  ``ManyToManyField`` модели "
"``Entry`` содержит ``related_name='entries'``, тогда каждый объект модели "
"``Author`` будет с атрибутом ``entries`` вместо ``entry_set``."

# 58dc0610d67d4894aafc637cfe84e268
#: ../../topics/db/queries.txt:1107
msgid "One-to-one relationships"
msgstr "Связь один-к-одному"

# 2518ca1f41df40339d225f06c55de122
#: ../../topics/db/queries.txt:1109
msgid ""
"One-to-one relationships are very similar to many-to-one relationships. If "
"you define a :class:`~django.db.models.OneToOneField` on your model, "
"instances of that model will have access to the related object via a simple "
"attribute of the model."
msgstr ""
"Связь один-к-одному похожа на связь многое-к-одному. При добавлении :class:"
"`~django.db.models.OneToOneField` в модель, объект этой модели будет "
"содержать ссылку на связанный объект через атрибут модели."

# 5bac17ba464a44eb8ef73610c30e948f
#: ../../topics/db/queries.txt:1114
msgid "For example::"
msgstr "Например::"

# b535b1d1d0e74fa8a83cef302cac0422
#: ../../topics/db/queries.txt:1123
msgid ""
"The difference comes in \"reverse\" queries. The related model in a one-to-"
"one relationship also has access to a :class:`~django.db.models.Manager` "
"object, but that :class:`~django.db.models.Manager` represents a single "
"object, rather than a collection of objects::"
msgstr ""
"Разница в обратной связи. Связанная модель так же имеет доступ к объекту :"
"class:`~django.db.models.Manager`, но :class:`~django.db.models.Manager` "
"представляет один объект, а не множество объектов::"

# b6b0e183769c4289a508aa9db77ac531
#: ../../topics/db/queries.txt:1131
msgid ""
"If no object has been assigned to this relationship, Django will raise a "
"``DoesNotExist`` exception."
msgstr ""
"Если ни один объект не добавлен в связь, Django вызовет исключение "
"``DoesNotExist``."

# 117c826dc5e149499692bc3f3b44c688
#: ../../topics/db/queries.txt:1134
msgid ""
"Instances can be assigned to the reverse relationship in the same way as you "
"would assign the forward relationship::"
msgstr ""
"Объект может быть назначен через обратную связь так же как и через прямую::"

# 2c5d938af4784825997033f0a4011056
#: ../../topics/db/queries.txt:1140
msgid "How are the backward relationships possible?"
msgstr "Как работает обратная связь?"

# d86cc532225542b2be233f21db22980d
#: ../../topics/db/queries.txt:1142
msgid ""
"Other object-relational mappers require you to define relationships on both "
"sides. The Django developers believe this is a violation of the DRY (Don't "
"Repeat Yourself) principle, so Django only requires you to define the "
"relationship on one end."
msgstr ""
"Другие ORM требуют определять связь с обоих сторон. Разработчики Django "
"считают, что это противоречит принципу DRY (Don't Repeat Yourself - не "
"повторяй себя), по этому Django требует определить связь только для одной "
"модели."

# 7928531e4fa4471397b2b353b22d6361
#: ../../topics/db/queries.txt:1147
msgid ""
"But how is this possible, given that a model class doesn't know which other "
"model classes are related to it until those other model classes are loaded?"
msgstr ""
"Но как это возможно, учитывая, что модель не знает, какие другие модели "
"связаны с ним, пока классы этих моделей не будут загружены?"

# 3cf18a59ead34c549fc971e29c91ee8a
#: ../../topics/db/queries.txt:1150
msgid ""
"The answer lies in the :setting:`INSTALLED_APPS` setting. The first time any "
"model is loaded, Django iterates over every model in :setting:"
"`INSTALLED_APPS` and creates the backward relationships in memory as needed. "
"Essentially, one of the functions of :setting:`INSTALLED_APPS` is to tell "
"Django the entire model domain."
msgstr ""
"Суть ответа в настройке :setting:`INSTALLED_APPS`. При загрузке любой модели "
"в первый раз, Django перебирает все модели из приложений в :setting:"
"`INSTALLED_APPS` и создает обратные связи для каждой модели.По сути, это "
"одна из функций :setting:`INSTALLED_APPS` -- определить все используемые "
"модели для Django."

# 0895351da3b84730bedbb16e1bdeaecd
#: ../../topics/db/queries.txt:1156
msgid "Queries over related objects"
msgstr "Запросы со связанными объектами"

# c6ef9029545d436584d6bcda98e006d5
#: ../../topics/db/queries.txt:1158
msgid ""
"Queries involving related objects follow the same rules as queries involving "
"normal value fields. When specifying the value for a query to match, you may "
"use either an object instance itself, or the primary key value for the "
"object."
msgstr ""
"Запросы со связанными объектами используют те же правила, что и с обычными "
"значениями. Вы можете использовать объект или значение первичного ключа."

# 0f6f6b8d11404210b59d152cff37f99c
#: ../../topics/db/queries.txt:1162
msgid ""
"For example, if you have a Blog object ``b`` with ``id=5``, the following "
"three queries would be identical::"
msgstr ""
"Например, если у вас объект ``Blog`` ``b`` с ``id=5``, эти три запроса будут "
"идентичны::"

# ecf21c78d1ee407092fd93800876f849
#: ../../topics/db/queries.txt:1170
msgid "Falling back to raw SQL"
msgstr "Использование чистого SQL"

# eea72f40671a41d2bf2c11ec33d9ba86
#: ../../topics/db/queries.txt:1172
msgid ""
"If you find yourself needing to write an SQL query that is too complex for "
"Django's database-mapper to handle, you can fall back on writing SQL by "
"hand. Django has a couple of options for writing raw SQL queries; see :doc:`/"
"topics/db/sql`."
msgstr ""
"Если вам нужно создать SQL запрос, который слишком сложен для API Django, вы "
"можете использовать чистый SQL. Django имеет несколько возможностей "
"использовать SQL запросы; смотрите :doc:`/topics/db/sql`."

# 5c5bcff1298f471abee7b10697f6d16a
#: ../../topics/db/queries.txt:1177
msgid ""
"Finally, it's important to note that the Django database layer is merely an "
"interface to your database. You can access your database via other tools, "
"programming languages or database frameworks; there's nothing Django-"
"specific about your database."
msgstr ""
"Наконец, важно отметить, что API Django для работы с базой данных является "
"лишь интерфейсом к базе данных. Вы можете получить доступ к базе данных "
"через другие инструменты, языки программирования и фреймверки; Django не "
"делает ничего специфического с вашей базой данных."
