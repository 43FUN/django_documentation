# Russian translations for Django package.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
# Automatically generated <>, 2012, 2013.
#
msgid ""
msgstr ""
"Project-Id-Version: Django 1.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2013-04-23 16:09\n"
"PO-Revision-Date: 2013-05-13 11:08+0300\n"
"Last-Translator: Dmitriy Kostochko <alerion.um@gmail.com>\n"
"Language-Team: none\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"

# 44a89a46f3e148ee966538fa70492490
#: ../../topics/http/urls.txt:3
msgid "URL dispatcher"
msgstr "Менеджер URL-ов"

# 17df4924b86442ad89dcf7d0419847af
#: ../../topics/http/urls.txt:5
msgid "A clean, elegant URL scheme is an important detail in a high-quality Web application. Django lets you design URLs however you want, with no framework limitations."
msgstr "Чистая, элегантная схема URL-ов -- это важная часть качественного приложения. Django позволяет проектировать URL-адреса как вы пожелаете, без ограничений \"фреймверка\"."

# 57872ae9e3b04448989f58fbba7a0059
#: ../../topics/http/urls.txt:9
msgid "There's no ``.php`` or ``.cgi`` required, and certainly none of that ``0,2097,1-1-1928,00`` nonsense."
msgstr "В  URL-ах не нужны ни ``.php``, ни ``.cgi``, ни всякая ерунда вроде ``0,2097,1-1-1928,00``."

# ff73ff2f19c0487d9a216ff2537ef310
#: ../../topics/http/urls.txt:12
msgid "See `Cool URIs don't change`_, by World Wide Web creator Tim Berners-Lee, for excellent arguments on why URLs should be clean and usable."
msgstr "Читайте `Cool URIs don't change <http://www.w3.org/Provider/Style/URI>`_, создателя World Wide Web, Тима Бернерса-Ли, что бы узнать почему URL-ы должны быть красивыми и практичными."

# 3fb1d863ce6d42f89ebbe0b643b704e0
#: ../../topics/http/urls.txt:18
msgid "Overview"
msgstr "Обзор"

# 94510b9fca3b475b8bb54eee7b08717d
#: ../../topics/http/urls.txt:20
msgid "To design URLs for an app, you create a Python module informally called a **URLconf** (URL configuration). This module is pure Python code and is a simple mapping between URL patterns (simple regular expressions) to Python functions (your views)."
msgstr "Для определения URL-ов приложения, создайте модуль Python, неофициально названный **URLconf** (конфигурация URL-ов). Этот модуль содержит код Python, который отображает URL-шаблоны (регулярные выражения) и связанные функции Python (ваши представления)."

# 2ca36790b64b4d27a3fbcfbc53abf138
#: ../../topics/http/urls.txt:25
msgid "This mapping can be as short or as long as needed. It can reference other mappings. And, because it's pure Python code, it can be constructed dynamically."
msgstr "Эта конфигурация может быть короткой или длинной настолько, насколько это нужно. Она может ссылаться на другие конфигурации. И, так как это код Python, может создаваться динамически."

# 824220d3e1ac4e3d82fcfde6df717952
#: ../../topics/http/urls.txt:37
msgid "How Django processes a request"
msgstr "Как Django обрабатывает запрос"

# 489d8bd0d15844c49998431831e97e90
#: ../../topics/http/urls.txt:39
msgid "When a user requests a page from your Django-powered site, this is the algorithm the system follows to determine which Python code to execute:"
msgstr "При запросе к странице вашего Django-сайта, используется такой алгоритм для определения какой код выполнить:"

# 8ced9086b21a4f25864ed385571abe9c
#: ../../topics/http/urls.txt:42
msgid "Django determines the root URLconf module to use. Ordinarily, this is the value of the :setting:`ROOT_URLCONF` setting, but if the incoming ``HttpRequest`` object has an attribute called ``urlconf`` (set by middleware :ref:`request processing <request-middleware>`), its value will be used in place of the :setting:`ROOT_URLCONF` setting."
msgstr "Django определяет какой корневой модуль URLconf использовать. Обычно, это значение настройки :setting:`ROOT_URLCONF`, но, если объект запроса ``HttpRequest`` содержит атрибут ``urlconf`` (установленный :ref:`request middleware <request-middleware>`), его значение будет использоваться вместо :setting:`ROOT_URLCONF`."

# 048d4ea680974eb0a9ccc9e7b1791e26
#: ../../topics/http/urls.txt:48
msgid "Django loads that Python module and looks for the variable ``urlpatterns``. This should be a Python list, in the format returned by the function :func:`django.conf.urls.patterns`."
msgstr "Django загружает модуль конфигурации URL и ищет переменную ``urlpatterns``. Это должен быть список Python, в формате возвращаемом функцией :func:`django.conf.urls.patterns`."

# ad17d75eba8f4abeb8d931e0dcf08f86
#: ../../topics/http/urls.txt:52
msgid "Django runs through each URL pattern, in order, and stops at the first one that matches the requested URL."
msgstr "Django перебирает каждый URL-шаблон по порядку, и останавливается при первом совпадении с запрошенным URL-ом."

# 504bddbb80be449a86e67df32d2510a3
#: ../../topics/http/urls.txt:55
msgid "Once one of the regexes matches, Django imports and calls the given view, which is a simple Python function (or a :doc:`class based view </topics/class-based-views/index>`). The view gets passed an :class:`~django.http.HttpRequest` as its first argument and any values captured in the regex as remaining arguments."
msgstr "Если одно из регулярных выражений соответствует URL-у, Django импортирует и вызывает соответствующее представление, которое является просто функцией Python(или :doc:`представление-класс </topics/class-based-views/index>`). При вызове первым аргументом передается :class:`~django.http.HttpRequest` а так же все значения найденные регулярным выражением."

# 49c3d738987d4b73b155913fefcacd4e
#: ../../topics/http/urls.txt:61
msgid "If no regex matches, or if an exception is raised during any point in this process, Django invokes an appropriate error-handling view. See `Error handling`_ below."
msgstr "Если ни одно регулярное выражение не соответствует, или возникла ошибка на любом из этапов, Django вызывает соответствующий обработчик ошибок. Смотрите `Error handling`_ ниже."

# adf7e75d4544433d812cbce0425fd3c9
#: ../../topics/http/urls.txt:66
#: ../../topics/http/urls.txt:746
msgid "Example"
msgstr "Например"

# 115122f3828343838f934ed3546d20a3
#: ../../topics/http/urls.txt:68
msgid "Here's a sample URLconf::"
msgstr "Вот пример простого URLconf::"

# de11530a822643d186b5167894f4a50a
#: ../../topics/http/urls.txt:79
msgid "Notes:"
msgstr "Заметим:"

# 306dd9b944c04e6292ea7bb6ef4931ca
#: ../../topics/http/urls.txt:81
msgid "To capture a value from the URL, just put parenthesis around it."
msgstr "Для получения совпадающего значения из URL, просто добавьте скобки вокруг него."

# 99f6e002f1b8417d82f05dffb1ba7db7
#: ../../topics/http/urls.txt:83
msgid "There's no need to add a leading slash, because every URL has that. For example, it's ``^articles``, not ``^/articles``."
msgstr "Не нужно добавлять слэш в начале, потому что каждый URL содержит его. Например, используйте ``^articles``, вместо ``^/articles``."

# 07d2957e806b48c1a1795e26d375d8ba
#: ../../topics/http/urls.txt:86
msgid "The ``'r'`` in front of each regular expression string is optional but recommended. It tells Python that a string is \"raw\" -- that nothing in the string should be escaped. See `Dive Into Python's explanation`_."
msgstr "Символ ``'r'`` перед каждым регулярным выражением не обязателен, но рекомендуется. Он указывает Python что строка \"сырая(raw)\" и ничего в строке не должно быть экранировано. Смотрите `Dive Into Python's explanation <http://www.diveintopython.net/regular_expressions/street_addresses.html#re.matching.2.3>`_."

# 5570142fb42b42858f44f59c68288e6f
#: ../../topics/http/urls.txt:90
msgid "Example requests:"
msgstr "Примеры запросов:"

# 9de013fa45cf458abb78de966637712e
#: ../../topics/http/urls.txt:92
msgid "A request to ``/articles/2005/03/`` would match the third entry in the list. Django would call the function ``news.views.month_archive(request, '2005', '03')``."
msgstr "Запрос к``/articles/2005/03/`` будет обработан третьим элементом списка. Django вызовет функцию ``news.views.month_archive(request, '2005', '03')``."

# 4129a80f378a4b1c940e46888cdeda2a
#: ../../topics/http/urls.txt:96
msgid "``/articles/2005/3/`` would not match any URL patterns, because the third entry in the list requires two digits for the month."
msgstr "``/articles/2005/3/`` не соответствует ни одному URL-шаблону, потому что третья запись требует две цифры в номере месяца."

# 0ddbce6f554b4546934dd09211163e45
#: ../../topics/http/urls.txt:99
msgid "``/articles/2003/`` would match the first pattern in the list, not the second one, because the patterns are tested in order, and the first one is the first test to pass. Feel free to exploit the ordering to insert special cases like this."
msgstr "``/articles/2003/`` соответствует первому выражению, не второму, потому что шаблоны проверяются по порядку. Не стесняйтесь использовать порядок для обработки различных ситуация, таких как эта."

# 14d3603798ba4393a3420959eb39ffb6
#: ../../topics/http/urls.txt:104
msgid "``/articles/2003`` would not match any of these patterns, because each pattern requires that the URL end with a slash."
msgstr "``/articles/2003`` не соответствует ни одному регулярному выражению, потому что каждое ожидает, что URL оканчивается на слэш."

# bc2dd4603a304148814f4cc059c38519
#: ../../topics/http/urls.txt:107
msgid "``/articles/2003/03/03/`` would match the final pattern. Django would call the function ``news.views.article_detail(request, '2003', '03', '03')``."
msgstr "``/articles/2003/03/03/`` соответствует последнему выражению. Django вызовет функцию ``news.views.article_detail(request, '2003', '03', '03')``."

# e1197d6592724a6c92ce4a74aa6b6153
#: ../../topics/http/urls.txt:113
msgid "Named groups"
msgstr "Именованные группы"

# c7bc17c011da45cea8f9f6bf1107461d
#: ../../topics/http/urls.txt:115
msgid "The above example used simple, *non-named* regular-expression groups (via parenthesis) to capture bits of the URL and pass them as *positional* arguments to a view. In more advanced usage, it's possible to use *named* regular-expression groups to capture URL bits and pass them as *keyword* arguments to a view."
msgstr "Пример выше использует простые, *не именованные* группы совпадений в регулярных выражениях (то, что в скобках) что бы получить значения из URL и передать в представление как *позиционные* аргументы. Но вы можете использовать *имена* для групп и значения будут передаваться как *именованные* аргументы."

# ada1f57789b24c208dddb5045df3aa82
#: ../../topics/http/urls.txt:121
msgid "In Python regular expressions, the syntax for named regular-expression groups is ``(?P<name>pattern)``, where ``name`` is the name of the group and ``pattern`` is some pattern to match."
msgstr "Для регулярных выражений в Python синтаксис для именованных совпадений выглядит таким образом ``(?P<name>pattern)``, где ``name`` это название группы, а ``pattern`` -- шаблон."

# f2beb7363a8d43da8d4fc1d6b0ba2e2b
#: ../../topics/http/urls.txt:125
msgid "Here's the above example URLconf, rewritten to use named groups::"
msgstr "Вот пример конфигурации URL, переписанный с использованием именованных групп::"

# 71c17e897e514ec5847da40f9f798ebb
#: ../../topics/http/urls.txt:134
msgid "This accomplishes exactly the same thing as the previous example, with one subtle difference: The captured values are passed to view functions as keyword arguments rather than positional arguments. For example:"
msgstr "Он выполняет то же самое, что и предыдущий пример, с одним небольшим отличием: полученные значения передаются в представление как именованные аргументы, а не позиционные. Например:"

# 96355635375e4354873544e2fc43cb39
#: ../../topics/http/urls.txt:138
msgid "A request to ``/articles/2005/03/`` would call the function ``news.views.month_archive(request, year='2005', month='03')``, instead of ``news.views.month_archive(request, '2005', '03')``."
msgstr "Запрос к ``/articles/2005/03/`` вызовет функцию ``news.views.month_archive(request, year='2005', month='03')``, вместо ``news.views.month_archive(request, '2005', '03')``."

# 153391f6b3f141d18687cfa27e85c213
#: ../../topics/http/urls.txt:142
msgid "A request to ``/articles/2003/03/03/`` would call the function ``news.views.article_detail(request, year='2003', month='03', day='03')``."
msgstr "Запрос к ``/articles/2003/03/03/`` вызовет ``news.views.article_detail(request, year='2003', month='03', day='03')``."

# 0e081d65d6e349748164e3f0ea5a040c
#: ../../topics/http/urls.txt:145
msgid "In practice, this means your URLconfs are slightly more explicit and less prone to argument-order bugs -- and you can reorder the arguments in your views' function definitions. Of course, these benefits come at the cost of brevity; some developers find the named-group syntax ugly and too verbose."
msgstr "На практике это означает, что ваша конфигурация URL более понятна и меньше зависит от ошибки в порядке аргументов, так же вы можете изменять порядок аргументов в представлении. Конечно, эти преимущества достигаются за счет краткости, некоторые разработчики считают именованные группы уродливыми и слишком многословными."

# a914fa737fae4e1483c011878abb3516
#: ../../topics/http/urls.txt:151
msgid "The matching/grouping algorithm"
msgstr "Алгоритм соответствия/группировки"

# 8a614b967feb45f79582619b2d1c423c
#: ../../topics/http/urls.txt:153
msgid "Here's the algorithm the URLconf parser follows, with respect to named groups vs. non-named groups in a regular expression:"
msgstr "Вот алгоритм, которому следует синтаксический анализатор конфигурации URL, для определения использовать значения именованных или не именованных совпадений:"

# 2a0423ff6c60439099242dd7bc298952
#: ../../topics/http/urls.txt:156
msgid "If there are any named arguments, it will use those, ignoring non-named arguments."
msgstr "Если существует именованный аргумент, он будет использован вместо позиционного аргумента."

# 2a0423ff6c60439099242dd7bc298952
#: ../../topics/http/urls.txt:159
msgid "Otherwise, it will pass all non-named arguments as positional arguments."
msgstr "Иначе все неименованные параметры будут переданы как позиционные аргументы."

# 0dd49926e3444fe9adc9ae06cd74e8a9
#: ../../topics/http/urls.txt:161
msgid "In both cases, any extra keyword arguments that have been given as per `Passing extra options to view functions`_ (below) will also be passed to the view."
msgstr "В любом случае дополнительные именованные аргументы будут переданы как именованные. Смотрите `Passing extra options to view functions`_ ниже."

# b871768b0b674192abdff8df2fd80354
#: ../../topics/http/urls.txt:165
msgid "What the URLconf searches against"
msgstr "Что использует URLconf при поиске нужного шаблона URL"

# a106db71a6b54a7e98a06bdae72e30be
#: ../../topics/http/urls.txt:167
msgid "The URLconf searches against the requested URL, as a normal Python string. This does not include GET or POST parameters, or the domain name."
msgstr "URLconf использует запрашиваемый URL как обычную строку Python. Он не учитывает параметры GET, POST и имя домена."

# 127285e2224b41b3b21c38b8e80eb71f
#: ../../topics/http/urls.txt:170
msgid "For example, in a request to ``http://www.example.com/myapp/``, the URLconf will look for ``myapp/``."
msgstr "Например, при запросе к ``http://www.example.com/myapp/``, URLconf возьмет ``myapp/``."

# 64a2c332cc0447838ffe0149bc36d178
#: ../../topics/http/urls.txt:173
msgid "In a request to ``http://www.example.com/myapp/?page=3``, the URLconf will look for ``myapp/``."
msgstr "При запросе к ``http://www.example.com/myapp/?page=3`` -- ``myapp/``."

# c2ae9a9690634379bad9ca6456a1867d
#: ../../topics/http/urls.txt:176
msgid "The URLconf doesn't look at the request method. In other words, all request methods -- ``POST``, ``GET``, ``HEAD``, etc. -- will be routed to the same function for the same URL."
msgstr "URLconf не учитывает тип запроса. Другими словами, все типы запросов -- ``POST``, ``GET``, ``HEAD``, и др. -- будут обработаны одним представлением при одинаковом URL."

# 875af8403096400ba182a69467ec132f
#: ../../topics/http/urls.txt:181
msgid "Notes on capturing text in URLs"
msgstr "Особенности нахождении аргументов в URL"

# 1dca15e4d9c54a28a2a544cd56669c02
#: ../../topics/http/urls.txt:183
msgid "Each captured argument is sent to the view as a plain Python string, regardless of what sort of match the regular expression makes. For example, in this URLconf line::"
msgstr "Каждый найденный аргумент передается в представление как строка, независимо от того, какое \"совпадение\" определено в регулярном выражении. Например, URLconf содержит такую строку::"

# 35e185e6d15c44558b68af0ca7670ccd
#: ../../topics/http/urls.txt:189
msgid "...the ``year`` argument to ``news.views.year_archive()`` will be a string, not an integer, even though the ``\\d{4}`` will only match integer strings."
msgstr "...аргумент ``year`` для ``news.views.year_archive()`` будет строкой, несмотря на ``\\d{4}``."

# 65b67011e98a4fa78dcf095d1a8994d7
#: ../../topics/http/urls.txt:192
msgid "A convenient trick is to specify default parameters for your views' arguments. Here's an example URLconf and view::"
msgstr "Принято указывать значения по-умолчанию для аргументов представления. Пример URLconf и представления::"

# 5e1ede5dd84045ab96ba9cb286a46030
#: ../../topics/http/urls.txt:205
msgid "In the above example, both URL patterns point to the same view -- ``blog.views.page`` -- but the first pattern doesn't capture anything from the URL. If the first pattern matches, the ``page()`` function will use its default argument for ``num``, ``\"1\"``. If the second pattern matches, ``page()`` will use whatever ``num`` value was captured by the regex."
msgstr "В примере выше, оба URL-шаблона указывают на одно представление -- ``blog.views.page`` -- но первый шаблон не принимает аргументы в URL. Если первый шаблон будет выбран, функция ``page()`` будет использовать значение по-умолчанию аргумента ``num`` равное ``\"1\"``. Если будет выбран другой шаблон, ``page()`` будет использовать значение ``num`` из URL, которое найдет регулярное выражение."

# 858c260216d04239ae52bacc18b66925
#: ../../topics/http/urls.txt:212
msgid "Performance"
msgstr "Производительность"

# 1eb58843b8454ee6b0288af55205990e
#: ../../topics/http/urls.txt:214
msgid "Each regular expression in a ``urlpatterns`` is compiled the first time it's accessed. This makes the system blazingly fast."
msgstr "Каждое регулярное выражение в ``urlpatterns`` будет скомпилировано при первом использовании. Это делает систему невероятно быстрой."

# 261666c18648414caed8c8256b30dbf3
#: ../../topics/http/urls.txt:218
msgid "Syntax of the urlpatterns variable"
msgstr "Синтаксис переменной urlpatterns"

# 7751f0c3f99c456cbef140eb60b2d893
#: ../../topics/http/urls.txt:220
msgid "``urlpatterns`` should be a Python list, in the format returned by the function :func:`django.conf.urls.patterns`. Always use ``patterns()`` to create the ``urlpatterns`` variable."
msgstr "``urlpatterns`` должен быть списком Python, в формате, возвращаемом функцией :func:`django.conf.urls.patterns`. Всегда используйте ``patterns()`` для определения переменной ``urlpatterns``."

# aa77f0e182df4239a1eae76d7f84e3c1
#: ../../topics/http/urls.txt:225
msgid "Error handling"
msgstr "Обработчики ошибок"

# 6d972bd8b1be4c8e8620aa141356a654
#: ../../topics/http/urls.txt:227
msgid "When Django can't find a regex matching the requested URL, or when an exception is raised, Django will invoke an error-handling view."
msgstr "Если Django не может найти подходящий шаблон URL, или было вызвано исключение в процессе обработки запроса, Django вызовет соответствующее представление обрабатывающее ошибку."

# 0376bbf36b9b4253b9787bcb99d43212
#: ../../topics/http/urls.txt:230
msgid "The views to use for these cases are specified by three variables. Their default values should suffice for most projects, but further customization is possible by assigning values to them."
msgstr "Эти представления определены в трех переменных. Для большинства проектов подойдут предуставноленные представления, но вы можете их поменять при необходимости."

# c75a6dcf875d47e993eaa2455616abd7
#: ../../topics/http/urls.txt:234
msgid "See the documentation on :ref:`customizing error views <customizing-error-views>` for the full details."
msgstr "Подробности в разделе о :ref:`переопределении обработчика ошибок <customizing-error-views>`."

# 5a1dec528982496a9ee9bfa57b78838c
#: ../../topics/http/urls.txt:237
msgid "Such values can be set in your root URLconf. Setting these variables in any other URLconf will have no effect."
msgstr "Эти значения должны быть определены в главном URLconf."

# 169ad2c1bed14d46b0f2f9665d7aa163
#: ../../topics/http/urls.txt:240
msgid "Values must be callables, or strings representing the full Python import path to the view that should be called to handle the error condition at hand."
msgstr "Значение это функции, или полный путь для импорта, которая будет вызвана, если не был найден подходящий URL-шаблон."

# 40b56a6070ec4f548c0a0b30579777cd
#: ../../topics/http/urls.txt:243
msgid "The variables are:"
msgstr "Есть следующие переменные:"

# 6851937bb16d449d84e15fb631ece159
#: ../../topics/http/urls.txt:245
msgid "``handler404`` -- See :data:`django.conf.urls.handler404`."
msgstr "``handler404`` -- Смотрите :data:`django.conf.urls.handler404`."

# d77483eafd9040798e41560f624a2fd0
#: ../../topics/http/urls.txt:246
msgid "``handler500`` -- See :data:`django.conf.urls.handler500`."
msgstr "``handler500`` -- Смотрите :data:`django.conf.urls.handler500`."

# de8ed53bc3164b73a0df7b7f7f794659
#: ../../topics/http/urls.txt:247
msgid "``handler403`` -- See :data:`django.conf.urls.handler403`."
msgstr "``handler403`` -- Смотрите :data:`django.conf.urls.handler403`."

# 40b56a6070ec4f548c0a0b30579777cd
#: ../../topics/http/urls.txt:255
msgid "The view prefix"
msgstr "Префикс представления"

# 896b967fd4a243489ffbd2b847a57caf
#: ../../topics/http/urls.txt:257
msgid "You can specify a common prefix in your ``patterns()`` call, to cut down on code duplication."
msgstr "Вы можете указать общий префикс при вызове ``patterns()`` что бы сократить дублирование кода."

# ba3218fda74644599bf84d08d03847d1
#: ../../topics/http/urls.txt:260
msgid "Here's the example URLconf from the :doc:`Django overview </intro/overview>`::"
msgstr "Вот пример URLconf из :doc:`обзора Django </intro/overview>`::"

# 24da6c6d5e0f4c0fbc2c57f1d1dfc607
#: ../../topics/http/urls.txt:270
msgid "In this example, each view has a common prefix -- ``'news.views'``. Instead of typing that out for each entry in ``urlpatterns``, you can use the first argument to the ``patterns()`` function to specify a prefix to apply to each view function."
msgstr "В этом пример, каждое представление содержит общий префикс -- ``'news.views'``. Вместо того, что бы писать его для каждой записи ``urlpatterns``, вы можете указать его первым аргументом функции ``patterns()``."

# c8ef7a5d95cf49ad8c69ddb3c3d1c7dd
#: ../../topics/http/urls.txt:275
msgid "With this in mind, the above example can be written more concisely as::"
msgstr "Теперь можно переписать пример выше::"

# c735e8e5c1a643d5b0233ac956d3b6fe
#: ../../topics/http/urls.txt:285
msgid "Note that you don't put a trailing dot (``\".\"``) in the prefix. Django puts that in automatically."
msgstr "Заметим что в конце префикса отсутствует точка (``\".\"``). Django самостоятельно добавит ее."

# dc4b5aa7cdee4d1b976202d3b92d1c15
#: ../../topics/http/urls.txt:289
msgid "Multiple view prefixes"
msgstr "Несколько префиксов представления"

# 642dc5193a70454cadd46a26fc6b5af9
#: ../../topics/http/urls.txt:291
msgid "In practice, you'll probably end up mixing and matching views to the point where the views in your ``urlpatterns`` won't have a common prefix. However, you can still take advantage of the view prefix shortcut to remove duplication. Just add multiple ``patterns()`` objects together, like this:"
msgstr "На практике, скорее всего представления в ``urlpatterns`` не буду содержать общий префикс. Однако, вы все равно можете использовать общий префикс что бы сократить дублирование кода. Просто используете несколько результатов вызова ``patterns()`` вместе:"

# 8517e13ed8054f0ab1d21c083a3c55bb
#: ../../topics/http/urls.txt:296
msgid "Old::"
msgstr "Раньше::"

# bd5aae80d4f142509e1581d4cc9ab103
#: ../../topics/http/urls.txt:306
msgid "New::"
msgstr "Теперь::"

# 6e8f5a3d7e53427a877351a6cf8687f1
#: ../../topics/http/urls.txt:322
msgid "Including other URLconfs"
msgstr "Комбинирование URLconfs"

# ce543103041c48d1b01e8aad527d3d4e
#: ../../topics/http/urls.txt:324
msgid "At any point, your ``urlpatterns`` can \"include\" other URLconf modules. This essentially \"roots\" a set of URLs below other ones."
msgstr "В любой момент, ваш ``urlpatterns`` может \"включать\" другие модули URLconf."

# d7f670c2106f42caada9e2db2c9d9c89
#: ../../topics/http/urls.txt:327
msgid "For example, here's an excerpt of the URLconf for the `Django Web site`_ itself. It includes a number of other URLconfs::"
msgstr "Вот пример URLconf для `сайта Django <http://www.djangoproject.com/>`_. Он включает множество других конфигураций URL::"

# 8b43692a7bed41fea08ee8547b80e70e
#: ../../topics/http/urls.txt:341
msgid "Note that the regular expressions in this example don't have a ``$`` (end-of-string match character) but do include a trailing slash. Whenever Django encounters ``include()`` (:func:`django.conf.urls.include()`), it chops off whatever part of the URL matched up to that point and sends the remaining string to the included URLconf for further processing."
msgstr "Заметим, что регулярные выражения не содержат ``$`` (определитель конца строки), но содержит слэш в конце. Каждый раз, когда Django встречает ``include()`` (:func:`django.conf.urls.include()`), из URL обрезается уже совпавшая часть, остальное передается во включенный URLconf для дальнейшей обработки."

# 0a937c37f833455ba63d013112a12b86
#: ../../topics/http/urls.txt:347
msgid "Another possibility is to include additional URL patterns not by specifying the URLconf Python module defining them as the ``include()`` argument but by using directly the pattern list as returned by :func:`~django.conf.urls.patterns` instead. For example, consider this URLconf::"
msgstr "Еще один способ добавить включить дополнительные URL-шаблоны: указать в ``include()`` результат выполнения :func:`~django.conf.urls.patterns`. Например::"

# 25d93fa4e1ab4f4889ab72ac6b6b551d
#: ../../topics/http/urls.txt:365
msgid "In this example, the ``/credit/reports/`` URL will be handled by the ``credit.views.report()`` Django view."
msgstr "В этом примере URL ``/credit/reports/`` обработан представлением ``credit.views.report()``."

# 92e201aaed794bb1a91e2a1968a52f2d
#: ../../topics/http/urls.txt:371
msgid "Captured parameters"
msgstr "Нахождение аргументов в URL"

# 6753ae947d4147b2a115a676350526cf
#: ../../topics/http/urls.txt:373
msgid "An included URLconf receives any captured parameters from parent URLconfs, so the following example is valid::"
msgstr "Включенный URLconf получает все аргументы найденные родительским URLconfs, по этому этот пример работает::"

# a5b43b2d81b24fe4b3a5900323f27757
#: ../../topics/http/urls.txt:387
msgid "In the above example, the captured ``\"username\"`` variable is passed to the included URLconf, as expected."
msgstr "В примере выше, найденный аргумент ``\"username\"`` передается во включенный URLconf, как и ожидалось."

# b2b2736313c548cd8c7d76ea42dcc30a
#: ../../topics/http/urls.txt:393
msgid "Passing extra options to view functions"
msgstr "Передача дополнительных аргументов в представление"

# 78cf611a86654220aa9b88c39b766c33
#: ../../topics/http/urls.txt:395
msgid "URLconfs have a hook that lets you pass extra arguments to your view functions, as a Python dictionary."
msgstr "Конфигурация URL-ов позволяет определить дополнительные аргументы для функции представления, используя словарь Python."

# 47f8727f4995461ba83343ba2192c658
#: ../../topics/http/urls.txt:398
msgid "Any URLconf tuple can have an optional third element, which should be a dictionary of extra keyword arguments to pass to the view function."
msgstr "Каждый кортеж в URLconf может содержать третий необязательный элемент. Этот элемент определяет дополнительные именованные аргументы для функции представления."

# 0546db3de0ad4f2787bdd62427825eff
#: ../../topics/http/urls.txt:401
#: ../../topics/http/urls.txt:806
msgid "For example::"
msgstr "Например::"

# c8a9acd499bf42b1821971de37c0eb5b
#: ../../topics/http/urls.txt:407
msgid "In this example, for a request to ``/blog/2005/``, Django will call ``blog.views.year_archive(year='2005', foo='bar')``."
msgstr "Например, при запросе к ``/blog/2005/``, Django вызовет ``blog.views.year_archive(year='2005', foo='bar')``."

# 72964d0c5c084ef3b82843fe8ed45eed
#: ../../topics/http/urls.txt:410
msgid "This technique is used in the :doc:`syndication framework </ref/contrib/syndication>` to pass metadata and options to views."
msgstr "Такой подход используется в :doc:`syndication framework </ref/contrib/syndication>` для передачи параметров и дополнительных данных в представление."

# f90d4341a12d4766a0a1fed2b2ecc43c
#: ../../topics/http/urls.txt:416
msgid "It's possible to have a URL pattern which captures named keyword arguments, and also passes arguments with the same names in its dictionary of extra arguments. When this happens, the arguments in the dictionary will be used instead of the arguments captured in the URL."
msgstr "Если регулярное выражение URL-шаблона выделяет из URL-а аргумент с названием, которое уже используется в дополнительных именованных аргументах, будет использован аргумент из словаря дополнительных аргументов, вместо значения из URL."

# b10f757cff594fc2bf5fa49c7225bf55
#: ../../topics/http/urls.txt:422
msgid "Passing extra options to ``include()``"
msgstr "Передача дополнительных аргументов в ``include()``"

# 3f4d4226ad30422ab0ecfd6d14f16390
#: ../../topics/http/urls.txt:424
msgid "Similarly, you can pass extra options to :func:`~django.conf.urls.include`. When you pass extra options to ``include()``, *each* line in the included URLconf will be passed the extra options."
msgstr "Аналогично вы можете передать дополнительные аргументы в :func:`~django.conf.urls.include`. При этом, *каждый* URL-шаблон включенного URLconf будет дополнен этими дополнительными аргументами."

# 42098b4ed83547cfa4cdbb3ca842ad39
#: ../../topics/http/urls.txt:428
msgid "For example, these two URLconf sets are functionally identical:"
msgstr "Например, эти два URLconf работают идентично:"

# b24a132a808043508c3ea87b077bbf68
#: ../../topics/http/urls.txt:430
msgid "Set one::"
msgstr "Первый::"

# adf681d691c346e494bcf1b04755cab8
#: ../../topics/http/urls.txt:443
msgid "Set two::"
msgstr "Второй::"

# 88f079c65c4d446eb77b1d41db891999
#: ../../topics/http/urls.txt:456
msgid "Note that extra options will *always* be passed to *every* line in the included URLconf, regardless of whether the line's view actually accepts those options as valid. For this reason, this technique is only useful if you're certain that every view in the included URLconf accepts the extra options you're passing."
msgstr "Дополнительные аргументы *всегда* передаются *каждому* представлению во включенном URLconf, независимо от того, принимает оно эти аргументы или нет. По этому, такой подход полезен только если вы уверенны, что каждое представление принимает передаваемые аргументы."

# b3167eb0046e483f8202f5f0a3034a6e
#: ../../topics/http/urls.txt:462
msgid "Passing callable objects instead of strings"
msgstr "Передача функций вместо строк"

# 814ce3d44967497eae0c09117bef9d13
#: ../../topics/http/urls.txt:464
msgid "Some developers find it more natural to pass the actual Python function object rather than a string containing the path to its module. This alternative is supported -- you can pass any callable object as the view."
msgstr "Некоторые разработчики предпочитают передавать функции вместо строк, содержащих путь для импорта. Такой способ так же работает -- вы можете передать любой вызываемый объект в качестве представлений."

# 1ec909fc44be42fd8c817b55f0a92058
#: ../../topics/http/urls.txt:468
msgid "For example, given this URLconf in \"string\" notation::"
msgstr "Например, у нас есть такой URLconf::"

# 0547250899224766abb8a6ec5795d16e
#: ../../topics/http/urls.txt:476
msgid "You can accomplish the same thing by passing objects rather than strings. Just be sure to import the objects::"
msgstr "Вы можете сделать то же самое, передавая объекты вместо строк. Просто импортируйте эти объекты::"

# f14d8cdd987f43beb994c0e9d96af0a5
#: ../../topics/http/urls.txt:487
msgid "The following example is functionally identical. It's just a bit more compact because it imports the module that contains the views, rather than importing each view individually::"
msgstr "Следующий пример работает аналогично. Он немного короче, потому что мы импортируем модуль содержащий представления, а не каждое представление по отдельности::"

# 25a54f46992740539051d7e45c2088d2
#: ../../topics/http/urls.txt:499
msgid "The style you use is up to you."
msgstr "Стиль, который вы используете, зависит от вас."

# 31697dbff4674953a63a44bd823beae7
#: ../../topics/http/urls.txt:501
msgid "Note that if you use this technique -- passing objects rather than strings -- the view prefix (as explained in \"The view prefix\" above) will have no effect."
msgstr "Стоит заметить, что при передаче объекта вместо строки, префикс для представлений (описанный выше `The view prefix`_) не будет иметь никакого эффекта."

# 21746d7468f34e1b813b9133809fdce8
#: ../../topics/http/urls.txt:504
msgid "Note that :doc:`class based views</topics/class-based-views/index>` must be imported::"
msgstr "Не забываем импоритровать :doc:`представления-классы </topics/class-based-views/index>`::"

# 6337fe6f80bc4bb99ab8e72ce69a6e48
#: ../../topics/http/urls.txt:514
msgid "Reverse resolution of URLs"
msgstr "Поиск URL-а по URL-шаблону"

# 36a6256db198410a8c93dc157892ffcc
#: ../../topics/http/urls.txt:516
msgid "A common need when working on a Django project is the possibility to obtain URLs in their final forms either for embedding in generated content (views and assets URLs, URLs shown to the user, etc.) or for handling of the navigation flow on the server side (redirections, etc.)"
msgstr "Обычной задачей является получение URL-а по его определению для отображения пользователю, или редиректа."

# defbbce6d1614d29afd87740463fd791
#: ../../topics/http/urls.txt:521
msgid "It is strongly desirable not having to hard-code these URLs (a laborious, non-scalable and error-prone strategy) or having to devise ad-hoc mechanisms for generating URLs that are parallel to the design described by the URLconf and as such in danger of producing stale URLs at some point."
msgstr "Очень важно не \"хардкодить\" URL-ы (трудоемкая и плохо поддерживаемая стратегия). Иногда необходимо менять структуру URL-ов, при этом важно что не оставить где-то URL в старом формате."

# a59e634e0e8f48369bc87d809fef1721
#: ../../topics/http/urls.txt:526
msgid "In other words, what's needed is a DRY mechanism. Among other advantages it would allow evolution of the URL design without having to go all over the project source code to search and replace outdated URLs."
msgstr "В общем необходимо предерживаться принципу DRY. Не мало важно иметь возможность менять URL-ы в одном месте, а не выполнять поиск и замену по всему проекту."

# 494fd1ff32d04500a45c972b4ae43c8e
#: ../../topics/http/urls.txt:530
msgid "The piece of information we have available as a starting point to get a URL is an identification (e.g. the name) of the view in charge of handling it, other pieces of information that necessarily must participate in the lookup of the right URL are the types (positional, keyword) and values of the view arguments."
msgstr ""

# c11fb61d089d482bb37c8af6e59b3c03
#: ../../topics/http/urls.txt:535
msgid "Django provides a solution such that the URL mapper is the only repository of the URL design. You feed it with your URLconf and then it can be used in both directions:"
msgstr ""

# 0c26a4dea83b4010b06c2543cebd805d
#: ../../topics/http/urls.txt:539
msgid "Starting with a URL requested by the user/browser, it calls the right Django view providing any arguments it might need with their values as extracted from the URL."
msgstr ""

# e33db5084a0b41a49c16712e2a6591cc
#: ../../topics/http/urls.txt:543
msgid "Starting with the identification of the corresponding Django view plus the values of arguments that would be passed to it, obtain the associated URL."
msgstr ""

# 245e16b169a74dc9b15d43a15d033150
#: ../../topics/http/urls.txt:546
msgid "The first one is the usage we've been discussing in the previous sections. The second one is what is known as *reverse resolution of URLs*, *reverse URL matching*, *reverse URL lookup*, or simply *URL reversing*."
msgstr ""

# 990f40827e7d46d2b4261a822be79b14
#: ../../topics/http/urls.txt:550
msgid "Django provides tools for performing URL reversing that match the different layers where URLs are needed:"
msgstr ""

# 38a637c8a05e468eb0e487219a91c429
#: ../../topics/http/urls.txt:553
msgid "In templates: Using the :ttag:`url` template tag."
msgstr ""

# a207ad47ec2a4a0f8f222ba97b6c5c76
#: ../../topics/http/urls.txt:555
msgid "In Python code: Using the :func:`django.core.urlresolvers.reverse` function."
msgstr ""

# f9ea1b69b77d4633bf6e99746f92bac0
#: ../../topics/http/urls.txt:558
msgid "In higher level code related to handling of URLs of Django model instances: The :meth:`~django.db.models.Model.get_absolute_url` method."
msgstr ""

# adf7e75d4544433d812cbce0425fd3c9
#: ../../topics/http/urls.txt:562
msgid "Examples"
msgstr "Примеры"

# d3d3d263a578458ebddeb5bcb00d6d13
#: ../../topics/http/urls.txt:564
msgid "Consider again this URLconf entry::"
msgstr ""

# af6e1ada257047abaa2f78bb09d12be4
#: ../../topics/http/urls.txt:574
msgid "According to this design, the URL for the archive corresponding to year *nnnn* is ``/articles/nnnn/``."
msgstr ""

# 422ceb5ee1a94f8981685c128d49e26d
#: ../../topics/http/urls.txt:577
msgid "You can obtain these in template code by using:"
msgstr ""

# c6fc742900214a89af6271e8f727ccc9
#: ../../topics/http/urls.txt:589
msgid "Or in Python code::"
msgstr ""

# ac994ad368e44fba9fbfa34fd0668632
#: ../../topics/http/urls.txt:600
msgid "If, for some reason, it was decided that the URLs where content for yearly article archives are published at should be changed then you would only need to change the entry in the URLconf."
msgstr ""

# 7ce3047c7f5c46bdaa190ccbf9549864
#: ../../topics/http/urls.txt:604
msgid "In some scenarios where views are of a generic nature, a many-to-one relationship might exist between URLs and views. For these cases the view name isn't a good enough identificator for it when it comes the time of reversing URLs. Read the next section to know about the solution Django provides for this."
msgstr ""

# 34cf6780279c4de9ad2c06814f1efd12
#: ../../topics/http/urls.txt:612
msgid "Naming URL patterns"
msgstr "Именованные URL-шаблоны"

# 567b930166e94022b493d2fd072033a9
#: ../../topics/http/urls.txt:614
msgid "It's fairly common to use the same view function in multiple URL patterns in your URLconf. For example, these two URL patterns both point to the ``archive`` view::"
msgstr "Обычная практика использовать одно представление для нескольких URL-шаблонов в URLconf. Например, эти два URL-шаблона указывают на представление ``archive``::"

# bd7a27eef8c44d5281f5c5833026be04
#: ../../topics/http/urls.txt:623
msgid "This is completely valid, but it leads to problems when you try to do reverse URL matching (through the :func:`~django.core.urlresolvers.reverse` function or the :ttag:`url` template tag). Continuing this example, if you wanted to retrieve the URL for the ``archive`` view, Django's reverse URL matcher would get confused, because *two* URL patterns point at that view."
msgstr "Этот пример работает, но, если вы захотите найти URL (используя  :func:`~django.core.urlresolvers.reverse` или тег шаблона :ttag:`url`), это приведет к проблемам. Если вы захотите получить URL для представления ``archive``, Django запутается так как *два* URL-шаблона соответствуют одному представлению."

# 713f8edfed024beb86cb384e08a8f6e8
#: ../../topics/http/urls.txt:629
msgid "To solve this problem, Django supports **named URL patterns**. That is, you can give a name to a URL pattern in order to distinguish it from other patterns using the same view and parameters. Then, you can use this name in reverse URL matching."
msgstr "Для решения этой проблемы, Django предоставляет **именованные URL-шаблоны**. То есть, вы можете дать название для URL-шаблонов что бы отличать их и использовать эти названия при поиске нужного вам URL-а."

# 27f7c2bb6a8b4a00a0ed20b1cdb18dbb
#: ../../topics/http/urls.txt:634
msgid "Here's the above example, rewritten to use named URL patterns::"
msgstr "Перепишем пример выше с использованием именованных URL-шаблонов::"

# f13201346f2649ffb85ae2398dfe51b1
#: ../../topics/http/urls.txt:641
msgid "With these names in place (``full-archive`` and ``arch-summary``), you can target each pattern individually by using its name:"
msgstr "Используя эти названия (``full-archive`` и ``arch-summary``), вы можете обратиться к каждому URL-шаблону отдельно:"

# 4229a4eb356043b6b53585a65222b006
#: ../../topics/http/urls.txt:649
msgid "Even though both URL patterns refer to the ``archive`` view here, using the ``name`` parameter to ``url()`` allows you to tell them apart in templates."
msgstr "Хоть оба URL-шаблона ссылаются на одно представление ``archive``, использование параметра ``name`` в теге ``url()`` позволит вам различить их в шаблоне."

# 60bac55c29c34734a8b5dd6241af5f3f
#: ../../topics/http/urls.txt:652
msgid "The string used for the URL name can contain any characters you like. You are not restricted to valid Python names."
msgstr "Вы можете использовать любые символы в названии."

# 14723fa60d674503b153eb1ca381d3af
#: ../../topics/http/urls.txt:657
msgid "When you name your URL patterns, make sure you use names that are unlikely to clash with any other application's choice of names. If you call your URL pattern ``comment``, and another application does the same thing, there's no guarantee which URL will be inserted into your template when you use this name."
msgstr "При выборе названия для URL-шаблона, убедитесь что оно достаточно уникально. Если вы назовете URL-шаблон ``comment``, и другое приложение сделает аналогичное, нет гарантии что в шаблон будет вставлен правильный URL."

# 309eff09cb8247ceb2af18bcec659976
#: ../../topics/http/urls.txt:663
msgid "Putting a prefix on your URL names, perhaps derived from the application name, will decrease the chances of collision. We recommend something like ``myapp-comment`` instead of ``comment``."
msgstr "Добавление префикса к названию URL-шаблона, возможного состоящего из названия приложения, уменьшит шанс конфликта. Мы советуем использовать ``myapp-comment`` вместо ``comment``."

# 92f63802982e425a83b2ea2cf0e45444
#: ../../topics/http/urls.txt:670
msgid "URL namespaces"
msgstr "Пространства имен в конфигурации URL-ов"

# 4a3f3844f9d54525b4d0210821220045
#: ../../topics/http/urls.txt:673
msgid "Introduction"
msgstr "Описание"

# 3a6abf87e6cb468086803751ef325dc5
#: ../../topics/http/urls.txt:675
msgid "When you need to deploy multiple instances of a single application, it can be helpful to be able to differentiate between instances. This is especially important when using :ref:`named URL patterns <naming-url-patterns>`, since multiple instances of a single application will share named URLs. Namespaces provide a way to tell these named URLs apart."
msgstr "Если необходимо использовать несколько экземпляров одного приложения, было бы удобно иметь возможность различать их. Это особенно важно при использовании :ref:`именованных шаблонов URL <naming-url-patterns>`, так как несколько экземпляров используют одинаковые названия для URL-ов. Пространства имен позволяют сделать эти названия уникальными."

# 8564d4d0edcc4355b741c81fbfee8b44
#: ../../topics/http/urls.txt:681
msgid "A URL namespace comes in two parts, both of which are strings:"
msgstr "Пространство имен состоит из двух частей, каждая из которых это строка:"

# 04864b70a0ad4532a65d972beaabcee9
#: ../../topics/http/urls.txt:686
msgid "This describes the name of the application that is being deployed. Every instance of a single application will have the same application namespace. For example, Django's admin application has the somewhat predictable application namespace of ``'admin'``."
msgstr "Указывает название установленного приложения. Все экземпляры одного приложения будет иметь одно название. Например, название приложения администратора Django -- ``admin``."

# 343b9502cdac4e0f971dec04a743cd9a
#: ../../topics/http/urls.txt:692
msgid "This identifies a specific instance of an application. Instance namespaces should be unique across your entire project. However, an instance namespace can be the same as the application namespace. This is used to specify a default instance of an application. For example, the default Django Admin instance has an instance namespace of ``'admin'``."
msgstr "Идентифицирует конкретный экземпляр приложения. Должно быть уникальным для проекта. Однако, название экземпляра может быть равным названию приложения. Оно используется по-умолчанию при создании приложения. Например, пространство имен приложения администратора Django -- ``admin``."

# 14ef8de1e76a40ddbaa40fc9cbc9d4f1
#: ../../topics/http/urls.txt:698
msgid "Namespaced URLs are specified using the ``':'`` operator. For example, the main index page of the admin application is referenced using ``'admin:index'``. This indicates a namespace of ``'admin'``, and a named URL of ``'index'``."
msgstr "Пространство имен определяется с помощью оператора ``':'``. Например, главная страница интерфейса администратора определяется как ``'admin:index'``. Мы видим пространство имен ``'admin'``, и название URL-шаблона ``'index'``."

# dd0beb185dda4037a57e82d5dc638d0d
#: ../../topics/http/urls.txt:702
msgid "Namespaces can also be nested. The named URL ``'foo:bar:whiz'`` would look for a pattern named ``'whiz'`` in the namespace ``'bar'`` that is itself defined within the top-level namespace ``'foo'``."
msgstr "Пространства имен могут быть вложенными. Название URL-а ``'foo:bar:whiz'`` означает именованный URL-шаблон с названием ``'foo:bar:whiz'`` в пространстве имен ``'bar'``, которое было определенно в другом пространстве имен - ``'foo'``."

# 9be6dca660e946dc96bef98ac8b5713d
#: ../../topics/http/urls.txt:709
msgid "Reversing namespaced URLs"
msgstr "Поиск URL-а по шаблону с пространством имен"

# 83542e06d4c0423ab8f1bd4a83ef08eb
#: ../../topics/http/urls.txt:711
msgid "When given a namespaced URL (e.g. ``'myapp:index'``) to resolve, Django splits the fully qualified name into parts, and then tries the following lookup:"
msgstr "Если необходимо найти URL по названию с пространсвом имен (например, ``'myapp:index'``), Django разбивает название на части и следует такому алгоритму:"

# 8961ae51f16347ff8b70c775b996abb6
#: ../../topics/http/urls.txt:714
msgid "First, Django looks for a matching :term:`application namespace` (in this example, ``'myapp'``). This will yield a list of instances of that application."
msgstr "Первым делом, Django проверяет :term:`название(пространсву имен) приложения` (например, ``myapp``).  Django получает список экземпляров приложения."

# 998245c1af554383854ef043ca51ae28
#: ../../topics/http/urls.txt:718
msgid "If there is a *current* application defined, Django finds and returns the URL resolver for that instance. The *current* application can be specified as an attribute on the template context - applications that expect to have multiple deployments should set the ``current_app`` attribute on any ``Context`` or ``RequestContext`` that is used to render a template."
msgstr "Если указан *текущий* экземпляр приложения, Django вернет \"URL resolver\" для этого экземпляра. *Текущий* экземпляр приложения можно указать используя атрибут ``current_app`` контекста шаблона. Приложения, которые будут использоваться в нескольких экземплярах в одном проекте, должны всегда определять атрибут ``current_app`` для ``Context`` или ``RequestContext``, который используется для выполнения шаблона."

# 225786f8ff194241a0870be14b65103b
#: ../../topics/http/urls.txt:725
msgid "The current application can also be specified manually as an argument to the :func:`django.core.urlresolvers.reverse` function."
msgstr "Текущей экземпляр приложения можно так же определить используя аргумент при вызове функции :func:`django.core.urlresolvers.reverse`."

# 6c884ad3de5542f8a98cf56e9687b0d7
#: ../../topics/http/urls.txt:728
msgid "If there is no current application. Django looks for a default application instance. The default application instance is the instance that has an :term:`instance namespace` matching the :term:`application namespace` (in this example, an instance of the ``myapp`` called ``'myapp'``)."
msgstr "Если текущий экземпляр приложения не найден, Django попытается использовать экземпляр по-умолчанию. Экземпляр по-умолчанию -- это экземпляр, у которого:term:`название приложения` и :term:`название экземпляра приложения` совпадают (в нашем примере это экземпляр ``myapp`` с названием ``myapp``)."

# 86ca11bff43f4a3daabeabc0a7c7e2e5
#: ../../topics/http/urls.txt:734
msgid "If there is no default application instance, Django will pick the last deployed instance of the application, whatever its instance name may be."
msgstr "Если экземпляр по-умолчанию не найден, Django возьмет последний установленный экземпляр приложения, не обращая внимание на его название."

# 2fbf1280565149daa69184349b4daa83
#: ../../topics/http/urls.txt:737
msgid "If the provided namespace doesn't match an :term:`application namespace` in step 1, Django will attempt a direct lookup of the namespace as an :term:`instance namespace`."
msgstr "Если на первом шаге не было найдено приложение по указанному пространству имен, Django попытается найти экземпляр приложения по его названию, используя пространство имен как название экземпляра."

# 91c5534255134861a26e4fa234a8ef6b
#: ../../topics/http/urls.txt:741
msgid "If there are nested namespaces, these steps are repeated for each part of the namespace until only the view name is unresolved. The view name will then be resolved into a URL in the namespace that has been found."
msgstr "Если пространство имен вложенное, этот процесс будет повторен, пока неопределенным не останется только название представления. URL для названия представления будет искаться среди URL-шаблонов определенных в приложении, найденном через пространство имен."

# d2932e82a8ff4612bf131f254d4e1662
#: ../../topics/http/urls.txt:748
msgid "To show this resolution strategy in action, consider an example of two instances of ``myapp``: one called ``'foo'``, and one called ``'bar'``. ``myapp`` has a main index page with a URL named ``'index'``. Using this setup, the following lookups are possible:"
msgstr "Разберем небольшой пример. У нас есть два экземпляра приложения ``myapp``: один назван ``foo``, другой - ``bar``. ``myapp`` содержит главную страницу с названием URL-а `index`. Возможны  такие ситуации:"

# c4f1a0672065409a8b32ff890d82afec
# 28c4f462d1ee427c8f23024192015366
#: ../../topics/http/urls.txt:753
#: ../../topics/http/urls.txt:770
msgid "If one of the instances is current - say, if we were rendering a utility page in the instance ``'bar'`` - ``'myapp:index'`` will resolve to the index page of the instance ``'bar'``."
msgstr "Если один из экземпляров указан как текущий - например, мы выполняем шаблон в экземпляре ``bar`` - поиск URL-а по ``myapp:index`` вернет URL на главную страницу экземпляра приложения ``bar``."

# cccee5e92f1c426db57088f0800e0336
#: ../../topics/http/urls.txt:757
msgid "If there is no current instance - say, if we were rendering a page somewhere else on the site - ``'myapp:index'`` will resolve to the last registered instance of ``myapp``. Since there is no default instance, the last instance of ``myapp`` that is registered will be used. This could be ``'foo'`` or ``'bar'``, depending on the order they are introduced into the urlpatterns of the project."
msgstr "Если текущий экземпляр приложения не указан - например, мы ищем URL в другом приложении -  поиск по ``'myapp:index'`` вернет URL для последнего добавленного экземпляра ``'myapp'``. Это может быть ``'foo'`` или ``'bar'``, в зависимости от того, в коком порядке они были добавлены в URL-шаблоны проекта."

# 4ad351cd6e984156a65909f3aedcb529
#: ../../topics/http/urls.txt:764
msgid "``'foo:index'`` will always resolve to the index page of the instance ``'foo'``."
msgstr "Поиск по ``'foo:index'``всегда вернет ссылку на главную страницу экземпляра приложения ``'foo'``."

# 85ce88d04cfd41a9bdad5af3b51d9bf7
#: ../../topics/http/urls.txt:767
msgid "If there was also a default instance - i.e., an instance named ``'myapp'`` - the following would happen:"
msgstr "Если бы был определен экземпляр по-умолчанию - то есть, экземпляр с названием ``'myapp'``:"

# 5b055cb3dd4c43d2ada5fd3760104c6c
#: ../../topics/http/urls.txt:774
msgid "If there is no current instance - say, if we were rendering a page somewhere else on the site - ``'myapp:index'`` will resolve to the index page of the default instance."
msgstr "Если текущий экземпляр приложения не указан - например, мы ищем URL в другом приложении - поиск по ``'myapp:index'`` вернет URL на главную страницу экземпляра по-умолчанию."

# 6297298535fa48b8b6fa1e808b853cbc
#: ../../topics/http/urls.txt:778
msgid "``'foo:index'`` will again resolve to the index page of the instance ``'foo'``."
msgstr "Поиск по ``'foo:index'``все так же вернет ссылку на главную страницу экземпляра приложения ``'foo'``."

# 01957d91166c45828a3d39607c2e00f7
#: ../../topics/http/urls.txt:784
msgid "URL namespaces and included URLconfs"
msgstr ""

# 3e8eeb7bb3e4413faf2861a3bc111d25
#: ../../topics/http/urls.txt:786
msgid "URL namespaces of included URLconfs can be specified in two ways."
msgstr "Пространство имен URL можно определить двумя путями."

# 41bbb924087e465ab7351becb2036397
#: ../../topics/http/urls.txt:788
msgid "Firstly, you can provide the :term:`application <application namespace>` and :term:`instance <instance namespace>` namespaces as arguments to :func:`django.conf.urls.include()` when you construct your URL patterns. For example,::"
msgstr "Первый, передав в качестве аргументов при вызове :func:`django.conf.urls.include()`. Например::"

# 1f9f3e7cb8a8476a876fb9f9957d0813
#: ../../topics/http/urls.txt:795
msgid "This will include the URLs defined in ``apps.help.urls`` into the :term:`application namespace` ``'bar'``, with the :term:`instance namespace` ``'foo'``."
msgstr "Этот код добавляет URL-шаблоны определенные в ``apps.help.urls``, используя название приложения ``'bar'`` и название экземпляра ``'foo'``."

# 939460af658044779d58aa573dc8705b
#: ../../topics/http/urls.txt:799
msgid "Secondly, you can include an object that contains embedded namespace data. If you ``include()`` an object as returned by :func:`~django.conf.urls.patterns`, the URLs contained in that object will be added to the global namespace. However, you can also ``include()`` a 3-tuple containing::"
msgstr "Второй, вы можете добавить объект, который содержит все необходимые данные. Если использовать результат:func:`~django.conf.urls.patterns` при вызове функции ``include()``, он будет добавлен в глобальное пространство имен. Однако, в ``include()`` можно передать 3-элементный кортеж, который содержит::"

# 1f9f3e7cb8a8476a876fb9f9957d0813
#: ../../topics/http/urls.txt:815
msgid "This will include the nominated URL patterns into the given application and instance namespace."
msgstr "Этот код добавляет URL-шаблоны, используя название приложения ``bar`` и название экземпляра ``foo``."

# 0fcd3c782822428996639208c2087345
#: ../../topics/http/urls.txt:818
msgid "For example, the Django Admin is deployed as instances of :class:`~django.contrib.admin.AdminSite`.  ``AdminSite`` objects have a ``urls`` attribute: A 3-tuple that contains all the patterns in the corresponding admin site, plus the application namespace ``'admin'``, and the name of the admin instance. It is this ``urls`` attribute that you ``include()`` into your projects ``urlpatterns`` when you deploy an Admin instance."
msgstr "Такой подход используется при подключении приложения интерфейса администратора(``admin``) Django. Для подключения используется экземпляр :class:`~django.contrib.admin.AdminSite`, каждый из которых содержит свойство ``urls``. Оно возвращает URL-шаблоны, которые доступные для этого экземпляра. Это то свойство, которое вы добавляете, используя ``include()``, в  ``urlpatterns`` вашего проекта при установке приложения администратора."

