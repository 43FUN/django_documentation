# Russian translations for Django package.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
# Automatically generated <>, 2012.
#
msgid ""
msgstr ""
"Project-Id-Version: Django 1.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2012-03-24 01:58\n"
"PO-Revision-Date: 2012-03-10 11:49+0200\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"

# 44a89a46f3e148ee966538fa70492490
#: ../../topics/http/urls.txt:3
msgid "URL dispatcher"
msgstr "Менеджер URL-ов"

# 17df4924b86442ad89dcf7d0419847af
#: ../../topics/http/urls.txt:7
msgid ""
"A clean, elegant URL scheme is an important detail in a high-quality Web "
"application. Django lets you design URLs however you want, with no framework "
"limitations."
msgstr ""
"Чистая, элегантная схема URL-ов -- это важная часть качественного "
"приложения. Django позволяет проектировать URL-адреса как вы пожелаете, без "
"ограничений \"фреймверка\"."

# 57872ae9e3b04448989f58fbba7a0059
#: ../../topics/http/urls.txt:11
msgid ""
"There's no ``.php`` or ``.cgi`` required, and certainly none of that "
"``0,2097,1-1-1928,00`` nonsense."
msgstr ""
"В  URL-ах не нужны ни ``.php``, ни ``.cgi``, ни всякая ерунда вроде "
"``0,2097,1-1-1928,00``."

# ff73ff2f19c0487d9a216ff2537ef310
#: ../../topics/http/urls.txt:14
msgid ""
"See `Cool URIs don't change`_, by World Wide Web creator Tim Berners-Lee, "
"for excellent arguments on why URLs should be clean and usable."
msgstr ""
"Читайте `Cool URIs don't change <http://www.w3.org/Provider/Style/URI>`_, "
"создателя World Wide Web, Тима Бернерса-Ли, что бы узнать почему URL-ы "
"должны быть красивыми и практичными."

# 3fb1d863ce6d42f89ebbe0b643b704e0
#: ../../topics/http/urls.txt:20
msgid "Overview"
msgstr "Обзор"

# 94510b9fca3b475b8bb54eee7b08717d
#: ../../topics/http/urls.txt:22
msgid ""
"To design URLs for an app, you create a Python module informally called a "
"**URLconf** (URL configuration). This module is pure Python code and is a "
"simple mapping between URL patterns (as simple regular expressions) to "
"Python callback functions (your views)."
msgstr ""
"Для определения URL-ов приложения, создайте модуль Python, неофициально "
"названный **URLconf** (конфигурация URL-ов). Этот модуль содержит код "
"Python, который отображает URL-шаблоны (регулярные выражения) и связанные "
"функции Python (ваши представления)."

# 2ca36790b64b4d27a3fbcfbc53abf138
#: ../../topics/http/urls.txt:27
msgid ""
"This mapping can be as short or as long as needed. It can reference other "
"mappings. And, because it's pure Python code, it can be constructed "
"dynamically."
msgstr ""
"Эта конфигурация может быть короткой или длинной на столько, на сколько это "
"нужно. Она может ссылаться на другие конфигурации. И, так как это код "
"Python, может создаваться динамически."

# 824220d3e1ac4e3d82fcfde6df717952
#: ../../topics/http/urls.txt:39
msgid "How Django processes a request"
msgstr "Как Django обрабатывает запрос"

# 489d8bd0d15844c49998431831e97e90
#: ../../topics/http/urls.txt:41
msgid ""
"When a user requests a page from your Django-powered site, this is the "
"algorithm the system follows to determine which Python code to execute:"
msgstr ""
"При запросе к странице вашего Django-сайта, используется такой алгоритм для "
"определения какой код выполнить:"

# 8ced9086b21a4f25864ed385571abe9c
#: ../../topics/http/urls.txt:44
msgid ""
"Django determines the root URLconf module to use. Ordinarily, this is the "
"value of the :setting:`ROOT_URLCONF` setting, but if the incoming "
"``HttpRequest`` object has an attribute called ``urlconf`` (set by "
"middleware :ref:`request processing <request-middleware>`), its value will "
"be used in place of the :setting:`ROOT_URLCONF` setting."
msgstr ""
"Django определяет какой корневой модуль URLconf использовать. Обычно, это "
"значение настройки :setting:`ROOT_URLCONF`, но, если объект запроса "
"``HttpRequest`` содержит атрибут ``urlconf`` (установленный :ref:`request "
"middleware <request-middleware>`), его значение будет использоваться вместо :"
"setting:`ROOT_URLCONF`."

# 048d4ea680974eb0a9ccc9e7b1791e26
#: ../../topics/http/urls.txt:50
msgid ""
"Django loads that Python module and looks for the variable ``urlpatterns``. "
"This should be a Python list, in the format returned by the function :func:"
"`django.conf.urls.patterns`."
msgstr ""
"Django загружает модуль конфигурации URL и ищет переменную ``urlpatterns``. "
"Это должен быть список Python, в формате возвращаемом функцией :func:`django."
"conf.urls.patterns`."

# ad17d75eba8f4abeb8d931e0dcf08f86
#: ../../topics/http/urls.txt:54
msgid ""
"Django runs through each URL pattern, in order, and stops at the first one "
"that matches the requested URL."
msgstr ""
"Django перебирает каждый URL-шаблон по порядку, и останавливается при первом "
"совпадении с запрошенным URL-ом."

# 504bddbb80be449a86e67df32d2510a3
#: ../../topics/http/urls.txt:57
msgid ""
"Once one of the regexes matches, Django imports and calls the given view, "
"which is a simple Python function. The view gets passed an :class:`~django."
"http.HttpRequest` as its first argument and any values captured in the regex "
"as remaining arguments."
msgstr ""
"Если одно из регулярных выражений соответствует URL-у, Django импортирует и "
"вызывает соответствующее представление, которое является просто функцией "
"Python. При вызове первым аргументом передается :class:`~django.http."
"HttpRequest` а так же все значения найденные регулярным выражением."

# 49c3d738987d4b73b155913fefcacd4e
#: ../../topics/http/urls.txt:62
msgid ""
"If no regex matches, or if an exception is raised during any point in this "
"process, Django invokes an appropriate error-handling view. See `Error "
"handling`_ below."
msgstr ""
"Если ни одно регулярное выражение не соответствует, или возникла ошибка на "
"любом из этапов, Django вызывает соответствующий обработчик ошибок. Смотрите "
"`Error handling`_ ниже."

# adf7e75d4544433d812cbce0425fd3c9
#: ../../topics/http/urls.txt:67
msgid "Example"
msgstr "Например"

# 115122f3828343838f934ed3546d20a3
#: ../../topics/http/urls.txt:69
msgid "Here's a sample URLconf::"
msgstr "Вот пример простого URLconf::"

# de11530a822643d186b5167894f4a50a
#: ../../topics/http/urls.txt:80
msgid "Notes:"
msgstr "Заметим:"

# 306dd9b944c04e6292ea7bb6ef4931ca
#: ../../topics/http/urls.txt:82
msgid "To capture a value from the URL, just put parenthesis around it."
msgstr ""
"Для получения совпадающего значения из URL, просто добавьте скобки вокруг "
"него."

# 99f6e002f1b8417d82f05dffb1ba7db7
#: ../../topics/http/urls.txt:84
msgid ""
"There's no need to add a leading slash, because every URL has that. For "
"example, it's ``^articles``, not ``^/articles``."
msgstr ""
"Не нужно добавлять слэш в начале, потому что каждый URL содержит его. "
"Например, используйте ``^articles``, вместо ``^/articles``."

# 07d2957e806b48c1a1795e26d375d8ba
#: ../../topics/http/urls.txt:87
msgid ""
"The ``'r'`` in front of each regular expression string is optional but "
"recommended. It tells Python that a string is \"raw\" -- that nothing in the "
"string should be escaped. See `Dive Into Python's explanation`_."
msgstr ""
"Символ ``'r'`` перед каждым регулярным выражением не обязателен, но "
"рекомендуется. Он указывает Python что строка \"сырая(raw)\" и ничего в "
"строке не должно быть экранировано. Смотрите `Dive Into Python's explanation "
"<http://www.diveintopython.net/regular_expressions/street_addresses.html#re."
"matching.2.3>`_."

# 5570142fb42b42858f44f59c68288e6f
#: ../../topics/http/urls.txt:91
msgid "Example requests:"
msgstr "Примеры запросов:"

# 9de013fa45cf458abb78de966637712e
#: ../../topics/http/urls.txt:93
msgid ""
"A request to ``/articles/2005/03/`` would match the third entry in the list. "
"Django would call the function ``news.views.month_archive(request, '2005', "
"'03')``."
msgstr ""
"Запрос к``/articles/2005/03/`` будет обработан третьим элементом списка. "
"Django вызовет функцию ``news.views.month_archive(request, '2005', '03')``."

# 4129a80f378a4b1c940e46888cdeda2a
#: ../../topics/http/urls.txt:97
msgid ""
"``/articles/2005/3/`` would not match any URL patterns, because the third "
"entry in the list requires two digits for the month."
msgstr ""
"``/articles/2005/3/`` не соответствует ни одному URL-шаблону, потому что "
"третья запись требует две цифры в номере месяца."

# 0ddbce6f554b4546934dd09211163e45
#: ../../topics/http/urls.txt:100
msgid ""
"``/articles/2003/`` would match the first pattern in the list, not the "
"second one, because the patterns are tested in order, and the first one is "
"the first test to pass. Feel free to exploit the ordering to insert special "
"cases like this."
msgstr ""
"``/articles/2003/`` соответствует первому выражению, не второму, потому что "
"шаблоны проверяются по порядку. Не стесняйтесь использовать порядок для "
"обработки различных ситуация, таких как эта."

# 14d3603798ba4393a3420959eb39ffb6
#: ../../topics/http/urls.txt:105
msgid ""
"``/articles/2003`` would not match any of these patterns, because each "
"pattern requires that the URL end with a slash."
msgstr ""
"``/articles/2003`` не соответствует ни одному регулярному выражению, потому "
"что каждое ожидает, что URL оканчивается на слэш."

# bc2dd4603a304148814f4cc059c38519
#: ../../topics/http/urls.txt:108
msgid ""
"``/articles/2003/03/03/`` would match the final pattern. Django would call "
"the function ``news.views.article_detail(request, '2003', '03', '03')``."
msgstr ""
"``/articles/2003/03/03/`` соответствует последнему выражению. Django вызовет "
"функцию ``news.views.article_detail(request, '2003', '03', '03')``."

# e1197d6592724a6c92ce4a74aa6b6153
#: ../../topics/http/urls.txt:114
msgid "Named groups"
msgstr "Именованные группы"

# c7bc17c011da45cea8f9f6bf1107461d
#: ../../topics/http/urls.txt:116
msgid ""
"The above example used simple, *non-named* regular-expression groups (via "
"parenthesis) to capture bits of the URL and pass them as *positional* "
"arguments to a view. In more advanced usage, it's possible to use *named* "
"regular-expression groups to capture URL bits and pass them as *keyword* "
"arguments to a view."
msgstr ""
"Пример выше использует простые, *не именованные* группы совпадений в "
"регулярных выражениях (то, что в скобках) что бы получить значения из URL и "
"передать в представление как *позиционные* аргументы. Но вы можете "
"использовать *имена* для групп и значения будут передаваться как "
"*именованные* аргументы."

# ada1f57789b24c208dddb5045df3aa82
#: ../../topics/http/urls.txt:122
msgid ""
"In Python regular expressions, the syntax for named regular-expression "
"groups is ``(?P<name>pattern)``, where ``name`` is the name of the group and "
"``pattern`` is some pattern to match."
msgstr ""
"Для регулярных выражений в Python синтаксис для именованных совпадений "
"выглядит таким образом ``(?P<name>pattern)``, где ``name`` это название "
"группы, а ``pattern`` -- шаблон."

# f2beb7363a8d43da8d4fc1d6b0ba2e2b
#: ../../topics/http/urls.txt:126
msgid "Here's the above example URLconf, rewritten to use named groups::"
msgstr ""
"Вот пример конфигурации URL, переписанный с использованием именованных "
"групп::"

# 71c17e897e514ec5847da40f9f798ebb
#: ../../topics/http/urls.txt:135
msgid ""
"This accomplishes exactly the same thing as the previous example, with one "
"subtle difference: The captured values are passed to view functions as "
"keyword arguments rather than positional arguments. For example:"
msgstr ""
"Он выполняет то же самое, что и предыдущий пример, с одним небольшим "
"отличием: полученные значения передаются в представление как именованные "
"аргументы, а не позиционные. Например:"

# 96355635375e4354873544e2fc43cb39
#: ../../topics/http/urls.txt:139
msgid ""
"A request to ``/articles/2005/03/`` would call the function ``news.views."
"month_archive(request, year='2005', month='03')``, instead of ``news.views."
"month_archive(request, '2005', '03')``."
msgstr ""
"Запрос к ``/articles/2005/03/`` вызовет функцию ``news.views.month_archive"
"(request, year='2005', month='03')``, вместо ``news.views.month_archive"
"(request, '2005', '03')``."

# 153391f6b3f141d18687cfa27e85c213
#: ../../topics/http/urls.txt:143
msgid ""
"A request to ``/articles/2003/03/03/`` would call the function ``news.views."
"article_detail(request, year='2003', month='03', day='03')``."
msgstr ""
"Запрос к ``/articles/2003/03/03/`` вызовет ``news.views.article_detail"
"(request, year='2003', month='03', day='03')``."

# 0e081d65d6e349748164e3f0ea5a040c
#: ../../topics/http/urls.txt:146
msgid ""
"In practice, this means your URLconfs are slightly more explicit and less "
"prone to argument-order bugs -- and you can reorder the arguments in your "
"views' function definitions. Of course, these benefits come at the cost of "
"brevity; some developers find the named-group syntax ugly and too verbose."
msgstr ""
"На практике это означает, что ваша конфигурация URL более понятна и меньше "
"зависит от ошибки в порядке аргументов, так же вы можете изменять порядок "
"аргументов в представлении. Конечно, эти преимущества достигаются за счет "
"краткости, некоторые разработчики считают именованные группы уродливыми и "
"слишком многословными."

# a914fa737fae4e1483c011878abb3516
#: ../../topics/http/urls.txt:152
msgid "The matching/grouping algorithm"
msgstr "Алгоритм соответствия/группировки"

# 8a614b967feb45f79582619b2d1c423c
#: ../../topics/http/urls.txt:154
msgid ""
"Here's the algorithm the URLconf parser follows, with respect to named "
"groups vs. non-named groups in a regular expression:"
msgstr ""
"Вот алгоритм, которому следует синтаксический анализатор конфигурации URL, "
"для определения использовать значения именованных или не именованных "
"совпадений:"

# 2a0423ff6c60439099242dd7bc298952
#: ../../topics/http/urls.txt:157
msgid ""
"If there are any named arguments, it will use those, ignoring non-named "
"arguments. Otherwise, it will pass all non-named arguments as positional "
"arguments."
msgstr ""
"Если существует именованный аргумент, он будет использован вместо "
"позиционного аргумента. В противном случае, все аргументы будет переданы как "
"позиционные."

# 0dd49926e3444fe9adc9ae06cd74e8a9
#: ../../topics/http/urls.txt:160
msgid ""
"In both cases, it will pass any extra keyword arguments as keyword "
"arguments. See \"Passing extra options to view functions\" below."
msgstr ""
"В любом случае дополнительные именованные аргументы будут переданы как "
"именованные. Смотрите `Passing extra options to view functions`_ ниже."

# b871768b0b674192abdff8df2fd80354
#: ../../topics/http/urls.txt:164
msgid "What the URLconf searches against"
msgstr "Что использует URLconf при поиске нужного шаблона URL"

# a106db71a6b54a7e98a06bdae72e30be
#: ../../topics/http/urls.txt:166
msgid ""
"The URLconf searches against the requested URL, as a normal Python string. "
"This does not include GET or POST parameters, or the domain name."
msgstr ""
"URLconf использует запрашиваемый URL как обычную строку Python. Он не "
"учитывает параметры GET, POST и имя домена."

# 127285e2224b41b3b21c38b8e80eb71f
#: ../../topics/http/urls.txt:169
msgid ""
"For example, in a request to ``http://www.example.com/myapp/``, the URLconf "
"will look for ``myapp/``."
msgstr ""
"Например, при запросе к ``http://www.example.com/myapp/``, URLconf возьмет "
"``myapp/``."

# 64a2c332cc0447838ffe0149bc36d178
#: ../../topics/http/urls.txt:172
msgid ""
"In a request to ``http://www.example.com/myapp/?page=3``, the URLconf will "
"look for ``myapp/``."
msgstr "При запросе к ``http://www.example.com/myapp/?page=3`` -- ``myapp/``."

# c2ae9a9690634379bad9ca6456a1867d
#: ../../topics/http/urls.txt:175
msgid ""
"The URLconf doesn't look at the request method. In other words, all request "
"methods -- ``POST``, ``GET``, ``HEAD``, etc. -- will be routed to the same "
"function for the same URL."
msgstr ""
"URLconf не учитывает тип запроса. Другими словами, все типы запросов -- "
"``POST``, ``GET``, ``HEAD``, и др. -- будут обработаны одним представлением "
"при одинаковом URL."

# 261666c18648414caed8c8256b30dbf3
#: ../../topics/http/urls.txt:180
msgid "Syntax of the urlpatterns variable"
msgstr "Синтаксис переменной urlpatterns"

# 7751f0c3f99c456cbef140eb60b2d893
#: ../../topics/http/urls.txt:182
msgid ""
"``urlpatterns`` should be a Python list, in the format returned by the "
"function :func:`django.conf.urls.patterns`. Always use ``patterns()`` to "
"create the ``urlpatterns`` variable."
msgstr ""
"``urlpatterns`` должен быть списком Python, в формате, возвращаемом "
"функцией :func:`django.conf.urls.patterns`. Всегда используйте ``patterns()"
"`` для определения переменной ``urlpatterns``."

# ca9ff3f4e93b4a28a7d73a933765cfa9
#: ../../topics/http/urls.txt:187
msgid "``django.conf.urls`` utility functions"
msgstr "Функции модуля ``django.conf.urls``"

# e40f8ab7417a4b078aed6b23651db1ba
#: ../../topics/http/urls.txt:196
msgid ""
"Until Django 1.3 they were located in ``django.conf.urls.defaults``. You "
"still can import them from there but it will be removed in Django 1.6."
msgstr ""
"До Django 1.3 они находились в ``django.conf.urls.defaults``. Вы можете "
"использовать этот модуль до Django 1.6."

# 25f9ecd113794d54bf6835b6ca44d3c6
#: ../../topics/http/urls.txt:200
msgid "patterns"
msgstr "patterns"

# a4ba7e69cca14fb388ad11cb2580dd53
#: ../../topics/http/urls.txt:204
msgid ""
"A function that takes a prefix, and an arbitrary number of URL patterns, and "
"returns a list of URL patterns in the format Django needs."
msgstr ""
"Функция, которая принимает префикс и произвольное количество URL-шаблонов, и "
"возвращает список URL-шаблонов в необходимом формате."

# c80825be7da74a4ab7b9d3d063c3c9de
#: ../../topics/http/urls.txt:207
msgid ""
"The first argument to ``patterns()`` is a string ``prefix``. See `The view "
"prefix`_ below."
msgstr ""
"Первый аргумент ``patterns()`` это строка ``prefix``. Смотрите `The view "
"prefix`_ ниже."

# e8247593a21a42f8a6fcffd5da06695a
#: ../../topics/http/urls.txt:210
msgid "The remaining arguments should be tuples in this format::"
msgstr "Остальные аргументы должны быть кортежами в таком формате::"

# e243ebbb0d6c4c54a61365e8a6cbf21a
#: ../../topics/http/urls.txt:214
msgid ""
"...where ``optional dictionary`` and ``optional name`` are optional. (See "
"`Passing extra options to view functions`_ below.)"
msgstr ""
"...где ``optional dictionary`` и ``optional name`` не обязательны. (Смотрите "
"`Passing extra options to view functions`_ ниже.)"

# 8ed0cf8723c94f3d861a840cf723a646
#: ../../topics/http/urls.txt:218
msgid ""
"Because `patterns()` is a function call, it accepts a maximum of 255 "
"arguments (URL patterns, in this case). This is a limit for all Python "
"function calls. This is rarely a problem in practice, because you'll "
"typically structure your URL patterns modularly by using `include()` "
"sections. However, on the off-chance you do hit the 255-argument limit, "
"realize that `patterns()` returns a Python list, so you can split up the "
"construction of the list."
msgstr ""
"Так как `patterns()` это вызов функции, максимальное количество аргументов "
"равно 255 (URL-шаблонов в этом случае). Это ограничение функций в Python. "
"Вряд ли это будет проблемой, так как лучше использовать модульную структуру, "
"разбивая их на группы с помощью функции `include()`. Если вам все таки "
"удалось достичь предела в 255 аргументов, помните, что `patterns()` "
"возвращает список, который вы можете объединить с другим списком."

# 5b93c2fb6c7e4669a5d23acd4a2ea59f
#: ../../topics/http/urls.txt:235
msgid ""
"Python lists have unlimited size, so there's no limit to how many URL "
"patterns you can construct. The only limit is that you can only create 254 "
"at a time (the 255th argument is the initial prefix argument)."
msgstr ""
"Список не имеет ограничения на количество элементов и вы можете создать "
"любое количество URL-шаблонов. Единственное ограничение -- вы можете создать "
"только 254 за один вызов функции (255-ый аргумент это префикс)."

# 52867cb1c603478ab32f1e75d1a963b5
#: ../../topics/http/urls.txt:240
msgid "url"
msgstr "url"

# 0c614ff47aed4d1f8d8fe619e5cc557c
#: ../../topics/http/urls.txt:244
msgid ""
"You can use the ``url()`` function, instead of a tuple, as an argument to "
"``patterns()``. This is convenient if you want to specify a name without the "
"optional extra arguments dictionary. For example::"
msgstr ""
"Вы можете использовать функцию ``url()`` вместо кортежа в качестве аргумента "
"``patterns()``. Это удобно, если вы хотите указать название без словаря "
"дополнительных аргументов. Например::"

# 0a47b6c48a064f64920e6f88cb0102de
#: ../../topics/http/urls.txt:253
msgid "This function takes five arguments, most of which are optional::"
msgstr ""
"Эта функция принимает пять аргументов большинство из которых не обязательны::"

# 2266f7d2cc144c2b8c4c340841d2e4fc
#: ../../topics/http/urls.txt:257
msgid "See `Naming URL patterns`_ for why the ``name`` parameter is useful."
msgstr ""
"Почему параметр ``name`` полезен читайте в разделе о `Именованных шаблонах "
"URL <naming-url-patterns>`_."

# 09db44536bd0456f98e7a5770f036983
#: ../../topics/http/urls.txt:259
msgid ""
"The ``prefix`` parameter has the same meaning as the first argument to "
"``patterns()`` and is only relevant when you're passing a string as the "
"``view`` parameter."
msgstr ""
"Параметр ``prefix`` аналогичен первому аргументу ``patterns()`` и уместен "
"только, если параметр ``view`` определяется строкой."

# 5af34d804b5341409796874b0618aac8
#: ../../topics/http/urls.txt:264
msgid "include"
msgstr "include"

# 6449a4f357cc438e94d9a9655ab17f7c
#: ../../topics/http/urls.txt:268
msgid ""
"A function that takes a full Python import path to another URLconf module "
"that should be \"included\" in this place."
msgstr ""
"Функция, которая принимает полный путь к другому модулю URLconf для импорта, "
"этот модуль должен быть \"включен\" в месте вызова функции."

# 33112ff15eaa481997fc2f9b4ce66b15
#: ../../topics/http/urls.txt:271
msgid ""
":func:`include` also accepts as an argument an iterable that returns URL "
"patterns."
msgstr ""
":func:`include` так же может принимаьб в качестве параметра итератор, "
"который возвращает шаблоны URL."

# 2ae47791c61c43e18bb3f2a0cf77bef1
#: ../../topics/http/urls.txt:274
msgid "See `Including other URLconfs`_ below."
msgstr "Смотрите `Including other URLconfs`_ ниже."

# aa77f0e182df4239a1eae76d7f84e3c1
#: ../../topics/http/urls.txt:277
msgid "Error handling"
msgstr "Обработчики ошибок"

# 6d972bd8b1be4c8e8620aa141356a654
#: ../../topics/http/urls.txt:279
msgid ""
"When Django can't find a regex matching the requested URL, or when an "
"exception is raised, Django will invoke an error-handling view. The views to "
"use for these cases are specified by three variables which can be set in "
"your root URLconf. Setting these variables in any other URLconf will have no "
"effect."
msgstr ""
"Если Django не может найти подходящий шаблон URL, или было вызвано "
"исключение в процессе обработки запроса, Django вызовет соответствующее "
"представление обрабатывающее ошибку. Эти представления определяются "
"переменными в корневом URLconf. Определение этих переменных в любом другом "
"URLconf не будут иметь никакого эффекта."

# c75a6dcf875d47e993eaa2455616abd7
#: ../../topics/http/urls.txt:285
msgid ""
"See the documentation on :ref:`customizing error views <customizing-error-"
"views>` for more details."
msgstr ""
"Подробности в разделе о :ref:`переопределении обработчика ошибок "
"<customizing-error-views>`."

# 85e66838991d46e49579fc87137be55c
#: ../../topics/http/urls.txt:289
msgid "handler403"
msgstr "handler403"

# fa621fc243d54fe2ac558ee6897c88f4
#: ../../topics/http/urls.txt:293
msgid ""
"A callable, or a string representing the full Python import path to the view "
"that should be called if the user doesn't have the permissions required to "
"access a resource."
msgstr ""
"Функция, или полный путь для импорта, которая будет вызвана, если у "
"пользователя нет доступа к ресурсу."

# 0bd71f32e14f488c9f9b650b65a0e065
#: ../../topics/http/urls.txt:297
msgid ""
"By default, this is ``'django.views.defaults.permission_denied'``. That "
"default value should suffice."
msgstr ""
"По-умолчанию, это ``'django.views.defaults.permission_denied'``. Этого "
"обработчика будет достаточно в большинстве случаев."

# e2f532e89d6c4f529af3eb0e3d2a601f
#: ../../topics/http/urls.txt:300
msgid ""
"See the documentation about :ref:`the 403 (HTTP Forbidden) view "
"<http_forbidden_view>` for more information."
msgstr ""
"Смотрите раздел о :ref:`представлении обрабатывающем 403 (HTTP Forbidden) "
"<http_forbidden_view>`."

# 8ac9a2cfb2f8486195b524904c61fa47
#: ../../topics/http/urls.txt:307
msgid "handler404"
msgstr "handler404"

# 169ad2c1bed14d46b0f2f9665d7aa163
#: ../../topics/http/urls.txt:311
msgid ""
"A callable, or a string representing the full Python import path to the view "
"that should be called if none of the URL patterns match."
msgstr ""
"Функция, или полный путь для импорта, которая будет вызвана, если не был "
"найден подходящий URL-шаблон."

# fcd78f9b2f6445d193325f4beef95f43
#: ../../topics/http/urls.txt:314
msgid ""
"By default, this is ``'django.views.defaults.page_not_found'``. That default "
"value should suffice."
msgstr ""
"По-умолчанию, это ``'django.views.defaults.page_not_found'``. Этого "
"обработчика будет достаточно в большинстве случаев."

# 9c5baa8a5abf4c43a7889412dca2a184
#: ../../topics/http/urls.txt:321
msgid "handler500"
msgstr "handler500"

# 107d47ddc30c487ea43d3fbc84a53197
#: ../../topics/http/urls.txt:325
msgid ""
"A callable, or a string representing the full Python import path to the view "
"that should be called in case of server errors. Server errors happen when "
"you have runtime errors in view code."
msgstr ""
"Функция, или полный путь для импорта, которая будет вызвана при исключении в "
"процессе обработки запроса. "

# ee3ceb7f2e1443528cedc436dcba04db
#: ../../topics/http/urls.txt:329
msgid ""
"By default, this is ``'django.views.defaults.server_error'``. That default "
"value should suffice."
msgstr ""
"По-умолчанию, это ``'django.views.defaults.server_error'``. Этого "
"обработчика будет достаточно в большинстве случаев."

# 875af8403096400ba182a69467ec132f
#: ../../topics/http/urls.txt:336
msgid "Notes on capturing text in URLs"
msgstr "Особенности нахождении аргументов в URL"

# 1dca15e4d9c54a28a2a544cd56669c02
#: ../../topics/http/urls.txt:338
msgid ""
"Each captured argument is sent to the view as a plain Python string, "
"regardless of what sort of match the regular expression makes. For example, "
"in this URLconf line::"
msgstr ""
"Каждый найденный аргумент передается в представление как строка, независимо "
"от того, какое \"совпадение\" определено в регулярном выражении. Например, "
"URLconf содержит такую строку::"

# 35e185e6d15c44558b68af0ca7670ccd
#: ../../topics/http/urls.txt:344
msgid ""
"...the ``year`` argument to ``news.views.year_archive()`` will be a string, "
"not an integer, even though the ``\\d{4}`` will only match integer strings."
msgstr ""
"...аргумент ``year`` для ``news.views.year_archive()`` будет строкой, "
"несмотря на ``\\d{4}``."

# 65b67011e98a4fa78dcf095d1a8994d7
#: ../../topics/http/urls.txt:347
msgid ""
"A convenient trick is to specify default parameters for your views' "
"arguments. Here's an example URLconf and view::"
msgstr ""
"Принято указывать значения по-умолчанию для аргументов представления. Пример "
"URLconf и представления::"

# 5e1ede5dd84045ab96ba9cb286a46030
#: ../../topics/http/urls.txt:360
msgid ""
"In the above example, both URL patterns point to the same view -- ``blog."
"views.page`` -- but the first pattern doesn't capture anything from the URL. "
"If the first pattern matches, the ``page()`` function will use its default "
"argument for ``num``, ``\"1\"``. If the second pattern matches, ``page()`` "
"will use whatever ``num`` value was captured by the regex."
msgstr ""
"В примере выше, оба URL-шаблона указывают на одно представление -- ``blog."
"views.page`` -- но первый шаблон не принимает аргументы в URL. Если первый "
"шаблон будет выбран, функция ``page()`` будет использовать значение по-"
"умолчанию аргумента ``num`` равное ``\"1\"``. Если будет выбран другой "
"шаблон, ``page()`` будет использовать значение ``num`` из URL, которое "
"найдет регулярное выражение."

# 858c260216d04239ae52bacc18b66925
#: ../../topics/http/urls.txt:367
msgid "Performance"
msgstr "Производительность"

# 1eb58843b8454ee6b0288af55205990e
#: ../../topics/http/urls.txt:369
msgid ""
"Each regular expression in a ``urlpatterns`` is compiled the first time it's "
"accessed. This makes the system blazingly fast."
msgstr ""
"Каждое регулярное выражение в ``urlpatterns`` будет скомпилировано при "
"первом использовании. Это делает систему невероятно быстрой."

# 40b56a6070ec4f548c0a0b30579777cd
#: ../../topics/http/urls.txt:373
msgid "The view prefix"
msgstr "Префикс представления"

# 896b967fd4a243489ffbd2b847a57caf
#: ../../topics/http/urls.txt:375
msgid ""
"You can specify a common prefix in your ``patterns()`` call, to cut down on "
"code duplication."
msgstr ""
"Вы можете указать общий префикс при вызове ``patterns()`` что бы сократить "
"дублирование кода."

# ba3218fda74644599bf84d08d03847d1
#: ../../topics/http/urls.txt:378
msgid ""
"Here's the example URLconf from the :doc:`Django overview </intro/"
"overview>`::"
msgstr "Вот пример URLconf из :doc:`обзора Django </intro/overview>`::"

# 24da6c6d5e0f4c0fbc2c57f1d1dfc607
#: ../../topics/http/urls.txt:388
msgid ""
"In this example, each view has a common prefix -- ``'news.views'``. Instead "
"of typing that out for each entry in ``urlpatterns``, you can use the first "
"argument to the ``patterns()`` function to specify a prefix to apply to each "
"view function."
msgstr ""
"В этом пример, каждое представление содержит общий префикс -- ``'news."
"views'``. Вместо того, что бы писать его для каждой записи ``urlpatterns``, "
"вы можете указать его первым аргументом функции ``patterns()``."

# c8ef7a5d95cf49ad8c69ddb3c3d1c7dd
#: ../../topics/http/urls.txt:393
msgid "With this in mind, the above example can be written more concisely as::"
msgstr "Теперь можно переписать пример выше::"

# c735e8e5c1a643d5b0233ac956d3b6fe
#: ../../topics/http/urls.txt:403
msgid ""
"Note that you don't put a trailing dot (``\".\"``) in the prefix. Django "
"puts that in automatically."
msgstr ""
"Заметим что в конце префикса отсутствует точка (``\".\"``). Django "
"самостоятельно добавит ее."

# dc4b5aa7cdee4d1b976202d3b92d1c15
#: ../../topics/http/urls.txt:407
msgid "Multiple view prefixes"
msgstr "Несколько префиксов представления"

# 642dc5193a70454cadd46a26fc6b5af9
#: ../../topics/http/urls.txt:409
msgid ""
"In practice, you'll probably end up mixing and matching views to the point "
"where the views in your ``urlpatterns`` won't have a common prefix. However, "
"you can still take advantage of the view prefix shortcut to remove "
"duplication. Just add multiple ``patterns()`` objects together, like this:"
msgstr ""
"На практике, скорее всего представления в ``urlpatterns`` не буду содержать "
"общий префикс. Однако, вы все равно можете использовать общий префикс что бы "
"сократить дублирование кода. Просто используете несколько результатов вызова "
"``patterns()`` вместе:"

# 8517e13ed8054f0ab1d21c083a3c55bb
#: ../../topics/http/urls.txt:414
msgid "Old::"
msgstr "Раньше::"

# bd5aae80d4f142509e1581d4cc9ab103
#: ../../topics/http/urls.txt:424
msgid "New::"
msgstr "Теперь::"

# 6e8f5a3d7e53427a877351a6cf8687f1
#: ../../topics/http/urls.txt:438
msgid "Including other URLconfs"
msgstr "Комбинирование URLconfs"

# ce543103041c48d1b01e8aad527d3d4e
#: ../../topics/http/urls.txt:440
msgid ""
"At any point, your ``urlpatterns`` can \"include\" other URLconf modules. "
"This essentially \"roots\" a set of URLs below other ones."
msgstr ""
"В любой момент, ваш ``urlpatterns`` может \"включать\" другие модули URLconf."

# d7f670c2106f42caada9e2db2c9d9c89
#: ../../topics/http/urls.txt:443
msgid ""
"For example, here's an excerpt of the URLconf for the `Django Web site`_ "
"itself. It includes a number of other URLconfs::"
msgstr ""
"Вот пример URLconf для `сайта Django <http://www.djangoproject.com/>`_. Он "
"включает множество других конфигураций URL::"

# 8b43692a7bed41fea08ee8547b80e70e
#: ../../topics/http/urls.txt:457
msgid ""
"Note that the regular expressions in this example don't have a ``$`` (end-of-"
"string match character) but do include a trailing slash. Whenever Django "
"encounters ``include()``, it chops off whatever part of the URL matched up "
"to that point and sends the remaining string to the included URLconf for "
"further processing."
msgstr ""
"Заметим, что регулярные выражения не содержат ``$`` (определитель конца "
"строки), но содержит слэш в конце. Каждый раз, когда Django встречает "
"``include()``, из URL обрезается уже совпавшая часть, остальное передается "
"во включенный URLconf для дальнейшей обработки."

# 0a937c37f833455ba63d013112a12b86
#: ../../topics/http/urls.txt:463
msgid ""
"Another possibility is to include additional URL patterns not by specifying "
"the URLconf Python module defining them as the `include`_ argument but by "
"using directly the pattern list as returned by `patterns`_ instead. For "
"example::"
msgstr ""
"Другой способ -- передать результат выполнения `patterns`_ вместо модуля "
"Python. Например::"

# 0fcd3c782822428996639208c2087345
#: ../../topics/http/urls.txt:480
msgid ""
"This approach can be seen in use when you deploy an instance of the Django "
"Admin application. The Django Admin is deployed as instances of a :class:"
"`~django.contrib.admin.AdminSite`; each :class:`~django.contrib.admin."
"AdminSite` instance has an attribute ``urls`` that returns the url patterns "
"available to that instance. It is this attribute that you ``include()`` into "
"your projects ``urlpatterns`` when you deploy the admin instance."
msgstr ""
"Такой подход используется при подключении приложения интерфейса "
"администратора(``admin``) Django. Для подключения используется экземпляр :"
"class:`~django.contrib.admin.AdminSite`, каждый из которых содержит свойство "
"``urls``. Оно возвращает URL-шаблоны, которые доступные для этого "
"экземпляра. Это то свойство, которое вы добавляете, используя ``include()``, "
"в  ``urlpatterns`` вашего проекта при установке приложения администратора."

# 92e201aaed794bb1a91e2a1968a52f2d
#: ../../topics/http/urls.txt:491
msgid "Captured parameters"
msgstr "Нахождение аргументов в URL"

# 6753ae947d4147b2a115a676350526cf
#: ../../topics/http/urls.txt:493
msgid ""
"An included URLconf receives any captured parameters from parent URLconfs, "
"so the following example is valid::"
msgstr ""
"Включенный URLconf получает все аргументы найденные родительским URLconfs, "
"по этому этот пример работает::"

# a5b43b2d81b24fe4b3a5900323f27757
#: ../../topics/http/urls.txt:507
msgid ""
"In the above example, the captured ``\"username\"`` variable is passed to "
"the included URLconf, as expected."
msgstr ""
"В примере выше, найденный аргумент ``\"username\"`` передается во включенный "
"URLconf, как и ожидалось."

# 9be6dca660e946dc96bef98ac8b5713d
#: ../../topics/http/urls.txt:513
msgid "Defining URL namespaces"
msgstr "Пространства имен"

# 3a6abf87e6cb468086803751ef325dc5
#: ../../topics/http/urls.txt:515
msgid ""
"When you need to deploy multiple instances of a single application, it can "
"be helpful to be able to differentiate between instances. This is especially "
"important when using :ref:`named URL patterns <naming-url-patterns>`, since "
"multiple instances of a single application will share named URLs. Namespaces "
"provide a way to tell these named URLs apart."
msgstr ""
"Если необходимо использовать несколько экземпляров одного приложения, было "
"бы удобно иметь возможность различать их. Это особенно важно при "
"использовании :ref:`именованных шаблонов URL <naming-url-patterns>`, так как "
"несколько экземпляров используют одинаковые названия для URL-ов. "
"Пространства имен позволяют сделать эти названия уникальными."

# 8564d4d0edcc4355b741c81fbfee8b44
#: ../../topics/http/urls.txt:521
msgid "A URL namespace comes in two parts, both of which are strings:"
msgstr ""
"Пространство имен состоит из двух частей, каждая из которых это строка:"

# 04864b70a0ad4532a65d972beaabcee9
#: ../../topics/http/urls.txt:523
msgid ""
"An **application namespace**. This describes the name of the application "
"that is being deployed. Every instance of a single application will have the "
"same application namespace. For example, Django's admin application has the "
"somewhat predictable application namespace of ``admin``."
msgstr ""
"**Название(пространство имен) приложения**. Указывает название "
"установленного приложения. Все экземпляры одного приложения будет иметь одно "
"название. Например, название приложения администратора Django -- ``admin``."

# 343b9502cdac4e0f971dec04a743cd9a
#: ../../topics/http/urls.txt:528
msgid ""
"An **instance namespace**. This identifies a specific instance of an "
"application. Instance namespaces should be unique across your entire "
"project. However, an instance namespace can be the same as the application "
"namespace. This is used to specify a default instance of an application. For "
"example, the default Django Admin instance has an instance namespace of "
"``admin``."
msgstr ""
"**Название(пространство имен) экземпляра**. Идентифицирует конкретный "
"экземпляр приложения. Должно быть уникальным для проекта. Однако, название "
"экземпляра может быть равным названию приложения. Оно используется по-"
"умолчанию при создании приложения. Например, пространство имен приложения "
"администратора Django -- ``admin``."

# 3e8eeb7bb3e4413faf2861a3bc111d25
#: ../../topics/http/urls.txt:535
msgid "URL Namespaces can be specified in two ways."
msgstr "Пространство имен URL можно определить двумя путями."

# 41bbb924087e465ab7351becb2036397
#: ../../topics/http/urls.txt:537
msgid ""
"Firstly, you can provide the application and instance namespace as arguments "
"to ``include()`` when you construct your URL patterns. For example,::"
msgstr ""
"Первый, передав в качестве аргументов при вызове ``include()``. Например::"

# 1f9f3e7cb8a8476a876fb9f9957d0813
#: ../../topics/http/urls.txt:542
msgid ""
"This will include the URLs defined in ``apps.help.urls`` into the "
"application namespace ``bar``, with the instance namespace ``foo``."
msgstr ""
"Этот код добавляет URL-шаблоны определенные в ``apps.help.urls``, используя "
"название приложения ``bar`` и название экземпляра ``foo``."

# 939460af658044779d58aa573dc8705b
#: ../../topics/http/urls.txt:545
msgid ""
"Secondly, you can include an object that contains embedded namespace data. "
"If you ``include()`` a ``patterns`` object, that object will be added to the "
"global namespace. However, you can also ``include()`` an object that "
"contains a 3-tuple containing::"
msgstr ""
"Второй, вы можете добавить объект, который содержит все необходимые данные. "
"Если использовать результат ``patterns()`` при вызове функции ``include()``, "
"он будет добавлен в глобальное пространство имен. Однако, в ``include()`` "
"можно передать 3-элементный кортеж, который содержит::"

# 224c7b2eb26d4cb7acd235e90fbcabbc
#: ../../topics/http/urls.txt:552
msgid ""
"This will include the nominated URL patterns into the given application and "
"instance namespace. For example, the ``urls`` attribute of Django's :class:"
"`~django.contrib.admin.AdminSite` object returns a 3-tuple that contains all "
"the patterns in an admin site, plus the name of the admin instance, and the "
"application namespace ``admin``."
msgstr ""
"Например, свойство ``urls`` экземпляра :class:`~django.contrib.admin."
"AdminSite` возвращает 3-элементный кортеж, который содержит URL-шаблоны, "
"название экземпляра и название(пространство имен) приложения ``admin``."

# 7393ec72521047709f3b40123b1c9218
#: ../../topics/http/urls.txt:558
msgid ""
"Once you have defined namespaced URLs, you can reverse them. For details on "
"reversing namespaced urls, see the documentation on :ref:`reversing "
"namespaced URLs <topics-http-reversing-url-namespaces>`."
msgstr ""
"После определения пространства имен, вы можете использовать его для "
"нахождения URL-ов. Подробности смотрите в разделе о :ref:`нахождение URL-ов "
"с пространством имен <topics-http-reversing-url-namespaces>`."

# b2b2736313c548cd8c7d76ea42dcc30a
#: ../../topics/http/urls.txt:563
msgid "Passing extra options to view functions"
msgstr "Передача дополнительных аргументов в представление"

# 78cf611a86654220aa9b88c39b766c33
#: ../../topics/http/urls.txt:565
msgid ""
"URLconfs have a hook that lets you pass extra arguments to your view "
"functions, as a Python dictionary."
msgstr ""
"Конфигурация URL-ов позволяет определить дополнительные аргументы для "
"функции представления, используя словарь Python."

# 47f8727f4995461ba83343ba2192c658
#: ../../topics/http/urls.txt:568
msgid ""
"Any URLconf tuple can have an optional third element, which should be a "
"dictionary of extra keyword arguments to pass to the view function."
msgstr ""
"Каждый кортеж в URLconf может содержать третий необязательный элемент. Этот "
"элемент определяет дополнительные именованные аргументы для функции "
"представления."

# 0546db3de0ad4f2787bdd62427825eff
#: ../../topics/http/urls.txt:571
msgid "For example::"
msgstr "Например::"

# c8a9acd499bf42b1821971de37c0eb5b
#: ../../topics/http/urls.txt:577
msgid ""
"In this example, for a request to ``/blog/2005/``, Django will call the "
"``blog.views.year_archive()`` view, passing it these keyword arguments::"
msgstr ""
"Например, при запросе к ``/blog/2005/``, Django вызовет ``blog.views."
"year_archive()``, передавая эти именованные аргументы::"

# 72964d0c5c084ef3b82843fe8ed45eed
#: ../../topics/http/urls.txt:582
msgid ""
"This technique is used in :doc:`generic views </ref/generic-views>` and in "
"the :doc:`syndication framework </ref/contrib/syndication>` to pass metadata "
"and options to views."
msgstr ""
"Такой подход используется :doc:`общими представлениями </ref/generic-views>` "
"и :doc:`syndication framework </ref/contrib/syndication>` для передачи "
"параметров и дополнительных данных в представление."

# f90d4341a12d4766a0a1fed2b2ecc43c
#: ../../topics/http/urls.txt:588
msgid ""
"It's possible to have a URL pattern which captures named keyword arguments, "
"and also passes arguments with the same names in its dictionary of extra "
"arguments. When this happens, the arguments in the dictionary will be used "
"instead of the arguments captured in the URL."
msgstr ""
"Если регулярное выражение URL-шаблона выделяет из URL-а аргумент с "
"названием, которое уже используется в дополнительных именованных аргументах, "
"будет использован аргумент из словаря дополнительных аргументов, вместо "
"значения из URL."

# b10f757cff594fc2bf5fa49c7225bf55
#: ../../topics/http/urls.txt:594
msgid "Passing extra options to ``include()``"
msgstr "Передача дополнительных аргументов в ``include()``"

# 3f4d4226ad30422ab0ecfd6d14f16390
#: ../../topics/http/urls.txt:596
msgid ""
"Similarly, you can pass extra options to ``include()``. When you pass extra "
"options to ``include()``, *each* line in the included URLconf will be passed "
"the extra options."
msgstr ""
"Аналогично вы можете передать дополнительные аргументы в ``include()``. При "
"этом, *каждый* URL-шаблон включенного URLconf будет дополнен этими "
"дополнительными аргументами."

# 42098b4ed83547cfa4cdbb3ca842ad39
#: ../../topics/http/urls.txt:600
msgid "For example, these two URLconf sets are functionally identical:"
msgstr "Например, эти два URLconf работают идентично:"

# b24a132a808043508c3ea87b077bbf68
#: ../../topics/http/urls.txt:602
msgid "Set one::"
msgstr "Первый::"

# adf681d691c346e494bcf1b04755cab8
#: ../../topics/http/urls.txt:615
msgid "Set two::"
msgstr "Второй::"

# 88f079c65c4d446eb77b1d41db891999
#: ../../topics/http/urls.txt:628
msgid ""
"Note that extra options will *always* be passed to *every* line in the "
"included URLconf, regardless of whether the line's view actually accepts "
"those options as valid. For this reason, this technique is only useful if "
"you're certain that every view in the included URLconf accepts the extra "
"options you're passing."
msgstr ""
"Дополнительные аргументы *всегда* передаются *каждому* представлению во "
"включенном URLconf, независимо от того, принимает оно эти аргументы или нет. "
"По этому, такой подход полезен только если вы уверенны, что каждое "
"представление принимает передаваемые аргументы."

# b3167eb0046e483f8202f5f0a3034a6e
#: ../../topics/http/urls.txt:634
msgid "Passing callable objects instead of strings"
msgstr "Передача функций вместо строк"

# 814ce3d44967497eae0c09117bef9d13
#: ../../topics/http/urls.txt:636
msgid ""
"Some developers find it more natural to pass the actual Python function "
"object rather than a string containing the path to its module. This "
"alternative is supported -- you can pass any callable object as the view."
msgstr ""
"Некоторые разработчики предпочитают передавать функции вместо строк, "
"содержащих путь для импорта. Такой способ так же работает -- вы можете "
"передать любой вызываемый объект в качестве представлений."

# 1ec909fc44be42fd8c817b55f0a92058
#: ../../topics/http/urls.txt:640
msgid "For example, given this URLconf in \"string\" notation::"
msgstr "Например, у нас есть такой URLconf::"

# 0547250899224766abb8a6ec5795d16e
#: ../../topics/http/urls.txt:648
msgid ""
"You can accomplish the same thing by passing objects rather than strings. "
"Just be sure to import the objects::"
msgstr ""
"Вы можете сделать то же самое, передавая объекты вместо строк. Просто "
"импортируйте эти объекты::"

# f14d8cdd987f43beb994c0e9d96af0a5
#: ../../topics/http/urls.txt:659
msgid ""
"The following example is functionally identical. It's just a bit more "
"compact because it imports the module that contains the views, rather than "
"importing each view individually::"
msgstr ""
"Следующий пример работает аналогично. Он немного короче, потому что мы "
"импортируем модуль содержащий представления, а не каждое представление по "
"отдельности::"

# 25a54f46992740539051d7e45c2088d2
#: ../../topics/http/urls.txt:671
msgid "The style you use is up to you."
msgstr "Стиль, который вы используете, зависит от вас."

# 31697dbff4674953a63a44bd823beae7
#: ../../topics/http/urls.txt:673
msgid ""
"Note that if you use this technique -- passing objects rather than strings "
"-- the view prefix (as explained in \"The view prefix\" above) will have no "
"effect."
msgstr ""
"Стоит заметить, что при передаче объекта вместо строки, префикс для "
"представлений (описанный выше `The view prefix`_) не будет иметь никакого "
"эффекта."

# 34cf6780279c4de9ad2c06814f1efd12
#: ../../topics/http/urls.txt:679
msgid "Naming URL patterns"
msgstr "Именованные URL-шаблоны"

# 567b930166e94022b493d2fd072033a9
#: ../../topics/http/urls.txt:681
msgid ""
"It's fairly common to use the same view function in multiple URL patterns in "
"your URLconf. For example, these two URL patterns both point to the "
"``archive`` view::"
msgstr ""
"Обычная практика использовать одно представление для нескольких URL-шаблонов "
"в URLconf. Например, эти два URL-шаблона указывают на представление "
"``archive``::"

# bd7a27eef8c44d5281f5c5833026be04
#: ../../topics/http/urls.txt:690
msgid ""
"This is completely valid, but it leads to problems when you try to do "
"reverse URL matching (through the ``permalink()`` decorator or the :ttag:"
"`url` template tag). Continuing this example, if you wanted to retrieve the "
"URL for the ``archive`` view, Django's reverse URL matcher would get "
"confused, because *two* URL patterns point at that view."
msgstr ""
"Этот пример работает, но, если вы захотите найти URL (используя декоратор "
"``permalink()`` или тег шаблона :ttag:`url`), это приведет к проблемам. Если "
"вы захотите получить URL для представления ``archive``, Django запутается "
"так как *два* URL-шаблона соответствуют одному представлению."

# 713f8edfed024beb86cb384e08a8f6e8
#: ../../topics/http/urls.txt:696
msgid ""
"To solve this problem, Django supports **named URL patterns**. That is, you "
"can give a name to a URL pattern in order to distinguish it from other "
"patterns using the same view and parameters. Then, you can use this name in "
"reverse URL matching."
msgstr ""
"Для решения этой проблемы, Django предоставляет **именованные URL-шаблоны**. "
"То есть, вы можете дать название для URL-шаблонов что бы отличать их и "
"использовать эти названия при поиске нужного вам URL-а."

# 27f7c2bb6a8b4a00a0ed20b1cdb18dbb
#: ../../topics/http/urls.txt:701
msgid "Here's the above example, rewritten to use named URL patterns::"
msgstr "Перепишем пример выше с использованием именованных URL-шаблонов::"

# f13201346f2649ffb85ae2398dfe51b1
#: ../../topics/http/urls.txt:708
msgid ""
"With these names in place (``full-archive`` and ``arch-summary``), you can "
"target each pattern individually by using its name:"
msgstr ""
"Используя эти названия (``full-archive`` и ``arch-summary``), вы можете "
"обратиться к каждому URL-шаблону отдельно:"

# 4229a4eb356043b6b53585a65222b006
#: ../../topics/http/urls.txt:716
msgid ""
"Even though both URL patterns refer to the ``archive`` view here, using the "
"``name`` parameter to ``url()`` allows you to tell them apart in templates."
msgstr ""
"Хоть оба URL-шаблона ссылаются на одно представление ``archive``, "
"использование параметра ``name`` в теге ``url()`` позволит вам различить их "
"в шаблоне."

# 60bac55c29c34734a8b5dd6241af5f3f
#: ../../topics/http/urls.txt:719
msgid ""
"The string used for the URL name can contain any characters you like. You "
"are not restricted to valid Python names."
msgstr "Вы можете использовать любые символы в названии."

# 14723fa60d674503b153eb1ca381d3af
#: ../../topics/http/urls.txt:724
msgid ""
"When you name your URL patterns, make sure you use names that are unlikely "
"to clash with any other application's choice of names. If you call your URL "
"pattern ``comment``, and another application does the same thing, there's no "
"guarantee which URL will be inserted into your template when you use this "
"name."
msgstr ""
"При выборе названия для URL-шаблона, убедитесь что оно достаточно уникально. "
"Если вы назовете URL-шаблон ``comment``, и другое приложение сделает "
"аналогичное, нет гарантии что в шаблон будет вставлен правильный URL."

# 309eff09cb8247ceb2af18bcec659976
#: ../../topics/http/urls.txt:730
msgid ""
"Putting a prefix on your URL names, perhaps derived from the application "
"name, will decrease the chances of collision. We recommend something like "
"``myapp-comment`` instead of ``comment``."
msgstr ""
"Добавление префикса к названию URL-шаблона, возможного состоящего из "
"названия приложения, уменьшит шанс конфликта. Мы советуем использовать "
"``myapp-comment`` вместо ``comment``."

# 92f63802982e425a83b2ea2cf0e45444
#: ../../topics/http/urls.txt:737
msgid "URL namespaces"
msgstr "Пространства имен в конфигурации URL-ов"

# 14ef8de1e76a40ddbaa40fc9cbc9d4f1
#: ../../topics/http/urls.txt:739
msgid ""
"Namespaced URLs are specified using the ``:`` operator. For example, the "
"main index page of the admin application is referenced using ``admin:"
"index``. This indicates a namespace of ``admin``, and a named URL of "
"``index``."
msgstr ""
"Пространство имен определяется с помощью оператора ``:``. Например, главная "
"страница интерфейса администратора определяется как ``admin:index``. Мы "
"видим пространство имен ``admin``, и название URL-шаблона ``index``."

# dd0beb185dda4037a57e82d5dc638d0d
#: ../../topics/http/urls.txt:743
msgid ""
"Namespaces can also be nested. The named URL ``foo:bar:whiz`` would look for "
"a pattern named ``whiz`` in the namespace ``bar`` that is itself defined "
"within the top-level namespace ``foo``."
msgstr ""
"Пространства имен могут быть вложенными. Название URL-а ``foo:bar:whiz`` "
"означает именованный URL-шаблон с названием ``whiz`` в пространстве имен "
"``bar``, которое было определенно в другом пространстве имен - ``foo``."

# 83542e06d4c0423ab8f1bd4a83ef08eb
#: ../../topics/http/urls.txt:747
msgid ""
"When given a namespaced URL (e.g. ``myapp:index``) to resolve, Django splits "
"the fully qualified name into parts, and then tries the following lookup:"
msgstr ""
"Если необходимо найти URL по названию (например, ``myapp:index``), Django "
"разбивает название на части и следует такому алгоритму:"

# 8961ae51f16347ff8b70c775b996abb6
#: ../../topics/http/urls.txt:750
msgid ""
"First, Django looks for a matching application namespace (in this example, "
"``myapp``). This will yield a list of instances of that application."
msgstr ""
"Первым делом, Django ищет список экземпляров приложения по указанному "
"пространству имен (например, ``myapp``). *(То есть ищет все вложенные "
"URLconf с аналогичным названием(пространством имен) приложения - прим. "
"переводчика.)*"

# 998245c1af554383854ef043ca51ae28
#: ../../topics/http/urls.txt:754
msgid ""
"If there is a *current* application defined, Django finds and returns the "
"URL resolver for that instance. The *current* application can be specified "
"as an attribute on the template context - applications that expect to have "
"multiple deployments should set the ``current_app`` attribute on any "
"``Context`` or ``RequestContext`` that is used to render a template."
msgstr ""
"Если указан *текущий* экземпляр приложения, Django вернет \"URL resolver\" "
"для этого экземпляра. *Текущий* экземпляр приложения можно указать используя "
"атрибут ``current_app` контекста шаблона. Приложения, которые будут "
"использоваться в нескольких экземплярах в одном проекте, должны всегда "
"определять атрибут ``current_app`` для ``Context`` или ``RequestContext``, "
"который используется для выполнения шаблона."

# 225786f8ff194241a0870be14b65103b
#: ../../topics/http/urls.txt:761
msgid ""
"The current application can also be specified manually as an argument to "
"the :func:`reverse()` function."
msgstr ""
"Текущей экземпляр приложения можно так же определить используя аргумент при "
"вызове функции :func:`reverse()`."

# 6c884ad3de5542f8a98cf56e9687b0d7
#: ../../topics/http/urls.txt:764
msgid ""
"If there is no current application. Django looks for a default application "
"instance. The default application instance is the instance that has an "
"instance namespace matching the application namespace (in this example, an "
"instance of the ``myapp`` called ``myapp``)."
msgstr ""
"Если текущий экземпляр приложения не найден, Django попытается использовать "
"экземпляр по-умолчанию. Экземпляр по-умолчанию -- это экземпляр, у которого "
"название приложения и название экземпляра приложения совпадают (в нашем "
"примере это экземпляр ``myapp`` с названием ``myapp``)."

# 86ca11bff43f4a3daabeabc0a7c7e2e5
#: ../../topics/http/urls.txt:769
msgid ""
"If there is no default application instance, Django will pick the last "
"deployed instance of the application, whatever its instance name may be."
msgstr ""
"Если экземпляр по-умолчанию не найден, Django возьмет последний "
"установленный экземпляр приложения, не обращая внимание на его название."

# 2fbf1280565149daa69184349b4daa83
#: ../../topics/http/urls.txt:772
msgid ""
"If the provided namespace doesn't match an application namespace in step 1, "
"Django will attempt a direct lookup of the namespace as an instance "
"namespace."
msgstr ""
"Если на первом шаге не было найдено приложение по указанному пространству "
"имен, Django попытается найти экземпляр приложения по его названию, "
"используя пространство имен как название экземпляра."

# 91c5534255134861a26e4fa234a8ef6b
#: ../../topics/http/urls.txt:776
msgid ""
"If there are nested namespaces, these steps are repeated for each part of "
"the namespace until only the view name is unresolved. The view name will "
"then be resolved into a URL in the namespace that has been found."
msgstr ""
"Если пространство имен вложенное, этот процесс будет повторен, пока "
"неопределенным не останется только название представления. URL для названия "
"представления будет искаться среди URL-шаблонов определенных в приложении, "
"найденном через пространство имен."

# d2932e82a8ff4612bf131f254d4e1662
#: ../../topics/http/urls.txt:780
msgid ""
"To show this resolution strategy in action, consider an example of two "
"instances of ``myapp``: one called ``foo``, and one called ``bar``. "
"``myapp`` has a main index page with a URL named `index`. Using this setup, "
"the following lookups are possible:"
msgstr ""
"Разберем небольшой пример. У нас есть два экземпляра приложения ``myapp``: "
"один назван ``foo``, другой - ``bar``. ``myapp`` содержит главную страницу с "
"названием URL-а `index`. Возможны  такие ситуации:"

# c4f1a0672065409a8b32ff890d82afec
# 28c4f462d1ee427c8f23024192015366
#: ../../topics/http/urls.txt:785 ../../topics/http/urls.txt:801
msgid ""
"If one of the instances is current - say, if we were rendering a utility "
"page in the instance ``bar`` - ``myapp:index`` will resolve to the index "
"page of the instance ``bar``."
msgstr ""
"Если один из экземпляров указан как текущий - например, мы выполняем шаблон "
"в экземпляре ``bar`` - поиск URL-а по ``myapp:index`` вернет URL на главную "
"страницу экземпляра приложения ``bar``."

# cccee5e92f1c426db57088f0800e0336
#: ../../topics/http/urls.txt:789
msgid ""
"If there is no current instance - say, if we were rendering a page somewhere "
"else on the site - ``myapp:index`` will resolve to the last registered "
"instance of ``myapp``. Since there is no default instance, the last instance "
"of ``myapp`` that is registered will be used. This could be ``foo`` or "
"``bar``, depending on the order they are introduced into the urlpatterns of "
"the project."
msgstr ""
"Если текущий экземпляр приложения не указан - например, мы ищем URL в другом "
"приложении -  поиск по ``myapp:index`` вернет URL для последнего "
"добавленного экземпляра ``myapp``. Это может быть ``foo`` или ``bar``, в "
"зависимости от того, в коком порядке они были добавлены в URL-шаблоны "
"проекта."

# 4ad351cd6e984156a65909f3aedcb529
#: ../../topics/http/urls.txt:796
msgid ""
"``foo:index`` will always resolve to the index page of the instance ``foo``."
msgstr ""
"Поиск по ``foo:index``всегда вернет ссылку на главную страницу экземпляра "
"приложения ``foo``."

# 85ce88d04cfd41a9bdad5af3b51d9bf7
#: ../../topics/http/urls.txt:798
msgid ""
"If there was also a default instance - i.e., an instance named `myapp` - the "
"following would happen:"
msgstr ""
"Если бы был определен экземпляр по-умолчанию - то есть, экземпляр с "
"названием `myapp`:"

# 5b055cb3dd4c43d2ada5fd3760104c6c
#: ../../topics/http/urls.txt:805
msgid ""
"If there is no current instance - say, if we were rendering a page somewhere "
"else on the site - ``myapp:index`` will resolve to the index page of the "
"default instance."
msgstr ""
"Если текущий экземпляр приложения не указан - например, мы ищем URL в другом "
"приложении - поиск по ``myapp:index`` вернет URL на главную страницу "
"экземпляра по-умолчанию."

# 6297298535fa48b8b6fa1e808b853cbc
#: ../../topics/http/urls.txt:809
msgid ""
"``foo:index`` will again resolve to the index page of the instance ``foo``."
msgstr ""
"Поиск по ``foo:index``все так же вернет ссылку на главную страницу "
"экземпляра приложения ``foo``."

# c7d64e28dc4e4d2c98296dccb80fc8c6
#: ../../topics/http/urls.txt:813
msgid "``django.core.urlresolvers`` utility functions"
msgstr "Функции модуля ``django.core.urlresolvers``"

# b175ae2819be4fca8204f187a993da56
#: ../../topics/http/urls.txt:818
msgid "reverse()"
msgstr "reverse()"

# 9a5e08c89a18457686698af1b84b6e51
#: ../../topics/http/urls.txt:820
msgid ""
"If you need to use something similar to the :ttag:`url` template tag in your "
"code, Django provides the following function (in the :mod:`django.core."
"urlresolvers` module):"
msgstr ""
"Если вам нужно использовать в коде функционал тега :ttag:`url`, Django "
"предоставляет ряд функций (в модуле :mod:`django.core.urlresolvers`):"

# 8eda6f8d47014bbbb7adb3c71a8c7a81
#: ../../topics/http/urls.txt:826
msgid ""
"``viewname`` is either the function name (either a function reference, or "
"the string version of the name, if you used that form in ``urlpatterns``) or "
"the `URL pattern name`_.  Normally, you won't need to worry about the "
"``urlconf`` parameter and will only pass in the positional and keyword "
"arguments to use in the URL matching. For example::"
msgstr ""
"``viewname`` -- это название функции (либо определение функции, либо путь "
"путь для импорта, зависит что вы использовали в ``urlpatterns``) или :ref:"
"`название URL-шаблона <naming-url-patterns>`.  Скорее всего вам не придется "
"использовать аргумент ``urlconf`` и все что вам нужно, это добавить "
"позиционные и именованные аргументы что бы найти определенный URL. Например::"

# c4dfd09eb88544e6bf3a662958210c2f
#: ../../topics/http/urls.txt:839
msgid ""
"The ``reverse()`` function can reverse a large variety of regular expression "
"patterns for URLs, but not every possible one. The main restriction at the "
"moment is that the pattern cannot contain alternative choices using the "
"vertical bar (``\"|\"``) character. You can quite happily use such patterns "
"for matching against incoming URLs and sending them off to views, but you "
"cannot reverse such patterns."
msgstr ""
"Функция  ``reverse()`` может обработать много видов регулярных выражений, но "
"не все. Главным ограничением на данный момент это использование "
"альтернативных вариантов с помощью ``\"|\"``. Вы можете использовать такое "
"регулярное выражения в URL-шаблонах, но не сможете найти URL по нему."

# d641025c9a0946fd904c06952acbe607
#: ../../topics/http/urls.txt:846
msgid ""
"The ``current_app`` argument allows you to provide a hint to the resolver "
"indicating the application to which the currently executing view belongs. "
"This ``current_app`` argument is used as a hint to resolve application "
"namespaces into URLs on specific application instances, according to the :"
"ref:`namespaced URL resolution strategy <topics-http-reversing-url-"
"namespaces>`."
msgstr ""
"Аргумент ``current_app`` позволяет указать экземпляр приложения на которое "
"должен указывать URL. Этот экземпляр приложения будет использоваться при :"
"ref:`анализе пространства имен <topics-http-reversing-url-namespaces>`."

# 87b7605894344745a28a6d388fbc20c8
#: ../../topics/http/urls.txt:852
msgid "You can use ``kwargs`` instead of ``args``. For example::"
msgstr "Вы можете использовать ``kwargs`` вметос ``args``. Например::"

# 3a482627991f4233b0d559181f352ce9
#: ../../topics/http/urls.txt:857
msgid ""
"``args`` and ``kwargs`` cannot be passed to ``reverse()`` at the same time."
msgstr "Нельзя использовать ``args`` и ``kwargs`` вместе."

# 68bc1f49106744bea0f79e6da3c5e5be
#: ../../topics/http/urls.txt:861
msgid ""
"As part of working out which URL names map to which patterns, the ``reverse()"
"`` function has to import all of your URLconf files and examine the name of "
"each view. This involves importing each view function. If there are *any* "
"errors whilst importing any of your view functions, it will cause ``reverse()"
"`` to raise an error, even if that view function is not the one you are "
"trying to reverse."
msgstr ""
"При поиске необходимого URL-шаблона функция ``reverse()`` импортирует все "
"файлы конфигурации URL  и анализирует название каждого представления. В "
"результате чего выполняется импорт всех функций представления. Если при "
"импорте произойдет *какая-либо* ошибка, функция ``reverse()`` вызовет "
"исключение, даже если это представление не относится к URL-y который вы "
"ищете."

# aed610b0dc794d2b89a0898f2f313199
#: ../../topics/http/urls.txt:868
msgid ""
"Make sure that any views you reference in your URLconf files exist and can "
"be imported correctly. Do not include lines that reference views you haven't "
"written yet, because those views will not be importable."
msgstr ""
"Убедитесь что любое использованное в URLconf представление существует и "
"может быть импортировано без ошибок. Не указывайте еще не созданные "
"представления, потому что DJango не сможет их импортировать."

# 2213bd16dab54916a3bac592bda6635b
#: ../../topics/http/urls.txt:874
msgid ""
"The string returned by :meth:`~django.core.urlresolvers.reverse` is already :"
"ref:`urlquoted <uri-and-iri-handling>`. For example::"
msgstr ""
"Строка, которую возвращает :meth:`~django.core.urlresolvers.reverse`, уже "
"обработана функцией :ref:`urlquoted <uri-and-iri-handling>`. Например::"

# 8c97328159df4d209aa5c54c4dfb4eae
#: ../../topics/http/urls.txt:880
msgid ""
"Applying further encoding (such as :meth:`~django.utils.http.urlquote` or "
"``urllib.quote``) to the output of :meth:`~django.core.urlresolvers.reverse` "
"may produce undesirable results."
msgstr ""
"Повторное применение кодирования (функций :meth:`~django.utils.http."
"urlquote` или ``urllib.quote``) к результату :meth:`~django.core."
"urlresolvers.reverse` может привести к неожиданным результатам."

# 5823501302a54ca8be9cef78457e08f3
#: ../../topics/http/urls.txt:885
msgid "reverse_lazy()"
msgstr "reverse_lazy()"

# b834eea1bf9a4bcc9884a1da401dbb76
#: ../../topics/http/urls.txt:889
msgid "A lazily evaluated version of `reverse()`_."
msgstr "\"Ленивая\" версия `reverse()`_."

# b274381caf934eb78f3b8a4f2a323e85
#: ../../topics/http/urls.txt:893
msgid ""
"It is useful for when you need to use a URL reversal before your project's "
"URLConf is loaded. Some common cases where this function is necessary are:"
msgstr ""
"Эта функция полезна если необходимо определить поиск URL-а до загрузки "
"URLConf. Например:"

# 6eb9295cae1346058ccd324096fd98c0
#: ../../topics/http/urls.txt:896
msgid ""
"providing a reversed URL as the ``url`` attribute of a generic class-based "
"view."
msgstr ""
"указать определенный URL как атрибут ``url`` класса общего представления(a "
"generic class-based view)."

# 3a984328ed7347c39e6214aeee1897c8
#: ../../topics/http/urls.txt:899
msgid ""
"providing a reversed URL to a decorator (such as the ``login_url`` argument "
"for the :func:`django.contrib.auth.decorators.permission_required` "
"decorator)."
msgstr ""
"передать URL в декоратор (например, аргумент ``login_url`` для декоратора :"
"func:`django.contrib.auth.decorators.permission_required`)."

# 801217c8351c43318a396a5e9b5df5d5
#: ../../topics/http/urls.txt:903
msgid ""
"providing a reversed URL as a default value for a parameter in a function's "
"signature."
msgstr ""
"использование URL-а как значения по-умолчанию для аргумента при определении "
"функции."

# 8c04783ad4cd49b1b43776697183c747
#: ../../topics/http/urls.txt:907
msgid "resolve()"
msgstr "resolve()"

# b86efc8af2fa490db24ac58d89e9f14a
#: ../../topics/http/urls.txt:909
msgid ""
"The :func:`django.core.urlresolvers.resolve` function can be used for "
"resolving URL paths to the corresponding view functions. It has the "
"following signature:"
msgstr ""
"Функция :func:`django.core.urlresolvers.resolve` может быть использована для "
"поиска представления соответствующего переданному URL. Определяется она "
"таким образом:"

# 45f4eb82c32d411f9ddd4639016d719c
#: ../../topics/http/urls.txt:915
msgid ""
"``path`` is the URL path you want to resolve. As with :func:`~django.core."
"urlresolvers.reverse`, you don't need to worry about the ``urlconf`` "
"parameter. The function returns a :class:`ResolverMatch` object that allows "
"you to access various meta-data about the resolved URL."
msgstr ""
"``path`` это URL для которого ищем представление. Как и для :func:`~django."
"core.urlresolvers.reverse`, вы не должны волноваться про аргумент "
"``urlconf``. Функция возвращает объект :class:`ResolverMatch`, который "
"позволяет получить различную информацию про переданный URL."

# c95acb6404e54014a7b264873284ad95
#: ../../topics/http/urls.txt:921
msgid ""
"If the URL does not resolve, the function raises an :class:`~django.http."
"Http404` exception."
msgstr ""
"Если соответствующее представление не найдено, функция вызовет исключение :"
"class:`~django.http.Http404`."

# 7717faa8e1fb4c129d3095a2b9f10839
#: ../../topics/http/urls.txt:928
msgid "The view function that would be used to serve the URL"
msgstr ""
"Функция представления, которая будет использована для обработки переданного "
"URL-а"

# bd70f661aa6040af86d5cb101493ae2b
#: ../../topics/http/urls.txt:932
msgid ""
"The arguments that would be passed to the view function, as parsed from the "
"URL."
msgstr ""
"Аргументы, которые были получены из URL-а и будут переданы в функцию "
"представления."

# eb0378684fff47c59d1dbc0458eeb731
#: ../../topics/http/urls.txt:937
msgid ""
"The keyword arguments that would be passed to the view function, as parsed "
"from the URL."
msgstr ""
"Именованные аргументы, которые были получены из URL-а и будут переданы в "
"функцию представления."

# 756c58d0c4334a8f9e9576546acb3737
#: ../../topics/http/urls.txt:942
msgid "The name of the URL pattern that matches the URL."
msgstr "Название URL-шаблона , который соответствует переданному URL-у."

# 62c895f865314f439cd659280f372e4c
#: ../../topics/http/urls.txt:946
msgid "The application namespace for the URL pattern that matches the URL."
msgstr "Название приложения найденного URL-шаблона."

# 99af107002c147b6a31c2d8f5daeb59c
#: ../../topics/http/urls.txt:951
msgid "The instance namespace for the URL pattern that matches the URL."
msgstr "Название экземпляра приложения найденного URL-шаблона."

# 82c84ed7c0a14418bffd0d8daa8eae29
#: ../../topics/http/urls.txt:956
msgid ""
"The list of individual namespace components in the full instance namespace "
"for the URL pattern that matches the URL. i.e., if the namespace is ``foo:"
"bar``, then namespaces will be ``['foo', 'bar']``."
msgstr ""
"Список пространств имен найденного URL-шаблона. Например, если пространство "
"имени определяется как ``foo:bar``, атрибут будет равен ``['foo', 'bar']``. "

# 572ce7ba45074195b6b8a7e449591592
#: ../../topics/http/urls.txt:961
msgid ""
"A :class:`ResolverMatch` object can then be interrogated to provide "
"information about the URL pattern that matches a URL::"
msgstr ""
"Объект :class:`ResolverMatch`может использоваться для получения информации о "
"URL-шаблоне, который соответствует переданному URL-у::"

# 21338661a11142c0be86000ee29652b7
#: ../../topics/http/urls.txt:969
msgid "A :class:`ResolverMatch` object can also be assigned to a triple::"
msgstr "Объект :class:`ResolverMatch` можно присвоит трем переменным::"

# a23991f0413a468f89fd960953d8b59c
#: ../../topics/http/urls.txt:980
msgid ""
"One possible use of :func:`~django.core.urlresolvers.resolve` would be to "
"test whether a view would raise a ``Http404`` error before redirecting to "
"it::"
msgstr ""
":func:`~django.core.urlresolvers.resolve` можно использовать для проверки "
"перед перенаправлением на представление, вызовет ли оно ошибку ``Http404``::"

# 73c35696037c40c0b8b8239dd68fc5d6
#: ../../topics/http/urls.txt:1004
msgid "permalink()"
msgstr "permalink()"

# be4a682011d64648b0c6d2c189383450
#: ../../topics/http/urls.txt:1006
msgid ""
"The :func:`django.db.models.permalink` decorator is useful for writing short "
"methods that return a full URL path. For example, a model's "
"``get_absolute_url()`` method. See :func:`django.db.models.permalink` for "
"more."
msgstr ""
"Декоратор :func:`django.db.models.permalink` полезен для написания коротких "
"методов, которые возвращают полный URL. Например, метод модели "
"``get_absolute_url()`` method. Подробности смотрите в описании :func:`django."
"db.models.permalink`."

# 4057a82113934a2dbe5858a708cbdb1f
#: ../../topics/http/urls.txt:1011
msgid "get_script_prefix()"
msgstr "get_script_prefix()"

# 6403a4c4551c467a9fa416be2b626163
#: ../../topics/http/urls.txt:1015
msgid ""
"Normally, you should always use :func:`~django.core.urlresolvers.reverse` "
"or :func:`~django.db.models.permalink` to define URLs within your "
"application. However, if your application constructs part of the URL "
"hierarchy itself, you may occasionally need to generate URLs. In that case, "
"you need to be able to find the base URL of the Django project within its "
"Web server (normally, :func:`~django.core.urlresolvers.reverse` takes care "
"of this for you). In that case, you can call ``get_script_prefix()``, which "
"will return the script prefix portion of the URL for your Django project. If "
"your Django project is at the root of its Web server, this is always ``\"/"
"\"``, but it can be changed, for instance  by using ``django.root`` (see :"
"doc:`How to use Django with Apache and mod_python </howto/deployment/"
"modpython>`)."
msgstr ""
"Обычно вы будет использовать функции :func:`~django.core.urlresolvers."
"reverse` или :func:`~django.db.models.permalink` для поиска URL-а для вашего "
"приложения. Однако, если вашему приложению необходимо создать URL "
"самостоятельно, вам может понадобиться основа URL-а для проекта, которая "
"определенна в настройках Web-сервера (:func:`~django.core.urlresolvers."
"reverse` самостоятельно заботиться об этом). В этом случае вы можете "
"использовать ``get_script_prefix()``, которая вернет префикс скрипта URL-а "
"для вашего проекта. Если ваш проект находиться в корне сервера, это будет ``"
"\"/\"``, но может быть и изменен через ``django.root`` (смотрите :doc:`Как "
"использовать Django с Apache и mod_python </howto/deployment/modpython>`)."
